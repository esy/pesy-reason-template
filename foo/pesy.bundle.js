'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }
var nodePath = require('path');
var fs = _interopDefault(require('fs'));
var chalk = _interopDefault(require('chalk'));
var https = _interopDefault(require('https'));
var assert = _interopDefault(require('assert'));
var path$1 = _interopDefault(require('path'));
var util = _interopDefault(require('util'));
var events = _interopDefault(require('events'));
var downloadGitRepo = _interopDefault(require('download-git-repo'));
var request = _interopDefault(require('request'));
var requestProgress = _interopDefault(require('request-progress'));
var readline = _interopDefault(require('readline'));
var walkSync = _interopDefault(require('walk-sync'));
var sourceMapSupport = _interopDefault(require('source-map-support'));

var out_of_memory = /* tuple */[
  "Out_of_memory",
  0
];

var sys_error = /* tuple */[
  "Sys_error",
  -1
];

var failure = /* tuple */[
  "Failure",
  -2
];

var invalid_argument = /* tuple */[
  "Invalid_argument",
  -3
];

var end_of_file = /* tuple */[
  "End_of_file",
  -4
];

var division_by_zero = /* tuple */[
  "Division_by_zero",
  -5
];

var not_found = /* tuple */[
  "Not_found",
  -6
];

var match_failure = /* tuple */[
  "Match_failure",
  -7
];

var stack_overflow = /* tuple */[
  "Stack_overflow",
  -8
];

var sys_blocked_io = /* tuple */[
  "Sys_blocked_io",
  -9
];

var assert_failure = /* tuple */[
  "Assert_failure",
  -10
];

var undefined_recursive_module = /* tuple */[
  "Undefined_recursive_module",
  -11
];

out_of_memory.tag = 248;

sys_error.tag = 248;

failure.tag = 248;

invalid_argument.tag = 248;

end_of_file.tag = 248;

division_by_zero.tag = 248;

not_found.tag = 248;

match_failure.tag = 248;

stack_overflow.tag = 248;

sys_blocked_io.tag = 248;

assert_failure.tag = 248;

undefined_recursive_module.tag = 248;

var out_of_memory_1 = out_of_memory;
var sys_error_1 = sys_error;
var failure_1 = failure;
var invalid_argument_1 = invalid_argument;
var end_of_file_1 = end_of_file;
var division_by_zero_1 = division_by_zero;
var not_found_1 = not_found;
var match_failure_1 = match_failure;
var stack_overflow_1 = stack_overflow;
var sys_blocked_io_1 = sys_blocked_io;
var assert_failure_1 = assert_failure;
var undefined_recursive_module_1 = undefined_recursive_module;
/*  Not a pure module */

var caml_builtin_exceptions = {
	out_of_memory: out_of_memory_1,
	sys_error: sys_error_1,
	failure: failure_1,
	invalid_argument: invalid_argument_1,
	end_of_file: end_of_file_1,
	division_by_zero: division_by_zero_1,
	not_found: not_found_1,
	match_failure: match_failure_1,
	stack_overflow: stack_overflow_1,
	sys_blocked_io: sys_blocked_io_1,
	assert_failure: assert_failure_1,
	undefined_recursive_module: undefined_recursive_module_1
};

function caml_sys_getenv(s) {
  if (typeof process === "undefined" || (process.env) === undefined) {
    throw caml_builtin_exceptions.not_found;
  }
  var match = (process.env)[s];
  if (match !== undefined) {
    return match;
  } else {
    throw caml_builtin_exceptions.not_found;
  }
}

function caml_sys_time(param) {
  if (typeof process === "undefined" || (process.uptime) === undefined) {
    return -1;
  } else {
    return process.uptime();
  }
}

function caml_sys_random_seed(param) {
  return /* array */[((Date.now() | 0) ^ 4294967295) * Math.random() | 0];
}

function caml_sys_system_command(_cmd) {
  return 127;
}

function caml_sys_getcwd(param) {
  if (typeof process === "undefined") {
    return "/";
  } else {
    return process.cwd();
  }
}

function caml_sys_get_argv(param) {
  if (typeof process === "undefined") {
    return /* tuple */[
            "",
            /* array */[""]
          ];
  } else {
    var argv = (process.argv);
    if (argv == null) {
      return /* tuple */[
              "",
              /* array */[""]
            ];
    } else {
      return /* tuple */[
              argv[0],
              argv
            ];
    }
  }
}

function caml_sys_exit(exit_code) {
  if (typeof process !== "undefined") {
    return process.exit(exit_code);
  } else {
    return 0;
  }
}

function caml_sys_is_directory(_s) {
  throw [
        caml_builtin_exceptions.failure,
        "caml_sys_is_directory not implemented"
      ];
}

function caml_sys_file_exists(_s) {
  throw [
        caml_builtin_exceptions.failure,
        "caml_sys_file_exists not implemented"
      ];
}

var caml_sys_getenv_1 = caml_sys_getenv;
var caml_sys_time_1 = caml_sys_time;
var caml_sys_random_seed_1 = caml_sys_random_seed;
var caml_sys_system_command_1 = caml_sys_system_command;
var caml_sys_getcwd_1 = caml_sys_getcwd;
var caml_sys_get_argv_1 = caml_sys_get_argv;
var caml_sys_exit_1 = caml_sys_exit;
var caml_sys_is_directory_1 = caml_sys_is_directory;
var caml_sys_file_exists_1 = caml_sys_file_exists;
/* No side effect */

var caml_sys = {
	caml_sys_getenv: caml_sys_getenv_1,
	caml_sys_time: caml_sys_time_1,
	caml_sys_random_seed: caml_sys_random_seed_1,
	caml_sys_system_command: caml_sys_system_command_1,
	caml_sys_getcwd: caml_sys_getcwd_1,
	caml_sys_get_argv: caml_sys_get_argv_1,
	caml_sys_exit: caml_sys_exit_1,
	caml_sys_is_directory: caml_sys_is_directory_1,
	caml_sys_file_exists: caml_sys_file_exists_1
};

var id = {
  contents: 0
};

function caml_set_oo_id(b) {
  b[1] = id.contents;
  id.contents = id.contents + 1;
  return b;
}

function caml_fresh_oo_id(param) {
  id.contents = id.contents + 1;
  return id.contents;
}

function create(str) {
  var v_001 = caml_fresh_oo_id();
  var v = /* tuple */[
    str,
    v_001
  ];
  v.tag = 248;
  return v;
}

function caml_is_extension(e) {
  if (e === undefined) {
    return false;
  } else if (e.tag === 248) {
    return true;
  } else {
    var slot = e[0];
    if (slot !== undefined) {
      return slot.tag === 248;
    } else {
      return false;
    }
  }
}

var caml_set_oo_id_1 = caml_set_oo_id;
var caml_fresh_oo_id_1 = caml_fresh_oo_id;
var create_1 = create;
var caml_is_extension_1 = caml_is_extension;
/* No side effect */

var caml_exceptions = {
	caml_set_oo_id: caml_set_oo_id_1,
	caml_fresh_oo_id: caml_fresh_oo_id_1,
	create: create_1,
	caml_is_extension: caml_is_extension_1
};

var match = caml_sys.caml_sys_get_argv(/* () */0);

var backend_type = /* Other */["BS"];

var big_endian = false;

var int_size = 32;

var unix = true;

var win32 = false;

var cygwin = false;

function getenv_opt(s) {
  var match = typeof process === "undefined" ? undefined : process;
  if (match !== undefined) {
    return match.env[s];
  }
  
}

var interactive = {
  contents: false
};

function set_signal(sig_num, sig_beh) {
  return /* () */0;
}

var Break = caml_exceptions.create("Sys.Break");

function catch_break(on) {
  return /* () */0;
}

function enable_runtime_warnings(param) {
  return /* () */0;
}

function runtime_warnings_enabled(param) {
  return false;
}

var argv = match[1];

var executable_name = match[0];

var word_size = 32;

var max_string_length = 2147483647;

var max_array_length = 2147483647;

var sigabrt = -1;

var sigalrm = -2;

var sigfpe = -3;

var sighup = -4;

var sigill = -5;

var sigint = -6;

var sigkill = -7;

var sigpipe = -8;

var sigquit = -9;

var sigsegv = -10;

var sigterm = -11;

var sigusr1 = -12;

var sigusr2 = -13;

var sigchld = -14;

var sigcont = -15;

var sigstop = -16;

var sigtstp = -17;

var sigttin = -18;

var sigttou = -19;

var sigvtalrm = -20;

var sigprof = -21;

var sigbus = -22;

var sigpoll = -23;

var sigsys = -24;

var sigtrap = -25;

var sigurg = -26;

var sigxcpu = -27;

var sigxfsz = -28;

var ocaml_version = "4.06.2+BS";

var argv_1 = argv;
var executable_name_1 = executable_name;
var getenv_opt_1 = getenv_opt;
var interactive_1 = interactive;
var backend_type_1 = backend_type;
var unix_1 = unix;
var win32_1 = win32;
var cygwin_1 = cygwin;
var word_size_1 = word_size;
var int_size_1 = int_size;
var big_endian_1 = big_endian;
var max_string_length_1 = max_string_length;
var max_array_length_1 = max_array_length;
var set_signal_1 = set_signal;
var sigabrt_1 = sigabrt;
var sigalrm_1 = sigalrm;
var sigfpe_1 = sigfpe;
var sighup_1 = sighup;
var sigill_1 = sigill;
var sigint_1 = sigint;
var sigkill_1 = sigkill;
var sigpipe_1 = sigpipe;
var sigquit_1 = sigquit;
var sigsegv_1 = sigsegv;
var sigterm_1 = sigterm;
var sigusr1_1 = sigusr1;
var sigusr2_1 = sigusr2;
var sigchld_1 = sigchld;
var sigcont_1 = sigcont;
var sigstop_1 = sigstop;
var sigtstp_1 = sigtstp;
var sigttin_1 = sigttin;
var sigttou_1 = sigttou;
var sigvtalrm_1 = sigvtalrm;
var sigprof_1 = sigprof;
var sigbus_1 = sigbus;
var sigpoll_1 = sigpoll;
var sigsys_1 = sigsys;
var sigtrap_1 = sigtrap;
var sigurg_1 = sigurg;
var sigxcpu_1 = sigxcpu;
var sigxfsz_1 = sigxfsz;
var Break_1 = Break;
var catch_break_1 = catch_break;
var ocaml_version_1 = ocaml_version;
var enable_runtime_warnings_1 = enable_runtime_warnings;
var runtime_warnings_enabled_1 = runtime_warnings_enabled;
/* No side effect */

var sys = {
	argv: argv_1,
	executable_name: executable_name_1,
	getenv_opt: getenv_opt_1,
	interactive: interactive_1,
	backend_type: backend_type_1,
	unix: unix_1,
	win32: win32_1,
	cygwin: cygwin_1,
	word_size: word_size_1,
	int_size: int_size_1,
	big_endian: big_endian_1,
	max_string_length: max_string_length_1,
	max_array_length: max_array_length_1,
	set_signal: set_signal_1,
	sigabrt: sigabrt_1,
	sigalrm: sigalrm_1,
	sigfpe: sigfpe_1,
	sighup: sighup_1,
	sigill: sigill_1,
	sigint: sigint_1,
	sigkill: sigkill_1,
	sigpipe: sigpipe_1,
	sigquit: sigquit_1,
	sigsegv: sigsegv_1,
	sigterm: sigterm_1,
	sigusr1: sigusr1_1,
	sigusr2: sigusr2_1,
	sigchld: sigchld_1,
	sigcont: sigcont_1,
	sigstop: sigstop_1,
	sigtstp: sigtstp_1,
	sigttin: sigttin_1,
	sigttou: sigttou_1,
	sigvtalrm: sigvtalrm_1,
	sigprof: sigprof_1,
	sigbus: sigbus_1,
	sigpoll: sigpoll_1,
	sigsys: sigsys_1,
	sigtrap: sigtrap_1,
	sigurg: sigurg_1,
	sigxcpu: sigxcpu_1,
	sigxfsz: sigxfsz_1,
	Break: Break_1,
	catch_break: catch_break_1,
	ocaml_version: ocaml_version_1,
	enable_runtime_warnings: enable_runtime_warnings_1,
	runtime_warnings_enabled: runtime_warnings_enabled_1
};

function caml_array_sub(x, offset, len) {
  var result = new Array(len);
  var j = 0;
  var i = offset;
  while(j < len) {
    result[j] = x[i];
    j = j + 1 | 0;
    i = i + 1 | 0;
  }  return result;
}

function len(_acc, _l) {
  while(true) {
    var l = _l;
    var acc = _acc;
    if (l) {
      _l = l[1];
      _acc = l[0].length + acc | 0;
      continue ;
    } else {
      return acc;
    }
  }}

function fill(arr, _i, _l) {
  while(true) {
    var l = _l;
    var i = _i;
    if (l) {
      var x = l[0];
      var l$1 = x.length;
      var k = i;
      var j = 0;
      while(j < l$1) {
        arr[k] = x[j];
        k = k + 1 | 0;
        j = j + 1 | 0;
      }      _l = l[1];
      _i = k;
      continue ;
    } else {
      return /* () */0;
    }
  }}

function caml_array_concat(l) {
  var v = len(0, l);
  var result = new Array(v);
  fill(result, 0, l);
  return result;
}

function caml_array_set(xs, index, newval) {
  if (index < 0 || index >= xs.length) {
    throw [
          caml_builtin_exceptions.invalid_argument,
          "index out of bounds"
        ];
  }
  xs[index] = newval;
  return /* () */0;
}

function caml_array_get(xs, index) {
  if (index < 0 || index >= xs.length) {
    throw [
          caml_builtin_exceptions.invalid_argument,
          "index out of bounds"
        ];
  }
  return xs[index];
}

function caml_make_vect(len, init) {
  var b = new Array(len);
  for(var i = 0 ,i_finish = len - 1 | 0; i <= i_finish; ++i){
    b[i] = init;
  }
  return b;
}

function caml_make_float_vect(len) {
  var b = new Array(len);
  for(var i = 0 ,i_finish = len - 1 | 0; i <= i_finish; ++i){
    b[i] = 0;
  }
  return b;
}

function caml_array_blit(a1, i1, a2, i2, len) {
  if (i2 <= i1) {
    for(var j = 0 ,j_finish = len - 1 | 0; j <= j_finish; ++j){
      a2[j + i2 | 0] = a1[j + i1 | 0];
    }
    return /* () */0;
  } else {
    for(var j$1 = len - 1 | 0; j$1 >= 0; --j$1){
      a2[j$1 + i2 | 0] = a1[j$1 + i1 | 0];
    }
    return /* () */0;
  }
}

function caml_array_dup(prim) {
  return prim.slice(0);
}

var caml_array_dup_1 = caml_array_dup;
var caml_array_sub_1 = caml_array_sub;
var caml_array_concat_1 = caml_array_concat;
var caml_make_vect_1 = caml_make_vect;
var caml_make_float_vect_1 = caml_make_float_vect;
var caml_array_blit_1 = caml_array_blit;
var caml_array_get_1 = caml_array_get;
var caml_array_set_1 = caml_array_set;
/* No side effect */

var caml_array = {
	caml_array_dup: caml_array_dup_1,
	caml_array_sub: caml_array_sub_1,
	caml_array_concat: caml_array_concat_1,
	caml_make_vect: caml_make_vect_1,
	caml_make_float_vect: caml_make_float_vect_1,
	caml_array_blit: caml_array_blit_1,
	caml_array_get: caml_array_get_1,
	caml_array_set: caml_array_set_1
};

function app(_f, _args) {
  while(true) {
    var args = _args;
    var f = _f;
    var init_arity = f.length;
    var arity = init_arity === 0 ? 1 : init_arity;
    var len = args.length;
    var d = arity - len | 0;
    if (d === 0) {
      return f.apply(null, args);
    } else if (d < 0) {
      _args = caml_array.caml_array_sub(args, arity, -d | 0);
      _f = f.apply(null, caml_array.caml_array_sub(args, 0, arity));
      continue ;
    } else {
      return (function(f,args){
      return function (x) {
        return app(f, args.concat(/* array */[x]));
      }
      }(f,args));
    }
  }}

function curry_1(o, a0, arity) {
  switch (arity) {
    case 1 :
        return o(a0);
    case 2 :
        return (function (param) {
            return o(a0, param);
          });
    case 3 :
        return (function (param, param$1) {
            return o(a0, param, param$1);
          });
    case 4 :
        return (function (param, param$1, param$2) {
            return o(a0, param, param$1, param$2);
          });
    case 5 :
        return (function (param, param$1, param$2, param$3) {
            return o(a0, param, param$1, param$2, param$3);
          });
    case 6 :
        return (function (param, param$1, param$2, param$3, param$4) {
            return o(a0, param, param$1, param$2, param$3, param$4);
          });
    case 7 :
        return (function (param, param$1, param$2, param$3, param$4, param$5) {
            return o(a0, param, param$1, param$2, param$3, param$4, param$5);
          });
    default:
      return app(o, /* array */[a0]);
  }
}

function _1(o, a0) {
  var arity = o.length;
  if (arity === 1) {
    return o(a0);
  } else {
    return curry_1(o, a0, arity);
  }
}

function __1(o) {
  var arity = o.length;
  if (arity === 1) {
    return o;
  } else {
    return (function (a0) {
        return _1(o, a0);
      });
  }
}

function curry_2(o, a0, a1, arity) {
  switch (arity) {
    case 1 :
        return app(o(a0), /* array */[a1]);
    case 2 :
        return o(a0, a1);
    case 3 :
        return (function (param) {
            return o(a0, a1, param);
          });
    case 4 :
        return (function (param, param$1) {
            return o(a0, a1, param, param$1);
          });
    case 5 :
        return (function (param, param$1, param$2) {
            return o(a0, a1, param, param$1, param$2);
          });
    case 6 :
        return (function (param, param$1, param$2, param$3) {
            return o(a0, a1, param, param$1, param$2, param$3);
          });
    case 7 :
        return (function (param, param$1, param$2, param$3, param$4) {
            return o(a0, a1, param, param$1, param$2, param$3, param$4);
          });
    default:
      return app(o, /* array */[
                  a0,
                  a1
                ]);
  }
}

function _2(o, a0, a1) {
  var arity = o.length;
  if (arity === 2) {
    return o(a0, a1);
  } else {
    return curry_2(o, a0, a1, arity);
  }
}

function __2(o) {
  var arity = o.length;
  if (arity === 2) {
    return o;
  } else {
    return (function (a0, a1) {
        return _2(o, a0, a1);
      });
  }
}

function curry_3(o, a0, a1, a2, arity) {
  switch (arity) {
    case 1 :
        return app(o(a0), /* array */[
                    a1,
                    a2
                  ]);
    case 2 :
        return app(o(a0, a1), /* array */[a2]);
    case 3 :
        return o(a0, a1, a2);
    case 4 :
        return (function (param) {
            return o(a0, a1, a2, param);
          });
    case 5 :
        return (function (param, param$1) {
            return o(a0, a1, a2, param, param$1);
          });
    case 6 :
        return (function (param, param$1, param$2) {
            return o(a0, a1, a2, param, param$1, param$2);
          });
    case 7 :
        return (function (param, param$1, param$2, param$3) {
            return o(a0, a1, a2, param, param$1, param$2, param$3);
          });
    default:
      return app(o, /* array */[
                  a0,
                  a1,
                  a2
                ]);
  }
}

function _3(o, a0, a1, a2) {
  var arity = o.length;
  if (arity === 3) {
    return o(a0, a1, a2);
  } else {
    return curry_3(o, a0, a1, a2, arity);
  }
}

function __3(o) {
  var arity = o.length;
  if (arity === 3) {
    return o;
  } else {
    return (function (a0, a1, a2) {
        return _3(o, a0, a1, a2);
      });
  }
}

function curry_4(o, a0, a1, a2, a3, arity) {
  switch (arity) {
    case 1 :
        return app(o(a0), /* array */[
                    a1,
                    a2,
                    a3
                  ]);
    case 2 :
        return app(o(a0, a1), /* array */[
                    a2,
                    a3
                  ]);
    case 3 :
        return app(o(a0, a1, a2), /* array */[a3]);
    case 4 :
        return o(a0, a1, a2, a3);
    case 5 :
        return (function (param) {
            return o(a0, a1, a2, a3, param);
          });
    case 6 :
        return (function (param, param$1) {
            return o(a0, a1, a2, a3, param, param$1);
          });
    case 7 :
        return (function (param, param$1, param$2) {
            return o(a0, a1, a2, a3, param, param$1, param$2);
          });
    default:
      return app(o, /* array */[
                  a0,
                  a1,
                  a2,
                  a3
                ]);
  }
}

function _4(o, a0, a1, a2, a3) {
  var arity = o.length;
  if (arity === 4) {
    return o(a0, a1, a2, a3);
  } else {
    return curry_4(o, a0, a1, a2, a3, arity);
  }
}

function __4(o) {
  var arity = o.length;
  if (arity === 4) {
    return o;
  } else {
    return (function (a0, a1, a2, a3) {
        return _4(o, a0, a1, a2, a3);
      });
  }
}

function curry_5(o, a0, a1, a2, a3, a4, arity) {
  switch (arity) {
    case 1 :
        return app(o(a0), /* array */[
                    a1,
                    a2,
                    a3,
                    a4
                  ]);
    case 2 :
        return app(o(a0, a1), /* array */[
                    a2,
                    a3,
                    a4
                  ]);
    case 3 :
        return app(o(a0, a1, a2), /* array */[
                    a3,
                    a4
                  ]);
    case 4 :
        return app(o(a0, a1, a2, a3), /* array */[a4]);
    case 5 :
        return o(a0, a1, a2, a3, a4);
    case 6 :
        return (function (param) {
            return o(a0, a1, a2, a3, a4, param);
          });
    case 7 :
        return (function (param, param$1) {
            return o(a0, a1, a2, a3, a4, param, param$1);
          });
    default:
      return app(o, /* array */[
                  a0,
                  a1,
                  a2,
                  a3,
                  a4
                ]);
  }
}

function _5(o, a0, a1, a2, a3, a4) {
  var arity = o.length;
  if (arity === 5) {
    return o(a0, a1, a2, a3, a4);
  } else {
    return curry_5(o, a0, a1, a2, a3, a4, arity);
  }
}

function __5(o) {
  var arity = o.length;
  if (arity === 5) {
    return o;
  } else {
    return (function (a0, a1, a2, a3, a4) {
        return _5(o, a0, a1, a2, a3, a4);
      });
  }
}

function curry_6(o, a0, a1, a2, a3, a4, a5, arity) {
  switch (arity) {
    case 1 :
        return app(o(a0), /* array */[
                    a1,
                    a2,
                    a3,
                    a4,
                    a5
                  ]);
    case 2 :
        return app(o(a0, a1), /* array */[
                    a2,
                    a3,
                    a4,
                    a5
                  ]);
    case 3 :
        return app(o(a0, a1, a2), /* array */[
                    a3,
                    a4,
                    a5
                  ]);
    case 4 :
        return app(o(a0, a1, a2, a3), /* array */[
                    a4,
                    a5
                  ]);
    case 5 :
        return app(o(a0, a1, a2, a3, a4), /* array */[a5]);
    case 6 :
        return o(a0, a1, a2, a3, a4, a5);
    case 7 :
        return (function (param) {
            return o(a0, a1, a2, a3, a4, a5, param);
          });
    default:
      return app(o, /* array */[
                  a0,
                  a1,
                  a2,
                  a3,
                  a4,
                  a5
                ]);
  }
}

function _6(o, a0, a1, a2, a3, a4, a5) {
  var arity = o.length;
  if (arity === 6) {
    return o(a0, a1, a2, a3, a4, a5);
  } else {
    return curry_6(o, a0, a1, a2, a3, a4, a5, arity);
  }
}

function __6(o) {
  var arity = o.length;
  if (arity === 6) {
    return o;
  } else {
    return (function (a0, a1, a2, a3, a4, a5) {
        return _6(o, a0, a1, a2, a3, a4, a5);
      });
  }
}

function curry_7(o, a0, a1, a2, a3, a4, a5, a6, arity) {
  switch (arity) {
    case 1 :
        return app(o(a0), /* array */[
                    a1,
                    a2,
                    a3,
                    a4,
                    a5,
                    a6
                  ]);
    case 2 :
        return app(o(a0, a1), /* array */[
                    a2,
                    a3,
                    a4,
                    a5,
                    a6
                  ]);
    case 3 :
        return app(o(a0, a1, a2), /* array */[
                    a3,
                    a4,
                    a5,
                    a6
                  ]);
    case 4 :
        return app(o(a0, a1, a2, a3), /* array */[
                    a4,
                    a5,
                    a6
                  ]);
    case 5 :
        return app(o(a0, a1, a2, a3, a4), /* array */[
                    a5,
                    a6
                  ]);
    case 6 :
        return app(o(a0, a1, a2, a3, a4, a5), /* array */[a6]);
    case 7 :
        return o(a0, a1, a2, a3, a4, a5, a6);
    default:
      return app(o, /* array */[
                  a0,
                  a1,
                  a2,
                  a3,
                  a4,
                  a5,
                  a6
                ]);
  }
}

function _7(o, a0, a1, a2, a3, a4, a5, a6) {
  var arity = o.length;
  if (arity === 7) {
    return o(a0, a1, a2, a3, a4, a5, a6);
  } else {
    return curry_7(o, a0, a1, a2, a3, a4, a5, a6, arity);
  }
}

function __7(o) {
  var arity = o.length;
  if (arity === 7) {
    return o;
  } else {
    return (function (a0, a1, a2, a3, a4, a5, a6) {
        return _7(o, a0, a1, a2, a3, a4, a5, a6);
      });
  }
}

function curry_8(o, a0, a1, a2, a3, a4, a5, a6, a7, arity) {
  switch (arity) {
    case 1 :
        return app(o(a0), /* array */[
                    a1,
                    a2,
                    a3,
                    a4,
                    a5,
                    a6,
                    a7
                  ]);
    case 2 :
        return app(o(a0, a1), /* array */[
                    a2,
                    a3,
                    a4,
                    a5,
                    a6,
                    a7
                  ]);
    case 3 :
        return app(o(a0, a1, a2), /* array */[
                    a3,
                    a4,
                    a5,
                    a6,
                    a7
                  ]);
    case 4 :
        return app(o(a0, a1, a2, a3), /* array */[
                    a4,
                    a5,
                    a6,
                    a7
                  ]);
    case 5 :
        return app(o(a0, a1, a2, a3, a4), /* array */[
                    a5,
                    a6,
                    a7
                  ]);
    case 6 :
        return app(o(a0, a1, a2, a3, a4, a5), /* array */[
                    a6,
                    a7
                  ]);
    case 7 :
        return app(o(a0, a1, a2, a3, a4, a5, a6), /* array */[a7]);
    default:
      return app(o, /* array */[
                  a0,
                  a1,
                  a2,
                  a3,
                  a4,
                  a5,
                  a6,
                  a7
                ]);
  }
}

function _8(o, a0, a1, a2, a3, a4, a5, a6, a7) {
  var arity = o.length;
  if (arity === 8) {
    return o(a0, a1, a2, a3, a4, a5, a6, a7);
  } else {
    return curry_8(o, a0, a1, a2, a3, a4, a5, a6, a7, arity);
  }
}

function __8(o) {
  var arity = o.length;
  if (arity === 8) {
    return o;
  } else {
    return (function (a0, a1, a2, a3, a4, a5, a6, a7) {
        return _8(o, a0, a1, a2, a3, a4, a5, a6, a7);
      });
  }
}

var app_1 = app;
var curry_1_1 = curry_1;
var _1_1 = _1;
var __1_1 = __1;
var curry_2_1 = curry_2;
var _2_1 = _2;
var __2_1 = __2;
var curry_3_1 = curry_3;
var _3_1 = _3;
var __3_1 = __3;
var curry_4_1 = curry_4;
var _4_1 = _4;
var __4_1 = __4;
var curry_5_1 = curry_5;
var _5_1 = _5;
var __5_1 = __5;
var curry_6_1 = curry_6;
var _6_1 = _6;
var __6_1 = __6;
var curry_7_1 = curry_7;
var _7_1 = _7;
var __7_1 = __7;
var curry_8_1 = curry_8;
var _8_1 = _8;
var __8_1 = __8;
/* No side effect */

var curry = {
	app: app_1,
	curry_1: curry_1_1,
	_1: _1_1,
	__1: __1_1,
	curry_2: curry_2_1,
	_2: _2_1,
	__2: __2_1,
	curry_3: curry_3_1,
	_3: _3_1,
	__3: __3_1,
	curry_4: curry_4_1,
	_4: _4_1,
	__4: __4_1,
	curry_5: curry_5_1,
	_5: _5_1,
	__5: __5_1,
	curry_6: curry_6_1,
	_6: _6_1,
	__6: __6_1,
	curry_7: curry_7_1,
	_7: _7_1,
	__7: __7_1,
	curry_8: curry_8_1,
	_8: _8_1,
	__8: __8_1
};

function __(tag, block) {
  block.tag = tag;
  return block;
}

var ___1 = __;
/* No side effect */

var block = {
	__: ___1
};

function caml_int_compare(x, y) {
  if (x < y) {
    return -1;
  } else if (x === y) {
    return 0;
  } else {
    return 1;
  }
}

function caml_bool_compare(x, y) {
  if (x) {
    if (y) {
      return 0;
    } else {
      return 1;
    }
  } else if (y) {
    return -1;
  } else {
    return 0;
  }
}

function caml_float_compare(x, y) {
  if (x === y) {
    return 0;
  } else if (x < y) {
    return -1;
  } else if (x > y || x === x) {
    return 1;
  } else if (y === y) {
    return -1;
  } else {
    return 0;
  }
}

function caml_string_compare(s1, s2) {
  if (s1 === s2) {
    return 0;
  } else if (s1 < s2) {
    return -1;
  } else {
    return 1;
  }
}

function caml_bytes_compare_aux(s1, s2, _off, len, def) {
  while(true) {
    var off = _off;
    if (off < len) {
      var a = s1[off];
      var b = s2[off];
      if (a > b) {
        return 1;
      } else if (a < b) {
        return -1;
      } else {
        _off = off + 1 | 0;
        continue ;
      }
    } else {
      return def;
    }
  }}

function caml_bytes_compare(s1, s2) {
  var len1 = s1.length;
  var len2 = s2.length;
  if (len1 === len2) {
    return caml_bytes_compare_aux(s1, s2, 0, len1, 0);
  } else if (len1 < len2) {
    return caml_bytes_compare_aux(s1, s2, 0, len1, -1);
  } else {
    return caml_bytes_compare_aux(s1, s2, 0, len2, 1);
  }
}

function caml_bytes_equal(s1, s2) {
  var len1 = s1.length;
  var len2 = s2.length;
  if (len1 === len2) {
    var s1$1 = s1;
    var s2$1 = s2;
    var _off = 0;
    var len = len1;
    while(true) {
      var off = _off;
      if (off === len) {
        return true;
      } else {
        var a = s1$1[off];
        var b = s2$1[off];
        if (a === b) {
          _off = off + 1 | 0;
          continue ;
        } else {
          return false;
        }
      }
    }  } else {
    return false;
  }
}

function caml_bool_min(x, y) {
  if (x) {
    return y;
  } else {
    return x;
  }
}

function caml_int_min(x, y) {
  if (x < y) {
    return x;
  } else {
    return y;
  }
}

function caml_float_min(x, y) {
  if (x < y) {
    return x;
  } else {
    return y;
  }
}

function caml_string_min(x, y) {
  if (x < y) {
    return x;
  } else {
    return y;
  }
}

function caml_nativeint_min(x, y) {
  if (x < y) {
    return x;
  } else {
    return y;
  }
}

function caml_int32_min(x, y) {
  if (x < y) {
    return x;
  } else {
    return y;
  }
}

function caml_bool_max(x, y) {
  if (x) {
    return x;
  } else {
    return y;
  }
}

function caml_int_max(x, y) {
  if (x > y) {
    return x;
  } else {
    return y;
  }
}

function caml_float_max(x, y) {
  if (x > y) {
    return x;
  } else {
    return y;
  }
}

function caml_string_max(x, y) {
  if (x > y) {
    return x;
  } else {
    return y;
  }
}

function caml_nativeint_max(x, y) {
  if (x > y) {
    return x;
  } else {
    return y;
  }
}

function caml_int32_max(x, y) {
  if (x > y) {
    return x;
  } else {
    return y;
  }
}

var caml_nativeint_compare = caml_int_compare;

var caml_int32_compare = caml_int_compare;

var caml_bytes_compare_1 = caml_bytes_compare;
var caml_bytes_equal_1 = caml_bytes_equal;
var caml_int_compare_1 = caml_int_compare;
var caml_bool_compare_1 = caml_bool_compare;
var caml_float_compare_1 = caml_float_compare;
var caml_nativeint_compare_1 = caml_nativeint_compare;
var caml_string_compare_1 = caml_string_compare;
var caml_int32_compare_1 = caml_int32_compare;
var caml_bool_min_1 = caml_bool_min;
var caml_int_min_1 = caml_int_min;
var caml_float_min_1 = caml_float_min;
var caml_string_min_1 = caml_string_min;
var caml_nativeint_min_1 = caml_nativeint_min;
var caml_int32_min_1 = caml_int32_min;
var caml_bool_max_1 = caml_bool_max;
var caml_int_max_1 = caml_int_max;
var caml_float_max_1 = caml_float_max;
var caml_string_max_1 = caml_string_max;
var caml_nativeint_max_1 = caml_nativeint_max;
var caml_int32_max_1 = caml_int32_max;
/* No side effect */

var caml_primitive = {
	caml_bytes_compare: caml_bytes_compare_1,
	caml_bytes_equal: caml_bytes_equal_1,
	caml_int_compare: caml_int_compare_1,
	caml_bool_compare: caml_bool_compare_1,
	caml_float_compare: caml_float_compare_1,
	caml_nativeint_compare: caml_nativeint_compare_1,
	caml_string_compare: caml_string_compare_1,
	caml_int32_compare: caml_int32_compare_1,
	caml_bool_min: caml_bool_min_1,
	caml_int_min: caml_int_min_1,
	caml_float_min: caml_float_min_1,
	caml_string_min: caml_string_min_1,
	caml_nativeint_min: caml_nativeint_min_1,
	caml_int32_min: caml_int32_min_1,
	caml_bool_max: caml_bool_max_1,
	caml_int_max: caml_int_max_1,
	caml_float_max: caml_float_max_1,
	caml_string_max: caml_string_max_1,
	caml_nativeint_max: caml_nativeint_max_1,
	caml_int32_max: caml_int32_max_1
};

function for_in (o,foo){
        for (var x in o) { foo(x); }
      }
function caml_obj_block(tag, size) {
  var v = new Array(size);
  v.tag = tag;
  return v;
}

function caml_obj_dup(x) {
  if (Array.isArray(x)) {
    var len = x.length | 0;
    var v = new Array(len);
    for(var i = 0 ,i_finish = len - 1 | 0; i <= i_finish; ++i){
      v[i] = x[i];
    }
    v.tag = x.tag | 0;
    return v;
  } else {
    return Object.assign(({}), x);
  }
}

function caml_obj_truncate(x, new_size) {
  var len = x.length | 0;
  if (new_size <= 0 || new_size > len) {
    throw [
          caml_builtin_exceptions.invalid_argument,
          "Obj.truncate"
        ];
  }
  if (len !== new_size) {
    for(var i = new_size ,i_finish = len - 1 | 0; i <= i_finish; ++i){
      x[i] = 0;
    }
    x.length = new_size;
    return /* () */0;
  } else {
    return 0;
  }
}

function caml_lazy_make_forward(x) {
  return block.__(250, [x]);
}

function caml_lazy_make(fn) {
  var block = /* array */[fn];
  block.tag = 246;
  return block;
}

function caml_update_dummy (x,y){
  for (var k in y){
    x[k] = y[k];
  }
  return 0;
}
function caml_compare(_a, _b) {
  while(true) {
    var b = _b;
    var a = _a;
    if (a === b) {
      return 0;
    } else {
      var a_type = typeof a;
      var b_type = typeof b;
      switch (a_type) {
        case "boolean" :
            if (b_type === "boolean") {
              return caml_primitive.caml_bool_compare(a, b);
            }
            break;
        case "function" :
            if (b_type === "function") {
              throw [
                    caml_builtin_exceptions.invalid_argument,
                    "compare: functional value"
                  ];
            }
            break;
        case "number" :
            if (b_type === "number") {
              return caml_primitive.caml_int_compare(a, b);
            }
            break;
        case "string" :
            if (b_type === "string") {
              return caml_primitive.caml_string_compare(a, b);
            } else {
              return 1;
            }
        case "undefined" :
            return -1;
          
      }
      switch (b_type) {
        case "string" :
            return -1;
        case "undefined" :
            return 1;
        default:
          if (a_type === "boolean") {
            return 1;
          } else if (b_type === "boolean") {
            return -1;
          } else if (a_type === "function") {
            return 1;
          } else if (b_type === "function") {
            return -1;
          } else if (a_type === "number") {
            if (b === null || b.tag === 256) {
              return 1;
            } else {
              return -1;
            }
          } else if (b_type === "number") {
            if (a === null || a.tag === 256) {
              return -1;
            } else {
              return 1;
            }
          } else if (a === null) {
            if (b.tag === 256) {
              return 1;
            } else {
              return -1;
            }
          } else if (b === null) {
            if (a.tag === 256) {
              return -1;
            } else {
              return 1;
            }
          } else {
            var tag_a = a.tag | 0;
            var tag_b = b.tag | 0;
            if (tag_a === 250) {
              _a = a[0];
              continue ;
            } else if (tag_b === 250) {
              _b = b[0];
              continue ;
            } else if (tag_a === 256) {
              if (tag_b === 256) {
                return caml_primitive.caml_int_compare(a[1], b[1]);
              } else {
                return -1;
              }
            } else if (tag_a === 248) {
              return caml_primitive.caml_int_compare(a[1], b[1]);
            } else {
              if (tag_a === 251) {
                throw [
                      caml_builtin_exceptions.invalid_argument,
                      "equal: abstract value"
                    ];
              }
              if (tag_a !== tag_b) {
                if (tag_a < tag_b) {
                  return -1;
                } else {
                  return 1;
                }
              } else {
                var len_a = a.length | 0;
                var len_b = b.length | 0;
                if (len_a === len_b) {
                  if (Array.isArray(a)) {
                    var a$1 = a;
                    var b$1 = b;
                    var _i = 0;
                    var same_length = len_a;
                    while(true) {
                      var i = _i;
                      if (i === same_length) {
                        return 0;
                      } else {
                        var res = caml_compare(a$1[i], b$1[i]);
                        if (res !== 0) {
                          return res;
                        } else {
                          _i = i + 1 | 0;
                          continue ;
                        }
                      }
                    }                  } else if ((a instanceof Date && b instanceof Date)) {
                    return (a - b);
                  } else {
                    var a$2 = a;
                    var b$2 = b;
                    var min_key_lhs = {
                      contents: undefined
                    };
                    var min_key_rhs = {
                      contents: undefined
                    };
                    var do_key = function (param, key) {
                      var min_key = param[2];
                      var b = param[1];
                      if (!b.hasOwnProperty(key) || caml_compare(param[0][key], b[key]) > 0) {
                        var match = min_key.contents;
                        if (match !== undefined && key >= match) {
                          return 0;
                        } else {
                          min_key.contents = key;
                          return /* () */0;
                        }
                      } else {
                        return 0;
                      }
                    };
                    var partial_arg = /* tuple */[
                      a$2,
                      b$2,
                      min_key_rhs
                    ];
                    var do_key_a = (function(partial_arg){
                    return function do_key_a(param) {
                      return do_key(partial_arg, param);
                    }
                    }(partial_arg));
                    var partial_arg$1 = /* tuple */[
                      b$2,
                      a$2,
                      min_key_lhs
                    ];
                    var do_key_b = (function(partial_arg$1){
                    return function do_key_b(param) {
                      return do_key(partial_arg$1, param);
                    }
                    }(partial_arg$1));
                    for_in(a$2, do_key_a);
                    for_in(b$2, do_key_b);
                    var match = min_key_lhs.contents;
                    var match$1 = min_key_rhs.contents;
                    if (match !== undefined) {
                      if (match$1 !== undefined) {
                        return caml_primitive.caml_string_compare(match, match$1);
                      } else {
                        return -1;
                      }
                    } else if (match$1 !== undefined) {
                      return 1;
                    } else {
                      return 0;
                    }
                  }
                } else if (len_a < len_b) {
                  var a$3 = a;
                  var b$3 = b;
                  var _i$1 = 0;
                  var short_length = len_a;
                  while(true) {
                    var i$1 = _i$1;
                    if (i$1 === short_length) {
                      return -1;
                    } else {
                      var res$1 = caml_compare(a$3[i$1], b$3[i$1]);
                      if (res$1 !== 0) {
                        return res$1;
                      } else {
                        _i$1 = i$1 + 1 | 0;
                        continue ;
                      }
                    }
                  }                } else {
                  var a$4 = a;
                  var b$4 = b;
                  var _i$2 = 0;
                  var short_length$1 = len_b;
                  while(true) {
                    var i$2 = _i$2;
                    if (i$2 === short_length$1) {
                      return 1;
                    } else {
                      var res$2 = caml_compare(a$4[i$2], b$4[i$2]);
                      if (res$2 !== 0) {
                        return res$2;
                      } else {
                        _i$2 = i$2 + 1 | 0;
                        continue ;
                      }
                    }
                  }                }
              }
            }
          }
      }
    }
  }}

function caml_equal(_a, _b) {
  while(true) {
    var b = _b;
    var a = _a;
    if (a === b) {
      return true;
    } else {
      var a_type = typeof a;
      if (a_type === "string" || a_type === "number" || a_type === "boolean" || a_type === "undefined" || a === null) {
        return false;
      } else {
        var b_type = typeof b;
        if (a_type === "function" || b_type === "function") {
          throw [
                caml_builtin_exceptions.invalid_argument,
                "equal: functional value"
              ];
        }
        if (b_type === "number" || b_type === "undefined" || b === null) {
          return false;
        } else {
          var tag_a = a.tag | 0;
          var tag_b = b.tag | 0;
          if (tag_a === 250) {
            _a = a[0];
            continue ;
          } else if (tag_b === 250) {
            _b = b[0];
            continue ;
          } else if (tag_a === 248) {
            return a[1] === b[1];
          } else {
            if (tag_a === 251) {
              throw [
                    caml_builtin_exceptions.invalid_argument,
                    "equal: abstract value"
                  ];
            }
            if (tag_a !== tag_b) {
              return false;
            } else if (tag_a === 256) {
              return a[1] === b[1];
            } else {
              var len_a = a.length | 0;
              var len_b = b.length | 0;
              if (len_a === len_b) {
                if (Array.isArray(a)) {
                  var a$1 = a;
                  var b$1 = b;
                  var _i = 0;
                  var same_length = len_a;
                  while(true) {
                    var i = _i;
                    if (i === same_length) {
                      return true;
                    } else if (caml_equal(a$1[i], b$1[i])) {
                      _i = i + 1 | 0;
                      continue ;
                    } else {
                      return false;
                    }
                  }                } else if ((a instanceof Date && b instanceof Date)) {
                  return !(a > b || a < b);
                } else {
                  var a$2 = a;
                  var b$2 = b;
                  var result = {
                    contents: true
                  };
                  var do_key_a = (function(b$2,result){
                  return function do_key_a(key) {
                    if (b$2.hasOwnProperty(key)) {
                      return 0;
                    } else {
                      result.contents = false;
                      return /* () */0;
                    }
                  }
                  }(b$2,result));
                  var do_key_b = (function(a$2,b$2,result){
                  return function do_key_b(key) {
                    if (!a$2.hasOwnProperty(key) || !caml_equal(b$2[key], a$2[key])) {
                      result.contents = false;
                      return /* () */0;
                    } else {
                      return 0;
                    }
                  }
                  }(a$2,b$2,result));
                  for_in(a$2, do_key_a);
                  if (result.contents) {
                    for_in(b$2, do_key_b);
                  }
                  return result.contents;
                }
              } else {
                return false;
              }
            }
          }
        }
      }
    }
  }}

function caml_equal_null(x, y) {
  if (y !== null) {
    return caml_equal(x, y);
  } else {
    return x === y;
  }
}

function caml_equal_undefined(x, y) {
  if (y !== undefined) {
    return caml_equal(x, y);
  } else {
    return x === y;
  }
}

function caml_equal_nullable(x, y) {
  if (y == null) {
    return x === y;
  } else {
    return caml_equal(x, y);
  }
}

function caml_notequal(a, b) {
  return !caml_equal(a, b);
}

function caml_greaterequal(a, b) {
  return caml_compare(a, b) >= 0;
}

function caml_greaterthan(a, b) {
  return caml_compare(a, b) > 0;
}

function caml_lessequal(a, b) {
  return caml_compare(a, b) <= 0;
}

function caml_lessthan(a, b) {
  return caml_compare(a, b) < 0;
}

function caml_min(x, y) {
  if (caml_compare(x, y) <= 0) {
    return x;
  } else {
    return y;
  }
}

function caml_max(x, y) {
  if (caml_compare(x, y) >= 0) {
    return x;
  } else {
    return y;
  }
}

function caml_obj_set_tag(prim, prim$1) {
  prim.tag = prim$1;
  return /* () */0;
}

var caml_obj_block_1 = caml_obj_block;
var caml_obj_dup_1 = caml_obj_dup;
var caml_obj_truncate_1 = caml_obj_truncate;
var caml_lazy_make_forward_1 = caml_lazy_make_forward;
var caml_lazy_make_1 = caml_lazy_make;
var caml_update_dummy_1 = caml_update_dummy;
var caml_compare_1 = caml_compare;
var caml_equal_1 = caml_equal;
var caml_equal_null_1 = caml_equal_null;
var caml_equal_undefined_1 = caml_equal_undefined;
var caml_equal_nullable_1 = caml_equal_nullable;
var caml_notequal_1 = caml_notequal;
var caml_greaterequal_1 = caml_greaterequal;
var caml_greaterthan_1 = caml_greaterthan;
var caml_lessthan_1 = caml_lessthan;
var caml_lessequal_1 = caml_lessequal;
var caml_min_1 = caml_min;
var caml_max_1 = caml_max;
var caml_obj_set_tag_1 = caml_obj_set_tag;
/* No side effect */

var caml_obj = {
	caml_obj_block: caml_obj_block_1,
	caml_obj_dup: caml_obj_dup_1,
	caml_obj_truncate: caml_obj_truncate_1,
	caml_lazy_make_forward: caml_lazy_make_forward_1,
	caml_lazy_make: caml_lazy_make_1,
	caml_update_dummy: caml_update_dummy_1,
	caml_compare: caml_compare_1,
	caml_equal: caml_equal_1,
	caml_equal_null: caml_equal_null_1,
	caml_equal_undefined: caml_equal_undefined_1,
	caml_equal_nullable: caml_equal_nullable_1,
	caml_notequal: caml_notequal_1,
	caml_greaterequal: caml_greaterequal_1,
	caml_greaterthan: caml_greaterthan_1,
	caml_lessthan: caml_lessthan_1,
	caml_lessequal: caml_lessequal_1,
	caml_min: caml_min_1,
	caml_max: caml_max_1,
	caml_obj_set_tag: caml_obj_set_tag_1
};

var undefinedHeader = /* array */[];

function some(x) {
  if (x === undefined) {
    var block = /* tuple */[
      undefinedHeader,
      0
    ];
    block.tag = 256;
    return block;
  } else if (x !== null && x[0] === undefinedHeader) {
    var nid = x[1] + 1 | 0;
    var block$1 = /* tuple */[
      undefinedHeader,
      nid
    ];
    block$1.tag = 256;
    return block$1;
  } else {
    return x;
  }
}

function nullable_to_opt(x) {
  if (x === null || x === undefined) {
    return ;
  } else {
    return some(x);
  }
}

function undefined_to_opt(x) {
  if (x === undefined) {
    return ;
  } else {
    return some(x);
  }
}

function null_to_opt(x) {
  if (x === null) {
    return ;
  } else {
    return some(x);
  }
}

function valFromOption(x) {
  if (x !== null && x[0] === undefinedHeader) {
    var depth = x[1];
    if (depth === 0) {
      return ;
    } else {
      return /* tuple */[
              undefinedHeader,
              depth - 1 | 0
            ];
    }
  } else {
    return x;
  }
}

function option_get(x) {
  if (x === undefined) {
    return ;
  } else {
    return valFromOption(x);
  }
}

function option_get_unwrap(x) {
  if (x === undefined) {
    return ;
  } else {
    return valFromOption(x)[1];
  }
}

var nullable_to_opt_1 = nullable_to_opt;
var undefined_to_opt_1 = undefined_to_opt;
var null_to_opt_1 = null_to_opt;
var valFromOption_1 = valFromOption;
var some_1 = some;
var option_get_1 = option_get;
var option_get_unwrap_1 = option_get_unwrap;
/* No side effect */

var caml_option = {
	nullable_to_opt: nullable_to_opt_1,
	undefined_to_opt: undefined_to_opt_1,
	null_to_opt: null_to_opt_1,
	valFromOption: valFromOption_1,
	some: some_1,
	option_get: option_get_1,
	option_get_unwrap: option_get_unwrap_1
};

var $$Error = caml_exceptions.create("Caml_js_exceptions.Error");

function internalToOCamlException(e) {
  if (caml_exceptions.caml_is_extension(e)) {
    return e;
  } else {
    return [
            $$Error,
            e
          ];
  }
}

function caml_as_js_exn(exn) {
  if (exn[0] === $$Error) {
    return caml_option.some(exn[1]);
  }
  
}

var $$Error_1 = $$Error;
var internalToOCamlException_1 = internalToOCamlException;
var caml_as_js_exn_1 = caml_as_js_exn;
/* No side effect */

var caml_js_exceptions = {
	$$Error: $$Error_1,
	internalToOCamlException: internalToOCamlException_1,
	caml_as_js_exn: caml_as_js_exn_1
};

var make_float = caml_array.caml_make_float_vect;

var Floatarray = { };

function init(l, f) {
  if (l === 0) {
    return /* array */[];
  } else {
    if (l < 0) {
      throw [
            caml_builtin_exceptions.invalid_argument,
            "Array.init"
          ];
    }
    var res = caml_array.caml_make_vect(l, curry._1(f, 0));
    for(var i = 1 ,i_finish = l - 1 | 0; i <= i_finish; ++i){
      res[i] = curry._1(f, i);
    }
    return res;
  }
}

function make_matrix(sx, sy, init) {
  var res = caml_array.caml_make_vect(sx, /* array */[]);
  for(var x = 0 ,x_finish = sx - 1 | 0; x <= x_finish; ++x){
    res[x] = caml_array.caml_make_vect(sy, init);
  }
  return res;
}

function copy(a) {
  var l = a.length;
  if (l === 0) {
    return /* array */[];
  } else {
    return caml_array.caml_array_sub(a, 0, l);
  }
}

function append(a1, a2) {
  var l1 = a1.length;
  if (l1 === 0) {
    return copy(a2);
  } else if (a2.length === 0) {
    return caml_array.caml_array_sub(a1, 0, l1);
  } else {
    return a1.concat(a2);
  }
}

function sub(a, ofs, len) {
  if (ofs < 0 || len < 0 || ofs > (a.length - len | 0)) {
    throw [
          caml_builtin_exceptions.invalid_argument,
          "Array.sub"
        ];
  }
  return caml_array.caml_array_sub(a, ofs, len);
}

function fill$1(a, ofs, len, v) {
  if (ofs < 0 || len < 0 || ofs > (a.length - len | 0)) {
    throw [
          caml_builtin_exceptions.invalid_argument,
          "Array.fill"
        ];
  }
  for(var i = ofs ,i_finish = (ofs + len | 0) - 1 | 0; i <= i_finish; ++i){
    a[i] = v;
  }
  return /* () */0;
}

function blit(a1, ofs1, a2, ofs2, len) {
  if (len < 0 || ofs1 < 0 || ofs1 > (a1.length - len | 0) || ofs2 < 0 || ofs2 > (a2.length - len | 0)) {
    throw [
          caml_builtin_exceptions.invalid_argument,
          "Array.blit"
        ];
  }
  return caml_array.caml_array_blit(a1, ofs1, a2, ofs2, len);
}

function iter(f, a) {
  for(var i = 0 ,i_finish = a.length - 1 | 0; i <= i_finish; ++i){
    curry._1(f, a[i]);
  }
  return /* () */0;
}

function iter2(f, a, b) {
  if (a.length !== b.length) {
    throw [
          caml_builtin_exceptions.invalid_argument,
          "Array.iter2: arrays must have the same length"
        ];
  }
  for(var i = 0 ,i_finish = a.length - 1 | 0; i <= i_finish; ++i){
    curry._2(f, a[i], b[i]);
  }
  return /* () */0;
}

function map(f, a) {
  var l = a.length;
  if (l === 0) {
    return /* array */[];
  } else {
    var r = caml_array.caml_make_vect(l, curry._1(f, a[0]));
    for(var i = 1 ,i_finish = l - 1 | 0; i <= i_finish; ++i){
      r[i] = curry._1(f, a[i]);
    }
    return r;
  }
}

function map2(f, a, b) {
  var la = a.length;
  var lb = b.length;
  if (la !== lb) {
    throw [
          caml_builtin_exceptions.invalid_argument,
          "Array.map2: arrays must have the same length"
        ];
  }
  if (la === 0) {
    return /* array */[];
  } else {
    var r = caml_array.caml_make_vect(la, curry._2(f, a[0], b[0]));
    for(var i = 1 ,i_finish = la - 1 | 0; i <= i_finish; ++i){
      r[i] = curry._2(f, a[i], b[i]);
    }
    return r;
  }
}

function iteri(f, a) {
  for(var i = 0 ,i_finish = a.length - 1 | 0; i <= i_finish; ++i){
    curry._2(f, i, a[i]);
  }
  return /* () */0;
}

function mapi(f, a) {
  var l = a.length;
  if (l === 0) {
    return /* array */[];
  } else {
    var r = caml_array.caml_make_vect(l, curry._2(f, 0, a[0]));
    for(var i = 1 ,i_finish = l - 1 | 0; i <= i_finish; ++i){
      r[i] = curry._2(f, i, a[i]);
    }
    return r;
  }
}

function to_list(a) {
  var _i = a.length - 1 | 0;
  var _res = /* [] */0;
  while(true) {
    var res = _res;
    var i = _i;
    if (i < 0) {
      return res;
    } else {
      _res = /* :: */[
        a[i],
        res
      ];
      _i = i - 1 | 0;
      continue ;
    }
  }}

function list_length(_accu, _param) {
  while(true) {
    var param = _param;
    var accu = _accu;
    if (param) {
      _param = param[1];
      _accu = accu + 1 | 0;
      continue ;
    } else {
      return accu;
    }
  }}

function of_list(l) {
  if (l) {
    var a = caml_array.caml_make_vect(list_length(0, l), l[0]);
    var _i = 1;
    var _param = l[1];
    while(true) {
      var param = _param;
      var i = _i;
      if (param) {
        a[i] = param[0];
        _param = param[1];
        _i = i + 1 | 0;
        continue ;
      } else {
        return a;
      }
    }  } else {
    return /* array */[];
  }
}

function fold_left(f, x, a) {
  var r = x;
  for(var i = 0 ,i_finish = a.length - 1 | 0; i <= i_finish; ++i){
    r = curry._2(f, r, a[i]);
  }
  return r;
}

function fold_right(f, a, x) {
  var r = x;
  for(var i = a.length - 1 | 0; i >= 0; --i){
    r = curry._2(f, a[i], r);
  }
  return r;
}

function exists(p, a) {
  var n = a.length;
  var _i = 0;
  while(true) {
    var i = _i;
    if (i === n) {
      return false;
    } else if (curry._1(p, a[i])) {
      return true;
    } else {
      _i = i + 1 | 0;
      continue ;
    }
  }}

function for_all(p, a) {
  var n = a.length;
  var _i = 0;
  while(true) {
    var i = _i;
    if (i === n) {
      return true;
    } else if (curry._1(p, a[i])) {
      _i = i + 1 | 0;
      continue ;
    } else {
      return false;
    }
  }}

function mem(x, a) {
  var n = a.length;
  var _i = 0;
  while(true) {
    var i = _i;
    if (i === n) {
      return false;
    } else if (caml_obj.caml_equal(a[i], x)) {
      return true;
    } else {
      _i = i + 1 | 0;
      continue ;
    }
  }}

function memq(x, a) {
  var n = a.length;
  var _i = 0;
  while(true) {
    var i = _i;
    if (i === n) {
      return false;
    } else if (x === a[i]) {
      return true;
    } else {
      _i = i + 1 | 0;
      continue ;
    }
  }}

var Bottom = caml_exceptions.create("Array.Bottom");

function sort(cmp, a) {
  var maxson = function (l, i) {
    var i31 = ((i + i | 0) + i | 0) + 1 | 0;
    var x = i31;
    if ((i31 + 2 | 0) < l) {
      if (curry._2(cmp, caml_array.caml_array_get(a, i31), caml_array.caml_array_get(a, i31 + 1 | 0)) < 0) {
        x = i31 + 1 | 0;
      }
      if (curry._2(cmp, caml_array.caml_array_get(a, x), caml_array.caml_array_get(a, i31 + 2 | 0)) < 0) {
        x = i31 + 2 | 0;
      }
      return x;
    } else if ((i31 + 1 | 0) < l && curry._2(cmp, caml_array.caml_array_get(a, i31), caml_array.caml_array_get(a, i31 + 1 | 0)) < 0) {
      return i31 + 1 | 0;
    } else if (i31 < l) {
      return i31;
    } else {
      throw [
            Bottom,
            i
          ];
    }
  };
  var trickle = function (l, i, e) {
    try {
      var l$1 = l;
      var _i = i;
      var e$1 = e;
      while(true) {
        var i$1 = _i;
        var j = maxson(l$1, i$1);
        if (curry._2(cmp, caml_array.caml_array_get(a, j), e$1) > 0) {
          caml_array.caml_array_set(a, i$1, caml_array.caml_array_get(a, j));
          _i = j;
          continue ;
        } else {
          return caml_array.caml_array_set(a, i$1, e$1);
        }
      };
    }
    catch (raw_exn){
      var exn = caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn[0] === Bottom) {
        return caml_array.caml_array_set(a, exn[1], e);
      } else {
        throw exn;
      }
    }
  };
  var bubble = function (l, i) {
    try {
      var l$1 = l;
      var _i = i;
      while(true) {
        var i$1 = _i;
        var j = maxson(l$1, i$1);
        caml_array.caml_array_set(a, i$1, caml_array.caml_array_get(a, j));
        _i = j;
        continue ;
      };
    }
    catch (raw_exn){
      var exn = caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn[0] === Bottom) {
        return exn[1];
      } else {
        throw exn;
      }
    }
  };
  var trickleup = function (_i, e) {
    while(true) {
      var i = _i;
      var father = (i - 1 | 0) / 3 | 0;
      if (i === father) {
        throw [
              caml_builtin_exceptions.assert_failure,
              /* tuple */[
                "array.ml",
                238,
                4
              ]
            ];
      }
      if (curry._2(cmp, caml_array.caml_array_get(a, father), e) < 0) {
        caml_array.caml_array_set(a, i, caml_array.caml_array_get(a, father));
        if (father > 0) {
          _i = father;
          continue ;
        } else {
          return caml_array.caml_array_set(a, 0, e);
        }
      } else {
        return caml_array.caml_array_set(a, i, e);
      }
    }  };
  var l = a.length;
  for(var i = ((l + 1 | 0) / 3 | 0) - 1 | 0; i >= 0; --i){
    trickle(l, i, caml_array.caml_array_get(a, i));
  }
  for(var i$1 = l - 1 | 0; i$1 >= 2; --i$1){
    var e = caml_array.caml_array_get(a, i$1);
    caml_array.caml_array_set(a, i$1, caml_array.caml_array_get(a, 0));
    trickleup(bubble(i$1, 0), e);
  }
  if (l > 1) {
    var e$1 = caml_array.caml_array_get(a, 1);
    caml_array.caml_array_set(a, 1, caml_array.caml_array_get(a, 0));
    return caml_array.caml_array_set(a, 0, e$1);
  } else {
    return 0;
  }
}

function stable_sort(cmp, a) {
  var merge = function (src1ofs, src1len, src2, src2ofs, src2len, dst, dstofs) {
    var src1r = src1ofs + src1len | 0;
    var src2r = src2ofs + src2len | 0;
    var _i1 = src1ofs;
    var _s1 = caml_array.caml_array_get(a, src1ofs);
    var _i2 = src2ofs;
    var _s2 = caml_array.caml_array_get(src2, src2ofs);
    var _d = dstofs;
    while(true) {
      var d = _d;
      var s2 = _s2;
      var i2 = _i2;
      var s1 = _s1;
      var i1 = _i1;
      if (curry._2(cmp, s1, s2) <= 0) {
        caml_array.caml_array_set(dst, d, s1);
        var i1$1 = i1 + 1 | 0;
        if (i1$1 < src1r) {
          _d = d + 1 | 0;
          _s1 = caml_array.caml_array_get(a, i1$1);
          _i1 = i1$1;
          continue ;
        } else {
          return blit(src2, i2, dst, d + 1 | 0, src2r - i2 | 0);
        }
      } else {
        caml_array.caml_array_set(dst, d, s2);
        var i2$1 = i2 + 1 | 0;
        if (i2$1 < src2r) {
          _d = d + 1 | 0;
          _s2 = caml_array.caml_array_get(src2, i2$1);
          _i2 = i2$1;
          continue ;
        } else {
          return blit(a, i1, dst, d + 1 | 0, src1r - i1 | 0);
        }
      }
    }  };
  var isortto = function (srcofs, dst, dstofs, len) {
    for(var i = 0 ,i_finish = len - 1 | 0; i <= i_finish; ++i){
      var e = caml_array.caml_array_get(a, srcofs + i | 0);
      var j = (dstofs + i | 0) - 1 | 0;
      while(j >= dstofs && curry._2(cmp, caml_array.caml_array_get(dst, j), e) > 0) {
        caml_array.caml_array_set(dst, j + 1 | 0, caml_array.caml_array_get(dst, j));
        j = j - 1 | 0;
      }      caml_array.caml_array_set(dst, j + 1 | 0, e);
    }
    return /* () */0;
  };
  var sortto = function (srcofs, dst, dstofs, len) {
    if (len <= 5) {
      return isortto(srcofs, dst, dstofs, len);
    } else {
      var l1 = len / 2 | 0;
      var l2 = len - l1 | 0;
      sortto(srcofs + l1 | 0, dst, dstofs + l1 | 0, l2);
      sortto(srcofs, a, srcofs + l2 | 0, l1);
      return merge(srcofs + l2 | 0, l1, dst, dstofs + l1 | 0, l2, dst, dstofs);
    }
  };
  var l = a.length;
  if (l <= 5) {
    return isortto(0, a, 0, l);
  } else {
    var l1 = l / 2 | 0;
    var l2 = l - l1 | 0;
    var t = caml_array.caml_make_vect(l2, caml_array.caml_array_get(a, 0));
    sortto(l1, t, 0, l2);
    sortto(0, a, l2, l1);
    return merge(l2, l1, t, 0, l2, a, 0);
  }
}

var create_matrix = make_matrix;

var concat = caml_array.caml_array_concat;

var fast_sort = stable_sort;

var make_float_1 = make_float;
var init_1 = init;
var make_matrix_1 = make_matrix;
var create_matrix_1 = create_matrix;
var append_1 = append;
var concat_1 = concat;
var sub_1 = sub;
var copy_1 = copy;
var fill_1 = fill$1;
var blit_1 = blit;
var to_list_1 = to_list;
var of_list_1 = of_list;
var iter_1 = iter;
var iteri_1 = iteri;
var map_1 = map;
var mapi_1 = mapi;
var fold_left_1 = fold_left;
var fold_right_1 = fold_right;
var iter2_1 = iter2;
var map2_1 = map2;
var for_all_1 = for_all;
var exists_1 = exists;
var mem_1 = mem;
var memq_1 = memq;
var sort_1 = sort;
var stable_sort_1 = stable_sort;
var fast_sort_1 = fast_sort;
var Floatarray_1 = Floatarray;
/* No side effect */

var array = {
	make_float: make_float_1,
	init: init_1,
	make_matrix: make_matrix_1,
	create_matrix: create_matrix_1,
	append: append_1,
	concat: concat_1,
	sub: sub_1,
	copy: copy_1,
	fill: fill_1,
	blit: blit_1,
	to_list: to_list_1,
	of_list: of_list_1,
	iter: iter_1,
	iteri: iteri_1,
	map: map_1,
	mapi: mapi_1,
	fold_left: fold_left_1,
	fold_right: fold_right_1,
	iter2: iter2_1,
	map2: map2_1,
	for_all: for_all_1,
	exists: exists_1,
	mem: mem_1,
	memq: memq_1,
	sort: sort_1,
	stable_sort: stable_sort_1,
	fast_sort: fast_sort_1,
	Floatarray: Floatarray_1
};

function get(s, i) {
  if (i < 0 || i >= s.length) {
    throw [
          caml_builtin_exceptions.invalid_argument,
          "index out of bounds"
        ];
  }
  return s[i];
}

function caml_fill_bytes(s, i, l, c) {
  if (l > 0) {
    for(var k = i ,k_finish = (l + i | 0) - 1 | 0; k <= k_finish; ++k){
      s[k] = c;
    }
    return /* () */0;
  } else {
    return 0;
  }
}

function caml_create_bytes(len) {
  if (len < 0) {
    throw [
          caml_builtin_exceptions.invalid_argument,
          "String.create"
        ];
  }
  var result = new Array(len);
  for(var i = 0 ,i_finish = len - 1 | 0; i <= i_finish; ++i){
    result[i] = /* "\000" */0;
  }
  return result;
}

function caml_blit_bytes(s1, i1, s2, i2, len) {
  if (len > 0) {
    if (s1 === s2) {
      var s1$1 = s1;
      var i1$1 = i1;
      var i2$1 = i2;
      var len$1 = len;
      if (i1$1 < i2$1) {
        var range_a = (s1$1.length - i2$1 | 0) - 1 | 0;
        var range_b = len$1 - 1 | 0;
        var range = range_a > range_b ? range_b : range_a;
        for(var j = range; j >= 0; --j){
          s1$1[i2$1 + j | 0] = s1$1[i1$1 + j | 0];
        }
        return /* () */0;
      } else if (i1$1 > i2$1) {
        var range_a$1 = (s1$1.length - i1$1 | 0) - 1 | 0;
        var range_b$1 = len$1 - 1 | 0;
        var range$1 = range_a$1 > range_b$1 ? range_b$1 : range_a$1;
        for(var k = 0; k <= range$1; ++k){
          s1$1[i2$1 + k | 0] = s1$1[i1$1 + k | 0];
        }
        return /* () */0;
      } else {
        return 0;
      }
    } else {
      var off1 = s1.length - i1 | 0;
      if (len <= off1) {
        for(var i = 0 ,i_finish = len - 1 | 0; i <= i_finish; ++i){
          s2[i2 + i | 0] = s1[i1 + i | 0];
        }
        return /* () */0;
      } else {
        for(var i$1 = 0 ,i_finish$1 = off1 - 1 | 0; i$1 <= i_finish$1; ++i$1){
          s2[i2 + i$1 | 0] = s1[i1 + i$1 | 0];
        }
        for(var i$2 = off1 ,i_finish$2 = len - 1 | 0; i$2 <= i_finish$2; ++i$2){
          s2[i2 + i$2 | 0] = /* "\000" */0;
        }
        return /* () */0;
      }
    }
  } else {
    return 0;
  }
}

function bytes_to_string(a) {
  var bytes = a;
  var len = a.length;
  var s = "";
  var s_len = len;
  if ( len <= 4096 && len === bytes.length) {
    return String.fromCharCode.apply(null, bytes);
  } else {
    var offset = 0;
    while(s_len > 0) {
      var next = s_len < 1024 ? s_len : 1024;
      var tmp_bytes = new Array(next);
      caml_blit_bytes(bytes, offset, tmp_bytes, 0, next);
      s = s + String.fromCharCode.apply(null, tmp_bytes);
      s_len = s_len - next | 0;
      offset = offset + next | 0;
    }    return s;
  }
}

function caml_blit_string(s1, i1, s2, i2, len) {
  if (len > 0) {
    var off1 = s1.length - i1 | 0;
    if (len <= off1) {
      for(var i = 0 ,i_finish = len - 1 | 0; i <= i_finish; ++i){
        s2[i2 + i | 0] = s1.charCodeAt(i1 + i | 0);
      }
      return /* () */0;
    } else {
      for(var i$1 = 0 ,i_finish$1 = off1 - 1 | 0; i$1 <= i_finish$1; ++i$1){
        s2[i2 + i$1 | 0] = s1.charCodeAt(i1 + i$1 | 0);
      }
      for(var i$2 = off1 ,i_finish$2 = len - 1 | 0; i$2 <= i_finish$2; ++i$2){
        s2[i2 + i$2 | 0] = /* "\000" */0;
      }
      return /* () */0;
    }
  } else {
    return 0;
  }
}

function bytes_of_string(s) {
  var len = s.length;
  var res = new Array(len);
  for(var i = 0 ,i_finish = len - 1 | 0; i <= i_finish; ++i){
    res[i] = s.charCodeAt(i);
  }
  return res;
}

var caml_create_bytes_1 = caml_create_bytes;
var caml_fill_bytes_1 = caml_fill_bytes;
var get_1 = get;
var bytes_to_string_1 = bytes_to_string;
var caml_blit_bytes_1 = caml_blit_bytes;
var caml_blit_string_1 = caml_blit_string;
var bytes_of_string_1 = bytes_of_string;
/* No side effect */

var caml_bytes = {
	caml_create_bytes: caml_create_bytes_1,
	caml_fill_bytes: caml_fill_bytes_1,
	get: get_1,
	bytes_to_string: bytes_to_string_1,
	caml_blit_bytes: caml_blit_bytes_1,
	caml_blit_string: caml_blit_string_1,
	bytes_of_string: bytes_of_string_1
};

function chr(n) {
  if (n < 0 || n > 255) {
    throw [
          caml_builtin_exceptions.invalid_argument,
          "Char.chr"
        ];
  }
  return n;
}

function escaped(c) {
  var exit = 0;
  if (c >= 40) {
    if (c !== 92) {
      exit = c >= 127 ? 1 : 2;
    } else {
      return "\\\\";
    }
  } else if (c >= 32) {
    if (c >= 39) {
      return "\\'";
    } else {
      exit = 2;
    }
  } else if (c >= 14) {
    exit = 1;
  } else {
    switch (c) {
      case 8 :
          return "\\b";
      case 9 :
          return "\\t";
      case 10 :
          return "\\n";
      case 0 :
      case 1 :
      case 2 :
      case 3 :
      case 4 :
      case 5 :
      case 6 :
      case 7 :
      case 11 :
      case 12 :
          exit = 1;
          break;
      case 13 :
          return "\\r";
      
    }
  }
  switch (exit) {
    case 1 :
        var s = [
          0,
          0,
          0,
          0
        ];
        s[0] = /* "\\" */92;
        s[1] = 48 + (c / 100 | 0) | 0;
        s[2] = 48 + (c / 10 | 0) % 10 | 0;
        s[3] = 48 + c % 10 | 0;
        return caml_bytes.bytes_to_string(s);
    case 2 :
        var s$1 = [0];
        s$1[0] = c;
        return caml_bytes.bytes_to_string(s$1);
    
  }
}

function lowercase(c) {
  if (c >= /* "A" */65 && c <= /* "Z" */90 || c >= /* "\192" */192 && c <= /* "\214" */214 || c >= /* "\216" */216 && c <= /* "\222" */222) {
    return c + 32 | 0;
  } else {
    return c;
  }
}

function uppercase(c) {
  if (c >= /* "a" */97 && c <= /* "z" */122 || c >= /* "\224" */224 && c <= /* "\246" */246 || c >= /* "\248" */248 && c <= /* "\254" */254) {
    return c - 32 | 0;
  } else {
    return c;
  }
}

function lowercase_ascii(c) {
  if (c >= /* "A" */65 && c <= /* "Z" */90) {
    return c + 32 | 0;
  } else {
    return c;
  }
}

function uppercase_ascii(c) {
  if (c >= /* "a" */97 && c <= /* "z" */122) {
    return c - 32 | 0;
  } else {
    return c;
  }
}

function compare(c1, c2) {
  return c1 - c2 | 0;
}

function equal(c1, c2) {
  return (c1 - c2 | 0) === 0;
}

var chr_1 = chr;
var escaped_1 = escaped;
var lowercase_1 = lowercase;
var uppercase_1 = uppercase;
var lowercase_ascii_1 = lowercase_ascii;
var uppercase_ascii_1 = uppercase_ascii;
var compare_1 = compare;
var equal_1 = equal;
/* No side effect */

var char_1 = {
	chr: chr_1,
	escaped: escaped_1,
	lowercase: lowercase_1,
	uppercase: uppercase_1,
	lowercase_ascii: lowercase_ascii_1,
	uppercase_ascii: uppercase_ascii_1,
	compare: compare_1,
	equal: equal_1
};

function make(n, c) {
  var s = caml_bytes.caml_create_bytes(n);
  caml_bytes.caml_fill_bytes(s, 0, n, c);
  return s;
}

function init$1(n, f) {
  var s = caml_bytes.caml_create_bytes(n);
  for(var i = 0 ,i_finish = n - 1 | 0; i <= i_finish; ++i){
    s[i] = curry._1(f, i);
  }
  return s;
}

var empty = [];

function copy$1(s) {
  var len = s.length;
  var r = caml_bytes.caml_create_bytes(len);
  caml_bytes.caml_blit_bytes(s, 0, r, 0, len);
  return r;
}

function to_string(b) {
  return caml_bytes.bytes_to_string(copy$1(b));
}

function of_string(s) {
  return copy$1(caml_bytes.bytes_of_string(s));
}

function sub$1(s, ofs, len) {
  if (ofs < 0 || len < 0 || ofs > (s.length - len | 0)) {
    throw [
          caml_builtin_exceptions.invalid_argument,
          "String.sub / Bytes.sub"
        ];
  }
  var r = caml_bytes.caml_create_bytes(len);
  caml_bytes.caml_blit_bytes(s, ofs, r, 0, len);
  return r;
}

function sub_string(b, ofs, len) {
  return caml_bytes.bytes_to_string(sub$1(b, ofs, len));
}

function $plus$plus(a, b) {
  var c = a + b | 0;
  var match = a < 0;
  var match$1 = b < 0;
  var match$2 = c < 0;
  if (match) {
    if (match$1 && !match$2) {
      throw [
            caml_builtin_exceptions.invalid_argument,
            "Bytes.extend"
          ];
    } else {
      return c;
    }
  } else if (match$1) {
    return c;
  } else {
    if (match$2) {
      throw [
            caml_builtin_exceptions.invalid_argument,
            "Bytes.extend"
          ];
    }
    return c;
  }
}

function extend(s, left, right) {
  var len = $plus$plus($plus$plus(s.length, left), right);
  var r = caml_bytes.caml_create_bytes(len);
  var match = left < 0 ? /* tuple */[
      -left | 0,
      0
    ] : /* tuple */[
      0,
      left
    ];
  var dstoff = match[1];
  var srcoff = match[0];
  var cpylen = caml_primitive.caml_int_min(s.length - srcoff | 0, len - dstoff | 0);
  if (cpylen > 0) {
    caml_bytes.caml_blit_bytes(s, srcoff, r, dstoff, cpylen);
  }
  return r;
}

function fill$2(s, ofs, len, c) {
  if (ofs < 0 || len < 0 || ofs > (s.length - len | 0)) {
    throw [
          caml_builtin_exceptions.invalid_argument,
          "String.fill / Bytes.fill"
        ];
  }
  return caml_bytes.caml_fill_bytes(s, ofs, len, c);
}

function blit$1(s1, ofs1, s2, ofs2, len) {
  if (len < 0 || ofs1 < 0 || ofs1 > (s1.length - len | 0) || ofs2 < 0 || ofs2 > (s2.length - len | 0)) {
    throw [
          caml_builtin_exceptions.invalid_argument,
          "Bytes.blit"
        ];
  }
  return caml_bytes.caml_blit_bytes(s1, ofs1, s2, ofs2, len);
}

function blit_string(s1, ofs1, s2, ofs2, len) {
  if (len < 0 || ofs1 < 0 || ofs1 > (s1.length - len | 0) || ofs2 < 0 || ofs2 > (s2.length - len | 0)) {
    throw [
          caml_builtin_exceptions.invalid_argument,
          "String.blit / Bytes.blit_string"
        ];
  }
  return caml_bytes.caml_blit_string(s1, ofs1, s2, ofs2, len);
}

function iter$1(f, a) {
  for(var i = 0 ,i_finish = a.length - 1 | 0; i <= i_finish; ++i){
    curry._1(f, a[i]);
  }
  return /* () */0;
}

function iteri$1(f, a) {
  for(var i = 0 ,i_finish = a.length - 1 | 0; i <= i_finish; ++i){
    curry._2(f, i, a[i]);
  }
  return /* () */0;
}

function ensure_ge(x, y) {
  if (x >= y) {
    return x;
  } else {
    throw [
          caml_builtin_exceptions.invalid_argument,
          "Bytes.concat"
        ];
  }
}

function sum_lengths(_acc, seplen, _param) {
  while(true) {
    var param = _param;
    var acc = _acc;
    if (param) {
      var tl = param[1];
      var hd = param[0];
      if (tl) {
        _param = tl;
        _acc = ensure_ge((hd.length + seplen | 0) + acc | 0, acc);
        continue ;
      } else {
        return hd.length + acc | 0;
      }
    } else {
      return acc;
    }
  }}

function concat$1(sep, l) {
  if (l) {
    var seplen = sep.length;
    var dst = caml_bytes.caml_create_bytes(sum_lengths(0, seplen, l));
    var _pos = 0;
    var sep$1 = sep;
    var seplen$1 = seplen;
    var _param = l;
    while(true) {
      var param = _param;
      var pos = _pos;
      if (param) {
        var tl = param[1];
        var hd = param[0];
        if (tl) {
          caml_bytes.caml_blit_bytes(hd, 0, dst, pos, hd.length);
          caml_bytes.caml_blit_bytes(sep$1, 0, dst, pos + hd.length | 0, seplen$1);
          _param = tl;
          _pos = (pos + hd.length | 0) + seplen$1 | 0;
          continue ;
        } else {
          caml_bytes.caml_blit_bytes(hd, 0, dst, pos, hd.length);
          return dst;
        }
      } else {
        return dst;
      }
    }  } else {
    return empty;
  }
}

function cat(s1, s2) {
  var l1 = s1.length;
  var l2 = s2.length;
  var r = caml_bytes.caml_create_bytes(l1 + l2 | 0);
  caml_bytes.caml_blit_bytes(s1, 0, r, 0, l1);
  caml_bytes.caml_blit_bytes(s2, 0, r, l1, l2);
  return r;
}

function is_space(param) {
  var switcher = param - 9 | 0;
  if (switcher > 4 || switcher < 0) {
    return switcher === 23;
  } else {
    return switcher !== 2;
  }
}

function trim(s) {
  var len = s.length;
  var i = 0;
  while(i < len && is_space(s[i])) {
    i = i + 1 | 0;
  }  var j = len - 1 | 0;
  while(j >= i && is_space(s[j])) {
    j = j - 1 | 0;
  }  if (j >= i) {
    return sub$1(s, i, (j - i | 0) + 1 | 0);
  } else {
    return empty;
  }
}

function escaped$1(s) {
  var n = 0;
  for(var i = 0 ,i_finish = s.length - 1 | 0; i <= i_finish; ++i){
    var match = s[i];
    var tmp;
    if (match >= 32) {
      var switcher = match - 34 | 0;
      tmp = switcher > 58 || switcher < 0 ? (
          switcher >= 93 ? 4 : 1
        ) : (
          switcher > 57 || switcher < 1 ? 2 : 1
        );
    } else {
      tmp = match >= 11 ? (
          match !== 13 ? 4 : 2
        ) : (
          match >= 8 ? 2 : 4
        );
    }
    n = n + tmp | 0;
  }
  if (n === s.length) {
    return copy$1(s);
  } else {
    var s$prime = caml_bytes.caml_create_bytes(n);
    n = 0;
    for(var i$1 = 0 ,i_finish$1 = s.length - 1 | 0; i$1 <= i_finish$1; ++i$1){
      var c = s[i$1];
      var exit = 0;
      if (c >= 35) {
        if (c !== 92) {
          if (c >= 127) {
            exit = 1;
          } else {
            s$prime[n] = c;
          }
        } else {
          exit = 2;
        }
      } else if (c >= 32) {
        if (c >= 34) {
          exit = 2;
        } else {
          s$prime[n] = c;
        }
      } else if (c >= 14) {
        exit = 1;
      } else {
        switch (c) {
          case 8 :
              s$prime[n] = /* "\\" */92;
              n = n + 1 | 0;
              s$prime[n] = /* "b" */98;
              break;
          case 9 :
              s$prime[n] = /* "\\" */92;
              n = n + 1 | 0;
              s$prime[n] = /* "t" */116;
              break;
          case 10 :
              s$prime[n] = /* "\\" */92;
              n = n + 1 | 0;
              s$prime[n] = /* "n" */110;
              break;
          case 0 :
          case 1 :
          case 2 :
          case 3 :
          case 4 :
          case 5 :
          case 6 :
          case 7 :
          case 11 :
          case 12 :
              exit = 1;
              break;
          case 13 :
              s$prime[n] = /* "\\" */92;
              n = n + 1 | 0;
              s$prime[n] = /* "r" */114;
              break;
          
        }
      }
      switch (exit) {
        case 1 :
            s$prime[n] = /* "\\" */92;
            n = n + 1 | 0;
            s$prime[n] = 48 + (c / 100 | 0) | 0;
            n = n + 1 | 0;
            s$prime[n] = 48 + (c / 10 | 0) % 10 | 0;
            n = n + 1 | 0;
            s$prime[n] = 48 + c % 10 | 0;
            break;
        case 2 :
            s$prime[n] = /* "\\" */92;
            n = n + 1 | 0;
            s$prime[n] = c;
            break;
        
      }
      n = n + 1 | 0;
    }
    return s$prime;
  }
}

function map$1(f, s) {
  var l = s.length;
  if (l === 0) {
    return s;
  } else {
    var r = caml_bytes.caml_create_bytes(l);
    for(var i = 0 ,i_finish = l - 1 | 0; i <= i_finish; ++i){
      r[i] = curry._1(f, s[i]);
    }
    return r;
  }
}

function mapi$1(f, s) {
  var l = s.length;
  if (l === 0) {
    return s;
  } else {
    var r = caml_bytes.caml_create_bytes(l);
    for(var i = 0 ,i_finish = l - 1 | 0; i <= i_finish; ++i){
      r[i] = curry._2(f, i, s[i]);
    }
    return r;
  }
}

function uppercase_ascii$1(s) {
  return map$1(char_1.uppercase_ascii, s);
}

function lowercase_ascii$1(s) {
  return map$1(char_1.lowercase_ascii, s);
}

function apply1(f, s) {
  if (s.length === 0) {
    return s;
  } else {
    var r = copy$1(s);
    r[0] = curry._1(f, s[0]);
    return r;
  }
}

function capitalize_ascii(s) {
  return apply1(char_1.uppercase_ascii, s);
}

function uncapitalize_ascii(s) {
  return apply1(char_1.lowercase_ascii, s);
}

function index_rec(s, lim, _i, c) {
  while(true) {
    var i = _i;
    if (i >= lim) {
      throw caml_builtin_exceptions.not_found;
    }
    if (s[i] === c) {
      return i;
    } else {
      _i = i + 1 | 0;
      continue ;
    }
  }}

function index(s, c) {
  return index_rec(s, s.length, 0, c);
}

function index_rec_opt(s, lim, _i, c) {
  while(true) {
    var i = _i;
    if (i >= lim) {
      return ;
    } else if (s[i] === c) {
      return i;
    } else {
      _i = i + 1 | 0;
      continue ;
    }
  }}

function index_opt(s, c) {
  return index_rec_opt(s, s.length, 0, c);
}

function index_from(s, i, c) {
  var l = s.length;
  if (i < 0 || i > l) {
    throw [
          caml_builtin_exceptions.invalid_argument,
          "String.index_from / Bytes.index_from"
        ];
  }
  return index_rec(s, l, i, c);
}

function index_from_opt(s, i, c) {
  var l = s.length;
  if (i < 0 || i > l) {
    throw [
          caml_builtin_exceptions.invalid_argument,
          "String.index_from_opt / Bytes.index_from_opt"
        ];
  }
  return index_rec_opt(s, l, i, c);
}

function rindex_rec(s, _i, c) {
  while(true) {
    var i = _i;
    if (i < 0) {
      throw caml_builtin_exceptions.not_found;
    }
    if (s[i] === c) {
      return i;
    } else {
      _i = i - 1 | 0;
      continue ;
    }
  }}

function rindex(s, c) {
  return rindex_rec(s, s.length - 1 | 0, c);
}

function rindex_from(s, i, c) {
  if (i < -1 || i >= s.length) {
    throw [
          caml_builtin_exceptions.invalid_argument,
          "String.rindex_from / Bytes.rindex_from"
        ];
  }
  return rindex_rec(s, i, c);
}

function rindex_rec_opt(s, _i, c) {
  while(true) {
    var i = _i;
    if (i < 0) {
      return ;
    } else if (s[i] === c) {
      return i;
    } else {
      _i = i - 1 | 0;
      continue ;
    }
  }}

function rindex_opt(s, c) {
  return rindex_rec_opt(s, s.length - 1 | 0, c);
}

function rindex_from_opt(s, i, c) {
  if (i < -1 || i >= s.length) {
    throw [
          caml_builtin_exceptions.invalid_argument,
          "String.rindex_from_opt / Bytes.rindex_from_opt"
        ];
  }
  return rindex_rec_opt(s, i, c);
}

function contains_from(s, i, c) {
  var l = s.length;
  if (i < 0 || i > l) {
    throw [
          caml_builtin_exceptions.invalid_argument,
          "String.contains_from / Bytes.contains_from"
        ];
  }
  try {
    index_rec(s, l, i, c);
    return true;
  }
  catch (exn){
    if (exn === caml_builtin_exceptions.not_found) {
      return false;
    } else {
      throw exn;
    }
  }
}

function contains(s, c) {
  return contains_from(s, 0, c);
}

function rcontains_from(s, i, c) {
  if (i < 0 || i >= s.length) {
    throw [
          caml_builtin_exceptions.invalid_argument,
          "String.rcontains_from / Bytes.rcontains_from"
        ];
  }
  try {
    rindex_rec(s, i, c);
    return true;
  }
  catch (exn){
    if (exn === caml_builtin_exceptions.not_found) {
      return false;
    } else {
      throw exn;
    }
  }
}

var compare$1 = caml_primitive.caml_bytes_compare;

function uppercase$1(s) {
  return map$1(char_1.uppercase, s);
}

function lowercase$1(s) {
  return map$1(char_1.lowercase, s);
}

function capitalize(s) {
  return apply1(char_1.uppercase, s);
}

function uncapitalize(s) {
  return apply1(char_1.lowercase, s);
}

var equal$1 = caml_primitive.caml_bytes_equal;

var unsafe_to_string = caml_bytes.bytes_to_string;

var unsafe_of_string = caml_bytes.bytes_of_string;

var make_1 = make;
var init_1$1 = init$1;
var empty_1 = empty;
var copy_1$1 = copy$1;
var of_string_1 = of_string;
var to_string_1 = to_string;
var sub_1$1 = sub$1;
var sub_string_1 = sub_string;
var extend_1 = extend;
var fill_1$1 = fill$2;
var blit_1$1 = blit$1;
var blit_string_1 = blit_string;
var concat_1$1 = concat$1;
var cat_1 = cat;
var iter_1$1 = iter$1;
var iteri_1$1 = iteri$1;
var map_1$1 = map$1;
var mapi_1$1 = mapi$1;
var trim_1 = trim;
var escaped_1$1 = escaped$1;
var index_1 = index;
var index_opt_1 = index_opt;
var rindex_1 = rindex;
var rindex_opt_1 = rindex_opt;
var index_from_1 = index_from;
var index_from_opt_1 = index_from_opt;
var rindex_from_1 = rindex_from;
var rindex_from_opt_1 = rindex_from_opt;
var contains_1 = contains;
var contains_from_1 = contains_from;
var rcontains_from_1 = rcontains_from;
var uppercase_1$1 = uppercase$1;
var lowercase_1$1 = lowercase$1;
var capitalize_1 = capitalize;
var uncapitalize_1 = uncapitalize;
var uppercase_ascii_1$1 = uppercase_ascii$1;
var lowercase_ascii_1$1 = lowercase_ascii$1;
var capitalize_ascii_1 = capitalize_ascii;
var uncapitalize_ascii_1 = uncapitalize_ascii;
var compare_1$1 = compare$1;
var equal_1$1 = equal$1;
var unsafe_to_string_1 = unsafe_to_string;
var unsafe_of_string_1 = unsafe_of_string;
/* No side effect */

var bytes = {
	make: make_1,
	init: init_1$1,
	empty: empty_1,
	copy: copy_1$1,
	of_string: of_string_1,
	to_string: to_string_1,
	sub: sub_1$1,
	sub_string: sub_string_1,
	extend: extend_1,
	fill: fill_1$1,
	blit: blit_1$1,
	blit_string: blit_string_1,
	concat: concat_1$1,
	cat: cat_1,
	iter: iter_1$1,
	iteri: iteri_1$1,
	map: map_1$1,
	mapi: mapi_1$1,
	trim: trim_1,
	escaped: escaped_1$1,
	index: index_1,
	index_opt: index_opt_1,
	rindex: rindex_1,
	rindex_opt: rindex_opt_1,
	index_from: index_from_1,
	index_from_opt: index_from_opt_1,
	rindex_from: rindex_from_1,
	rindex_from_opt: rindex_from_opt_1,
	contains: contains_1,
	contains_from: contains_from_1,
	rcontains_from: rcontains_from_1,
	uppercase: uppercase_1$1,
	lowercase: lowercase_1$1,
	capitalize: capitalize_1,
	uncapitalize: uncapitalize_1,
	uppercase_ascii: uppercase_ascii_1$1,
	lowercase_ascii: lowercase_ascii_1$1,
	capitalize_ascii: capitalize_ascii_1,
	uncapitalize_ascii: uncapitalize_ascii_1,
	compare: compare_1$1,
	equal: equal_1$1,
	unsafe_to_string: unsafe_to_string_1,
	unsafe_of_string: unsafe_of_string_1
};

function make$1(n, c) {
  return caml_bytes.bytes_to_string(bytes.make(n, c));
}

function init$2(n, f) {
  return caml_bytes.bytes_to_string(bytes.init(n, f));
}

function copy$2(s) {
  return caml_bytes.bytes_to_string(bytes.copy(caml_bytes.bytes_of_string(s)));
}

function sub$2(s, ofs, len) {
  return caml_bytes.bytes_to_string(bytes.sub(caml_bytes.bytes_of_string(s), ofs, len));
}

function ensure_ge$1(x, y) {
  if (x >= y) {
    return x;
  } else {
    throw [
          caml_builtin_exceptions.invalid_argument,
          "String.concat"
        ];
  }
}

function sum_lengths$1(_acc, seplen, _param) {
  while(true) {
    var param = _param;
    var acc = _acc;
    if (param) {
      var tl = param[1];
      var hd = param[0];
      if (tl) {
        _param = tl;
        _acc = ensure_ge$1((hd.length + seplen | 0) + acc | 0, acc);
        continue ;
      } else {
        return hd.length + acc | 0;
      }
    } else {
      return acc;
    }
  }}

function unsafe_blits(dst, _pos, sep, seplen, _param) {
  while(true) {
    var param = _param;
    var pos = _pos;
    if (param) {
      var tl = param[1];
      var hd = param[0];
      if (tl) {
        caml_bytes.caml_blit_string(hd, 0, dst, pos, hd.length);
        caml_bytes.caml_blit_string(sep, 0, dst, pos + hd.length | 0, seplen);
        _param = tl;
        _pos = (pos + hd.length | 0) + seplen | 0;
        continue ;
      } else {
        caml_bytes.caml_blit_string(hd, 0, dst, pos, hd.length);
        return dst;
      }
    } else {
      return dst;
    }
  }}

function concat$2(sep, l) {
  if (l) {
    var seplen = sep.length;
    return caml_bytes.bytes_to_string(unsafe_blits(caml_bytes.caml_create_bytes(sum_lengths$1(0, seplen, l)), 0, sep, seplen, l));
  } else {
    return "";
  }
}

function iter$2(f, s) {
  for(var i = 0 ,i_finish = s.length - 1 | 0; i <= i_finish; ++i){
    curry._1(f, s.charCodeAt(i));
  }
  return /* () */0;
}

function iteri$2(f, s) {
  for(var i = 0 ,i_finish = s.length - 1 | 0; i <= i_finish; ++i){
    curry._2(f, i, s.charCodeAt(i));
  }
  return /* () */0;
}

function map$2(f, s) {
  return caml_bytes.bytes_to_string(bytes.map(f, caml_bytes.bytes_of_string(s)));
}

function mapi$2(f, s) {
  return caml_bytes.bytes_to_string(bytes.mapi(f, caml_bytes.bytes_of_string(s)));
}

function is_space$1(param) {
  var switcher = param - 9 | 0;
  if (switcher > 4 || switcher < 0) {
    return switcher === 23;
  } else {
    return switcher !== 2;
  }
}

function trim$1(s) {
  if (s === "" || !(is_space$1(s.charCodeAt(0)) || is_space$1(s.charCodeAt(s.length - 1 | 0)))) {
    return s;
  } else {
    return caml_bytes.bytes_to_string(bytes.trim(caml_bytes.bytes_of_string(s)));
  }
}

function escaped$2(s) {
  var needs_escape = function (_i) {
    while(true) {
      var i = _i;
      if (i >= s.length) {
        return false;
      } else {
        var match = s.charCodeAt(i);
        if (match >= 32) {
          var switcher = match - 34 | 0;
          if (switcher > 58 || switcher < 0) {
            if (switcher >= 93) {
              return true;
            } else {
              _i = i + 1 | 0;
              continue ;
            }
          } else if (switcher > 57 || switcher < 1) {
            return true;
          } else {
            _i = i + 1 | 0;
            continue ;
          }
        } else {
          return true;
        }
      }
    }  };
  if (needs_escape(0)) {
    return caml_bytes.bytes_to_string(bytes.escaped(caml_bytes.bytes_of_string(s)));
  } else {
    return s;
  }
}

function index_rec$1(s, lim, _i, c) {
  while(true) {
    var i = _i;
    if (i >= lim) {
      throw caml_builtin_exceptions.not_found;
    }
    if (s.charCodeAt(i) === c) {
      return i;
    } else {
      _i = i + 1 | 0;
      continue ;
    }
  }}

function index$1(s, c) {
  return index_rec$1(s, s.length, 0, c);
}

function index_rec_opt$1(s, lim, _i, c) {
  while(true) {
    var i = _i;
    if (i >= lim) {
      return ;
    } else if (s.charCodeAt(i) === c) {
      return i;
    } else {
      _i = i + 1 | 0;
      continue ;
    }
  }}

function index_opt$1(s, c) {
  return index_rec_opt$1(s, s.length, 0, c);
}

function index_from$1(s, i, c) {
  var l = s.length;
  if (i < 0 || i > l) {
    throw [
          caml_builtin_exceptions.invalid_argument,
          "String.index_from / Bytes.index_from"
        ];
  }
  return index_rec$1(s, l, i, c);
}

function index_from_opt$1(s, i, c) {
  var l = s.length;
  if (i < 0 || i > l) {
    throw [
          caml_builtin_exceptions.invalid_argument,
          "String.index_from_opt / Bytes.index_from_opt"
        ];
  }
  return index_rec_opt$1(s, l, i, c);
}

function rindex_rec$1(s, _i, c) {
  while(true) {
    var i = _i;
    if (i < 0) {
      throw caml_builtin_exceptions.not_found;
    }
    if (s.charCodeAt(i) === c) {
      return i;
    } else {
      _i = i - 1 | 0;
      continue ;
    }
  }}

function rindex$1(s, c) {
  return rindex_rec$1(s, s.length - 1 | 0, c);
}

function rindex_from$1(s, i, c) {
  if (i < -1 || i >= s.length) {
    throw [
          caml_builtin_exceptions.invalid_argument,
          "String.rindex_from / Bytes.rindex_from"
        ];
  }
  return rindex_rec$1(s, i, c);
}

function rindex_rec_opt$1(s, _i, c) {
  while(true) {
    var i = _i;
    if (i < 0) {
      return ;
    } else if (s.charCodeAt(i) === c) {
      return i;
    } else {
      _i = i - 1 | 0;
      continue ;
    }
  }}

function rindex_opt$1(s, c) {
  return rindex_rec_opt$1(s, s.length - 1 | 0, c);
}

function rindex_from_opt$1(s, i, c) {
  if (i < -1 || i >= s.length) {
    throw [
          caml_builtin_exceptions.invalid_argument,
          "String.rindex_from_opt / Bytes.rindex_from_opt"
        ];
  }
  return rindex_rec_opt$1(s, i, c);
}

function contains_from$1(s, i, c) {
  var l = s.length;
  if (i < 0 || i > l) {
    throw [
          caml_builtin_exceptions.invalid_argument,
          "String.contains_from / Bytes.contains_from"
        ];
  }
  try {
    index_rec$1(s, l, i, c);
    return true;
  }
  catch (exn){
    if (exn === caml_builtin_exceptions.not_found) {
      return false;
    } else {
      throw exn;
    }
  }
}

function contains$1(s, c) {
  return contains_from$1(s, 0, c);
}

function rcontains_from$1(s, i, c) {
  if (i < 0 || i >= s.length) {
    throw [
          caml_builtin_exceptions.invalid_argument,
          "String.rcontains_from / Bytes.rcontains_from"
        ];
  }
  try {
    rindex_rec$1(s, i, c);
    return true;
  }
  catch (exn){
    if (exn === caml_builtin_exceptions.not_found) {
      return false;
    } else {
      throw exn;
    }
  }
}

function uppercase_ascii$2(s) {
  return caml_bytes.bytes_to_string(bytes.uppercase_ascii(caml_bytes.bytes_of_string(s)));
}

function lowercase_ascii$2(s) {
  return caml_bytes.bytes_to_string(bytes.lowercase_ascii(caml_bytes.bytes_of_string(s)));
}

function capitalize_ascii$1(s) {
  return caml_bytes.bytes_to_string(bytes.capitalize_ascii(caml_bytes.bytes_of_string(s)));
}

function uncapitalize_ascii$1(s) {
  return caml_bytes.bytes_to_string(bytes.uncapitalize_ascii(caml_bytes.bytes_of_string(s)));
}

var compare$2 = caml_primitive.caml_string_compare;

function split_on_char(sep, s) {
  var r = /* [] */0;
  var j = s.length;
  for(var i = s.length - 1 | 0; i >= 0; --i){
    if (s.charCodeAt(i) === sep) {
      r = /* :: */[
        sub$2(s, i + 1 | 0, (j - i | 0) - 1 | 0),
        r
      ];
      j = i;
    }
    
  }
  return /* :: */[
          sub$2(s, 0, j),
          r
        ];
}

function uppercase$2(s) {
  return caml_bytes.bytes_to_string(bytes.uppercase(caml_bytes.bytes_of_string(s)));
}

function lowercase$2(s) {
  return caml_bytes.bytes_to_string(bytes.lowercase(caml_bytes.bytes_of_string(s)));
}

function capitalize$1(s) {
  return caml_bytes.bytes_to_string(bytes.capitalize(caml_bytes.bytes_of_string(s)));
}

function uncapitalize$1(s) {
  return caml_bytes.bytes_to_string(bytes.uncapitalize(caml_bytes.bytes_of_string(s)));
}

var fill$3 = bytes.fill;

var blit$2 = bytes.blit_string;

function equal$2(prim, prim$1) {
  return prim === prim$1;
}

var make_1$1 = make$1;
var init_1$2 = init$2;
var copy_1$2 = copy$2;
var sub_1$2 = sub$2;
var fill_1$2 = fill$3;
var blit_1$2 = blit$2;
var concat_1$2 = concat$2;
var iter_1$2 = iter$2;
var iteri_1$2 = iteri$2;
var map_1$2 = map$2;
var mapi_1$2 = mapi$2;
var trim_1$1 = trim$1;
var escaped_1$2 = escaped$2;
var index_1$1 = index$1;
var index_opt_1$1 = index_opt$1;
var rindex_1$1 = rindex$1;
var rindex_opt_1$1 = rindex_opt$1;
var index_from_1$1 = index_from$1;
var index_from_opt_1$1 = index_from_opt$1;
var rindex_from_1$1 = rindex_from$1;
var rindex_from_opt_1$1 = rindex_from_opt$1;
var contains_1$1 = contains$1;
var contains_from_1$1 = contains_from$1;
var rcontains_from_1$1 = rcontains_from$1;
var uppercase_1$2 = uppercase$2;
var lowercase_1$2 = lowercase$2;
var capitalize_1$1 = capitalize$1;
var uncapitalize_1$1 = uncapitalize$1;
var uppercase_ascii_1$2 = uppercase_ascii$2;
var lowercase_ascii_1$2 = lowercase_ascii$2;
var capitalize_ascii_1$1 = capitalize_ascii$1;
var uncapitalize_ascii_1$1 = uncapitalize_ascii$1;
var compare_1$2 = compare$2;
var equal_1$2 = equal$2;
var split_on_char_1 = split_on_char;
/* No side effect */

var string = {
	make: make_1$1,
	init: init_1$2,
	copy: copy_1$2,
	sub: sub_1$2,
	fill: fill_1$2,
	blit: blit_1$2,
	concat: concat_1$2,
	iter: iter_1$2,
	iteri: iteri_1$2,
	map: map_1$2,
	mapi: mapi_1$2,
	trim: trim_1$1,
	escaped: escaped_1$2,
	index: index_1$1,
	index_opt: index_opt_1$1,
	rindex: rindex_1$1,
	rindex_opt: rindex_opt_1$1,
	index_from: index_from_1$1,
	index_from_opt: index_from_opt_1$1,
	rindex_from: rindex_from_1$1,
	rindex_from_opt: rindex_from_opt_1$1,
	contains: contains_1$1,
	contains_from: contains_from_1$1,
	rcontains_from: rcontains_from_1$1,
	uppercase: uppercase_1$2,
	lowercase: lowercase_1$2,
	capitalize: capitalize_1$1,
	uncapitalize: uncapitalize_1$1,
	uppercase_ascii: uppercase_ascii_1$2,
	lowercase_ascii: lowercase_ascii_1$2,
	capitalize_ascii: capitalize_ascii_1$1,
	uncapitalize_ascii: uncapitalize_ascii_1$1,
	compare: compare_1$2,
	equal: equal_1$2,
	split_on_char: split_on_char_1
};

var stdout = {
  buffer: "",
  output: (function (param, s) {
      var v = s.length - 1 | 0;
      if (( (typeof process !== "undefined") && process.stdout && process.stdout.write)) {
        return ( process.stdout.write )(s);
      } else if (s[v] === "\n") {
        console.log(s.slice(0, v));
        return /* () */0;
      } else {
        console.log(s);
        return /* () */0;
      }
    })
};

var stderr = {
  buffer: "",
  output: (function (param, s) {
      var v = s.length - 1 | 0;
      if (s[v] === "\n") {
        console.log(s.slice(0, v));
        return /* () */0;
      } else {
        console.log(s);
        return /* () */0;
      }
    })
};

function caml_ml_flush(oc) {
  if (oc.buffer !== "") {
    curry._2(oc.output, oc, oc.buffer);
    oc.buffer = "";
    return /* () */0;
  } else {
    return 0;
  }
}

function caml_ml_output(oc, str, offset, len) {
  var str$1 = offset === 0 && len === str.length ? str : str.slice(offset, len);
  if (( (typeof process !== "undefined") && process.stdout && process.stdout.write ) && oc === stdout) {
    return ( process.stdout.write )(str$1);
  } else {
    var id = str$1.lastIndexOf("\n");
    if (id < 0) {
      oc.buffer = oc.buffer + str$1;
      return /* () */0;
    } else {
      oc.buffer = oc.buffer + str$1.slice(0, id + 1 | 0);
      caml_ml_flush(oc);
      oc.buffer = oc.buffer + str$1.slice(id + 1 | 0);
      return /* () */0;
    }
  }
}

function caml_ml_output_char(oc, $$char) {
  return caml_ml_output(oc, String.fromCharCode($$char), 0, 1);
}

function caml_ml_out_channels_list(param) {
  return /* :: */[
          stdout,
          /* :: */[
            stderr,
            /* [] */0
          ]
        ];
}

var stdin = undefined;

var stdin_1 = stdin;
var stdout_1 = stdout;
var stderr_1 = stderr;
var caml_ml_flush_1 = caml_ml_flush;
var caml_ml_output_1 = caml_ml_output;
var caml_ml_output_char_1 = caml_ml_output_char;
var caml_ml_out_channels_list_1 = caml_ml_out_channels_list;
/* No side effect */

var caml_io = {
	stdin: stdin_1,
	stdout: stdout_1,
	stderr: stderr_1,
	caml_ml_flush: caml_ml_flush_1,
	caml_ml_output: caml_ml_output_1,
	caml_ml_output_char: caml_ml_output_char_1,
	caml_ml_out_channels_list: caml_ml_out_channels_list_1
};

function div(x, y) {
  if (y === 0) {
    throw caml_builtin_exceptions.division_by_zero;
  }
  return x / y | 0;
}

function mod_(x, y) {
  if (y === 0) {
    throw caml_builtin_exceptions.division_by_zero;
  }
  return x % y;
}

function caml_bswap16(x) {
  return ((x & 255) << 8) | ((x & 65280) >>> 8);
}

function caml_int32_bswap(x) {
  return ((x & 255) << 24) | ((x & 65280) << 8) | ((x & 16711680) >>> 8) | ((x & 4278190080) >>> 24);
}

var imul = ( Math.imul || function (x,y) {
  y |= 0; return ((((x >> 16) * y) << 16) + (x & 0xffff) * y)|0; 
}
);

var caml_nativeint_bswap = caml_int32_bswap;

var div_1 = div;
var mod__1 = mod_;
var caml_bswap16_1 = caml_bswap16;
var caml_int32_bswap_1 = caml_int32_bswap;
var caml_nativeint_bswap_1 = caml_nativeint_bswap;
var imul_1 = imul;
/* imul Not a pure module */

var caml_int32 = {
	div: div_1,
	mod_: mod__1,
	caml_bswap16: caml_bswap16_1,
	caml_int32_bswap: caml_int32_bswap_1,
	caml_nativeint_bswap: caml_nativeint_bswap_1,
	imul: imul_1
};

function repeat (count,self){
    if (self.repeat){
        return self.repeat(count)
    }
    if (self.length == 0 || count == 0) {
            return '';
        }
    // Ensuring count is a 31-bit integer allows us to heavily optimize the
    // main part. But anyway, most current (August 2014) browsers can't handle
    // strings 1 << 28 chars or longer, so:
    if (self.length * count >= 1 << 28) {
            throw new RangeError('repeat count must not overflow maximum string size');
    }
    var rpt = '';
    for (;;) {
            if ((count & 1) == 1) {
                rpt += self;
            }
            count >>>= 1;
            if (count == 0) {
                break;
            }
            self += self;
    }
    return rpt;

}
var repeat_1 = repeat;
/* No side effect */

var caml_utils = {
	repeat: repeat_1
};

var min_int = {
  hi: -2147483648,
  lo: 0
};

var max_int = {
  hi: 2147483647,
  lo: 1
};

var one = {
  hi: 0,
  lo: 1
};

var zero = {
  hi: 0,
  lo: 0
};

var neg_one = {
  hi: -1,
  lo: 4294967295
};

function neg_signed(x) {
  return (x & 2147483648) !== 0;
}

function add(param, param$1) {
  var other_low_ = param$1.lo;
  var this_low_ = param.lo;
  var lo = this_low_ + other_low_ & 4294967295;
  var overflow = neg_signed(this_low_) && (neg_signed(other_low_) || !neg_signed(lo)) || neg_signed(other_low_) && !neg_signed(lo) ? 1 : 0;
  var hi = param.hi + param$1.hi + overflow & 4294967295;
  return {
          hi: hi,
          lo: (lo >>> 0)
        };
}

function not(param) {
  var hi = param.hi ^ -1;
  var lo = param.lo ^ -1;
  return {
          hi: hi,
          lo: (lo >>> 0)
        };
}

function eq(x, y) {
  if (x.hi === y.hi) {
    return x.lo === y.lo;
  } else {
    return false;
  }
}

function equal_null(x, y) {
  if (y !== null) {
    return eq(x, y);
  } else {
    return false;
  }
}

function equal_undefined(x, y) {
  if (y !== undefined) {
    return eq(x, y);
  } else {
    return false;
  }
}

function equal_nullable(x, y) {
  if (y == null) {
    return false;
  } else {
    return eq(x, y);
  }
}

function neg(x) {
  if (eq(x, min_int)) {
    return min_int;
  } else {
    return add(not(x), one);
  }
}

function sub$3(x, y) {
  return add(x, neg(y));
}

function lsl_(x, numBits) {
  if (numBits === 0) {
    return x;
  } else {
    var lo = x.lo;
    if (numBits >= 32) {
      return {
              hi: (lo << (numBits - 32 | 0)),
              lo: 0
            };
    } else {
      var hi = (lo >>> (32 - numBits | 0)) | (x.hi << numBits);
      return {
              hi: hi,
              lo: ((lo << numBits) >>> 0)
            };
    }
  }
}

function lsr_(x, numBits) {
  if (numBits === 0) {
    return x;
  } else {
    var hi = x.hi;
    var offset = numBits - 32 | 0;
    if (offset === 0) {
      return {
              hi: 0,
              lo: (hi >>> 0)
            };
    } else if (offset > 0) {
      var lo = (hi >>> offset);
      return {
              hi: 0,
              lo: (lo >>> 0)
            };
    } else {
      var hi$1 = (hi >>> numBits);
      var lo$1 = (hi << (-offset | 0)) | (x.lo >>> numBits);
      return {
              hi: hi$1,
              lo: (lo$1 >>> 0)
            };
    }
  }
}

function asr_(x, numBits) {
  if (numBits === 0) {
    return x;
  } else {
    var hi = x.hi;
    if (numBits < 32) {
      var hi$1 = (hi >> numBits);
      var lo = (hi << (32 - numBits | 0)) | (x.lo >>> numBits);
      return {
              hi: hi$1,
              lo: (lo >>> 0)
            };
    } else {
      var lo$1 = (hi >> (numBits - 32 | 0));
      return {
              hi: hi >= 0 ? 0 : -1,
              lo: (lo$1 >>> 0)
            };
    }
  }
}

function is_zero(param) {
  if (param.hi !== 0 || param.lo !== 0) {
    return false;
  } else {
    return true;
  }
}

function mul(_this, _other) {
  while(true) {
    var other = _other;
    var $$this = _this;
    var lo;
    var this_hi = $$this.hi;
    var exit = 0;
    var exit$1 = 0;
    var exit$2 = 0;
    if (this_hi !== 0 || $$this.lo !== 0) {
      exit$2 = 4;
    } else {
      return zero;
    }
    if (exit$2 === 4) {
      if (other.hi !== 0 || other.lo !== 0) {
        exit$1 = 3;
      } else {
        return zero;
      }
    }
    if (exit$1 === 3) {
      if (this_hi !== -2147483648 || $$this.lo !== 0) {
        exit = 2;
      } else {
        lo = other.lo;
      }
    }
    if (exit === 2) {
      var other_hi = other.hi;
      var lo$1 = $$this.lo;
      var exit$3 = 0;
      if (other_hi !== -2147483648 || other.lo !== 0) {
        exit$3 = 3;
      } else {
        lo = lo$1;
      }
      if (exit$3 === 3) {
        var other_lo = other.lo;
        if (this_hi < 0) {
          if (other_hi < 0) {
            _other = neg(other);
            _this = neg($$this);
            continue ;
          } else {
            return neg(mul(neg($$this), other));
          }
        } else if (other_hi < 0) {
          return neg(mul($$this, neg(other)));
        } else {
          var a48 = (this_hi >>> 16);
          var a32 = this_hi & 65535;
          var a16 = (lo$1 >>> 16);
          var a00 = lo$1 & 65535;
          var b48 = (other_hi >>> 16);
          var b32 = other_hi & 65535;
          var b16 = (other_lo >>> 16);
          var b00 = other_lo & 65535;
          var c48 = 0;
          var c32 = 0;
          var c16 = 0;
          var c00 = a00 * b00;
          c16 = (c00 >>> 16) + a16 * b00;
          c32 = (c16 >>> 16);
          c16 = (c16 & 65535) + a00 * b16;
          c32 = c32 + (c16 >>> 16) + a32 * b00;
          c48 = (c32 >>> 16);
          c32 = (c32 & 65535) + a16 * b16;
          c48 = c48 + (c32 >>> 16);
          c32 = (c32 & 65535) + a00 * b32;
          c48 = c48 + (c32 >>> 16);
          c32 = c32 & 65535;
          c48 = c48 + (a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48) & 65535;
          var hi = c32 | (c48 << 16);
          var lo$2 = c00 & 65535 | ((c16 & 65535) << 16);
          return {
                  hi: hi,
                  lo: (lo$2 >>> 0)
                };
        }
      }
      
    }
    if ((lo & 1) === 0) {
      return zero;
    } else {
      return min_int;
    }
  }}

function swap(param) {
  var hi = caml_int32.caml_int32_bswap(param.lo);
  var lo = caml_int32.caml_int32_bswap(param.hi);
  return {
          hi: hi,
          lo: (lo >>> 0)
        };
}

function xor(param, param$1) {
  return {
          hi: param.hi ^ param$1.hi,
          lo: ((param.lo ^ param$1.lo) >>> 0)
        };
}

function or_(param, param$1) {
  return {
          hi: param.hi | param$1.hi,
          lo: ((param.lo | param$1.lo) >>> 0)
        };
}

function and_(param, param$1) {
  return {
          hi: param.hi & param$1.hi,
          lo: ((param.lo & param$1.lo) >>> 0)
        };
}

function ge(param, param$1) {
  var other_hi = param$1.hi;
  var hi = param.hi;
  if (hi > other_hi) {
    return true;
  } else if (hi < other_hi) {
    return false;
  } else {
    return param.lo >= param$1.lo;
  }
}

function neq(x, y) {
  return !eq(x, y);
}

function lt(x, y) {
  return !ge(x, y);
}

function gt(x, y) {
  if (x.hi > y.hi) {
    return true;
  } else if (x.hi < y.hi) {
    return false;
  } else {
    return x.lo > y.lo;
  }
}

function le(x, y) {
  return !gt(x, y);
}

function min(x, y) {
  if (ge(x, y)) {
    return y;
  } else {
    return x;
  }
}

function max(x, y) {
  if (gt(x, y)) {
    return x;
  } else {
    return y;
  }
}

function to_float(param) {
  return param.hi * (0x100000000) + param.lo;
}

function of_float(x) {
  if (isNaN(x) || !isFinite(x)) {
    return zero;
  } else if (x <= -9.22337203685477581e+18) {
    return min_int;
  } else if (x + 1 >= 9.22337203685477581e+18) {
    return max_int;
  } else if (x < 0) {
    return neg(of_float(-x));
  } else {
    var hi = x / 4294967296 | 0;
    var lo = x % 4294967296 | 0;
    return {
            hi: hi,
            lo: (lo >>> 0)
          };
  }
}

function div$1(_self, _other) {
  while(true) {
    var other = _other;
    var self = _self;
    var self_hi = self.hi;
    var exit = 0;
    var exit$1 = 0;
    if (other.hi !== 0 || other.lo !== 0) {
      exit$1 = 2;
    } else {
      throw caml_builtin_exceptions.division_by_zero;
    }
    if (exit$1 === 2) {
      if (self_hi !== -2147483648) {
        if (self_hi !== 0 || self.lo !== 0) {
          exit = 1;
        } else {
          return zero;
        }
      } else if (self.lo !== 0) {
        exit = 1;
      } else if (eq(other, one) || eq(other, neg_one)) {
        return self;
      } else if (eq(other, min_int)) {
        return one;
      } else {
        var other_hi = other.hi;
        var half_this = asr_(self, 1);
        var approx = lsl_(div$1(half_this, other), 1);
        if (approx.hi === 0 && approx.lo === 0) {
          if (other_hi < 0) {
            return one;
          } else {
            return neg(one);
          }
        }
        var y = mul(other, approx);
        var rem = add(self, neg(y));
        return add(approx, div$1(rem, other));
      }
    }
    if (exit === 1) {
      var other_hi$1 = other.hi;
      if (other_hi$1 === -2147483648 && other.lo === 0) {
        return zero;
      }
      if (self_hi < 0) {
        if (other_hi$1 < 0) {
          _other = neg(other);
          _self = neg(self);
          continue ;
        } else {
          return neg(div$1(neg(self), other));
        }
      } else if (other_hi$1 < 0) {
        return neg(div$1(self, neg(other)));
      } else {
        var res = zero;
        var rem$1 = self;
        while(ge(rem$1, other)) {
          var approx$1 = caml_primitive.caml_float_max(1, Math.floor(to_float(rem$1) / to_float(other)));
          var log2 = Math.ceil(Math.log(approx$1) / Math.LN2);
          var delta = log2 <= 48 ? 1 : Math.pow(2, log2 - 48);
          var approxRes = of_float(approx$1);
          var approxRem = mul(approxRes, other);
          while(approxRem.hi < 0 || gt(approxRem, rem$1)) {
            approx$1 = approx$1 - delta;
            approxRes = of_float(approx$1);
            approxRem = mul(approxRes, other);
          }          if (is_zero(approxRes)) {
            approxRes = one;
          }
          res = add(res, approxRes);
          rem$1 = add(rem$1, neg(approxRem));
        }        return res;
      }
    }
    
  }}

function mod_$1(self, other) {
  var y = mul(div$1(self, other), other);
  return add(self, neg(y));
}

function div_mod(self, other) {
  var quotient = div$1(self, other);
  var y = mul(quotient, other);
  return /* tuple */[
          quotient,
          add(self, neg(y))
        ];
}

function compare$3(self, other) {
  var v = caml_primitive.caml_nativeint_compare(self.hi, other.hi);
  if (v === 0) {
    return caml_primitive.caml_nativeint_compare(self.lo, other.lo);
  } else {
    return v;
  }
}

function of_int32(lo) {
  return {
          hi: lo < 0 ? -1 : 0,
          lo: (lo >>> 0)
        };
}

function to_int32(x) {
  return x.lo | 0;
}

function to_hex(x) {
  var x_lo = x.lo;
  var x_hi = x.hi;
  var aux = function (v) {
    return (v >>> 0).toString(16);
  };
  if (x_hi === 0 && x_lo === 0) {
    return "0";
  }
  if (x_lo !== 0) {
    if (x_hi !== 0) {
      var lo = aux(x_lo);
      var pad = 8 - lo.length | 0;
      if (pad <= 0) {
        return aux(x_hi) + lo;
      } else {
        return aux(x_hi) + (caml_utils.repeat(pad, "0") + lo);
      }
    } else {
      return aux(x_lo);
    }
  } else {
    return aux(x_hi) + "00000000";
  }
}

function discard_sign(x) {
  return {
          hi: 2147483647 & x.hi,
          lo: x.lo
        };
}

function float_of_bits(x) {
  return function (lo,hi){
   return (new Float64Array(new Int32Array([lo,hi]).buffer))[0]
   }(x.lo, x.hi);
}

function bits_of_float(x) {
  var buf = (new Int32Array(new Float64Array([x]).buffer));
  return {
          hi: buf[1],
          lo: (buf[0] >>> 0)
        };
}

function get64(s, i) {
  var hi = (s.charCodeAt(i + 4 | 0) << 32) | (s.charCodeAt(i + 5 | 0) << 40) | (s.charCodeAt(i + 6 | 0) << 48) | (s.charCodeAt(i + 7 | 0) << 56);
  var lo = s.charCodeAt(i) | (s.charCodeAt(i + 1 | 0) << 8) | (s.charCodeAt(i + 2 | 0) << 16) | (s.charCodeAt(i + 3 | 0) << 24);
  return {
          hi: hi,
          lo: (lo >>> 0)
        };
}

var min_int_1 = min_int;
var max_int_1 = max_int;
var one_1 = one;
var zero_1 = zero;
var not_1 = not;
var of_int32_1 = of_int32;
var to_int32_1 = to_int32;
var add_1 = add;
var neg_1 = neg;
var sub_1$3 = sub$3;
var lsl__1 = lsl_;
var lsr__1 = lsr_;
var asr__1 = asr_;
var is_zero_1 = is_zero;
var mul_1 = mul;
var xor_1 = xor;
var or__1 = or_;
var and__1 = and_;
var swap_1 = swap;
var ge_1 = ge;
var eq_1 = eq;
var neq_1 = neq;
var lt_1 = lt;
var gt_1 = gt;
var le_1 = le;
var equal_null_1 = equal_null;
var equal_undefined_1 = equal_undefined;
var equal_nullable_1 = equal_nullable;
var min_1 = min;
var max_1 = max;
var to_float_1 = to_float;
var of_float_1 = of_float;
var div_1$1 = div$1;
var mod__1$1 = mod_$1;
var compare_1$3 = compare$3;
var float_of_bits_1 = float_of_bits;
var bits_of_float_1 = bits_of_float;
var get64_1 = get64;
var div_mod_1 = div_mod;
var to_hex_1 = to_hex;
var discard_sign_1 = discard_sign;
/* Caml_int32 Not a pure module */

var caml_int64 = {
	min_int: min_int_1,
	max_int: max_int_1,
	one: one_1,
	zero: zero_1,
	not: not_1,
	of_int32: of_int32_1,
	to_int32: to_int32_1,
	add: add_1,
	neg: neg_1,
	sub: sub_1$3,
	lsl_: lsl__1,
	lsr_: lsr__1,
	asr_: asr__1,
	is_zero: is_zero_1,
	mul: mul_1,
	xor: xor_1,
	or_: or__1,
	and_: and__1,
	swap: swap_1,
	ge: ge_1,
	eq: eq_1,
	neq: neq_1,
	lt: lt_1,
	gt: gt_1,
	le: le_1,
	equal_null: equal_null_1,
	equal_undefined: equal_undefined_1,
	equal_nullable: equal_nullable_1,
	min: min_1,
	max: max_1,
	to_float: to_float_1,
	of_float: of_float_1,
	div: div_1$1,
	mod_: mod__1$1,
	compare: compare_1$3,
	float_of_bits: float_of_bits_1,
	bits_of_float: bits_of_float_1,
	get64: get64_1,
	div_mod: div_mod_1,
	to_hex: to_hex_1,
	discard_sign: discard_sign_1
};

function parse_digit(c) {
  if (c >= 65) {
    if (c >= 97) {
      if (c >= 123) {
        return -1;
      } else {
        return c - 87 | 0;
      }
    } else if (c >= 91) {
      return -1;
    } else {
      return c - 55 | 0;
    }
  } else if (c > 57 || c < 48) {
    return -1;
  } else {
    return c - /* "0" */48 | 0;
  }
}

function int_of_string_base(param) {
  switch (param) {
    case /* Oct */0 :
        return 8;
    case /* Hex */1 :
        return 16;
    case /* Dec */2 :
        return 10;
    case /* Bin */3 :
        return 2;
    
  }
}

function parse_sign_and_base(s) {
  var sign = 1;
  var base = /* Dec */2;
  var i = 0;
  var match = s.charCodeAt(i);
  switch (match) {
    case 43 :
        i = i + 1 | 0;
        break;
    case 44 :
        break;
    case 45 :
        sign = -1;
        i = i + 1 | 0;
        break;
      
  }
  if (s[i] === "0") {
    var match$1 = s.charCodeAt(i + 1 | 0);
    if (match$1 >= 89) {
      if (match$1 >= 111) {
        if (match$1 < 121) {
          switch (match$1 - 111 | 0) {
            case 0 :
                base = /* Oct */0;
                i = i + 2 | 0;
                break;
            case 6 :
                i = i + 2 | 0;
                break;
            case 1 :
            case 2 :
            case 3 :
            case 4 :
            case 5 :
            case 7 :
            case 8 :
                break;
            case 9 :
                base = /* Hex */1;
                i = i + 2 | 0;
                break;
            
          }
        }
        
      } else if (match$1 === 98) {
        base = /* Bin */3;
        i = i + 2 | 0;
      }
      
    } else if (match$1 !== 66) {
      if (match$1 >= 79) {
        switch (match$1 - 79 | 0) {
          case 0 :
              base = /* Oct */0;
              i = i + 2 | 0;
              break;
          case 6 :
              i = i + 2 | 0;
              break;
          case 1 :
          case 2 :
          case 3 :
          case 4 :
          case 5 :
          case 7 :
          case 8 :
              break;
          case 9 :
              base = /* Hex */1;
              i = i + 2 | 0;
              break;
          
        }
      }
      
    } else {
      base = /* Bin */3;
      i = i + 2 | 0;
    }
  }
  return /* tuple */[
          i,
          sign,
          base
        ];
}

function caml_int_of_string(s) {
  var match = parse_sign_and_base(s);
  var i = match[0];
  var base = int_of_string_base(match[2]);
  var threshold = 4294967295;
  var len = s.length;
  var c = i < len ? s.charCodeAt(i) : /* "\000" */0;
  var d = parse_digit(c);
  if (d < 0 || d >= base) {
    throw [
          caml_builtin_exceptions.failure,
          "int_of_string"
        ];
  }
  var aux = function (_acc, _k) {
    while(true) {
      var k = _k;
      var acc = _acc;
      if (k === len) {
        return acc;
      } else {
        var a = s.charCodeAt(k);
        if (a === /* "_" */95) {
          _k = k + 1 | 0;
          continue ;
        } else {
          var v = parse_digit(a);
          if (v < 0 || v >= base) {
            throw [
                  caml_builtin_exceptions.failure,
                  "int_of_string"
                ];
          }
          var acc$1 = base * acc + v;
          if (acc$1 > threshold) {
            throw [
                  caml_builtin_exceptions.failure,
                  "int_of_string"
                ];
          }
          _k = k + 1 | 0;
          _acc = acc$1;
          continue ;
        }
      }
    }  };
  var res = match[1] * aux(d, i + 1 | 0);
  var or_res = res | 0;
  if (base === 10 && res !== or_res) {
    throw [
          caml_builtin_exceptions.failure,
          "int_of_string"
        ];
  }
  return or_res;
}

function caml_int64_of_string(s) {
  var match = parse_sign_and_base(s);
  var hbase = match[2];
  var i = match[0];
  var base = caml_int64.of_int32(int_of_string_base(hbase));
  var sign = caml_int64.of_int32(match[1]);
  var threshold;
  switch (hbase) {
    case /* Oct */0 :
        threshold = /* int64 */{
          hi: 536870911,
          lo: 4294967295
        };
        break;
    case /* Hex */1 :
        threshold = /* int64 */{
          hi: 268435455,
          lo: 4294967295
        };
        break;
    case /* Dec */2 :
        threshold = /* int64 */{
          hi: 429496729,
          lo: 2576980377
        };
        break;
    case /* Bin */3 :
        threshold = /* int64 */{
          hi: 2147483647,
          lo: 4294967295
        };
        break;
    
  }
  var len = s.length;
  var c = i < len ? s.charCodeAt(i) : /* "\000" */0;
  var d = caml_int64.of_int32(parse_digit(c));
  if (caml_int64.lt(d, /* int64 */{
          hi: 0,
          lo: 0
        }) || caml_int64.ge(d, base)) {
    throw [
          caml_builtin_exceptions.failure,
          "int64_of_string"
        ];
  }
  var aux = function (_acc, _k) {
    while(true) {
      var k = _k;
      var acc = _acc;
      if (k === len) {
        return acc;
      } else {
        var a = s.charCodeAt(k);
        if (a === /* "_" */95) {
          _k = k + 1 | 0;
          continue ;
        } else {
          var v = caml_int64.of_int32(parse_digit(a));
          if (caml_int64.lt(v, /* int64 */{
                  hi: 0,
                  lo: 0
                }) || caml_int64.ge(v, base) || caml_int64.gt(acc, threshold)) {
            throw [
                  caml_builtin_exceptions.failure,
                  "int64_of_string"
                ];
          }
          var acc$1 = caml_int64.add(caml_int64.mul(base, acc), v);
          _k = k + 1 | 0;
          _acc = acc$1;
          continue ;
        }
      }
    }  };
  var res = caml_int64.mul(sign, aux(d, i + 1 | 0));
  var or_res = caml_int64.or_(res, /* int64 */{
        hi: 0,
        lo: 0
      });
  if (caml_int64.eq(base, /* int64 */{
          hi: 0,
          lo: 10
        }) && caml_int64.neq(res, or_res)) {
    throw [
          caml_builtin_exceptions.failure,
          "int64_of_string"
        ];
  }
  return or_res;
}

function int_of_base(param) {
  switch (param) {
    case /* Oct */0 :
        return 8;
    case /* Hex */1 :
        return 16;
    case /* Dec */2 :
        return 10;
    
  }
}

function lowercase$3(c) {
  if (c >= /* "A" */65 && c <= /* "Z" */90 || c >= /* "\192" */192 && c <= /* "\214" */214 || c >= /* "\216" */216 && c <= /* "\222" */222) {
    return c + 32 | 0;
  } else {
    return c;
  }
}

function parse_format(fmt) {
  var len = fmt.length;
  if (len > 31) {
    throw [
          caml_builtin_exceptions.invalid_argument,
          "format_int: format too long"
        ];
  }
  var f = {
    justify: "+",
    signstyle: "-",
    filter: " ",
    alternate: false,
    base: /* Dec */2,
    signedconv: false,
    width: 0,
    uppercase: false,
    sign: 1,
    prec: -1,
    conv: "f"
  };
  var _i = 0;
  while(true) {
    var i = _i;
    if (i >= len) {
      return f;
    } else {
      var c = fmt.charCodeAt(i);
      var exit = 0;
      if (c >= 69) {
        if (c >= 88) {
          if (c >= 121) {
            exit = 1;
          } else {
            switch (c - 88 | 0) {
              case 0 :
                  f.base = /* Hex */1;
                  f.uppercase = true;
                  _i = i + 1 | 0;
                  continue ;
              case 13 :
              case 14 :
              case 15 :
                  exit = 5;
                  break;
              case 12 :
              case 17 :
                  exit = 4;
                  break;
              case 23 :
                  f.base = /* Oct */0;
                  _i = i + 1 | 0;
                  continue ;
              case 29 :
                  f.base = /* Dec */2;
                  _i = i + 1 | 0;
                  continue ;
              case 1 :
              case 2 :
              case 3 :
              case 4 :
              case 5 :
              case 6 :
              case 7 :
              case 8 :
              case 9 :
              case 10 :
              case 11 :
              case 16 :
              case 18 :
              case 19 :
              case 20 :
              case 21 :
              case 22 :
              case 24 :
              case 25 :
              case 26 :
              case 27 :
              case 28 :
              case 30 :
              case 31 :
                  exit = 1;
                  break;
              case 32 :
                  f.base = /* Hex */1;
                  _i = i + 1 | 0;
                  continue ;
              
            }
          }
        } else if (c >= 72) {
          exit = 1;
        } else {
          f.signedconv = true;
          f.uppercase = true;
          f.conv = String.fromCharCode(lowercase$3(c));
          _i = i + 1 | 0;
          continue ;
        }
      } else {
        switch (c) {
          case 35 :
              f.alternate = true;
              _i = i + 1 | 0;
              continue ;
          case 32 :
          case 43 :
              exit = 2;
              break;
          case 45 :
              f.justify = "-";
              _i = i + 1 | 0;
              continue ;
          case 46 :
              f.prec = 0;
              var j = i + 1 | 0;
              while((function(j){
                  return function () {
                    var w = fmt.charCodeAt(j) - /* "0" */48 | 0;
                    return w >= 0 && w <= 9;
                  }
                  }(j))()) {
                f.prec = (caml_int32.imul(f.prec, 10) + fmt.charCodeAt(j) | 0) - /* "0" */48 | 0;
                j = j + 1 | 0;
              }              _i = j;
              continue ;
          case 33 :
          case 34 :
          case 36 :
          case 37 :
          case 38 :
          case 39 :
          case 40 :
          case 41 :
          case 42 :
          case 44 :
          case 47 :
              exit = 1;
              break;
          case 48 :
              f.filter = "0";
              _i = i + 1 | 0;
              continue ;
          case 49 :
          case 50 :
          case 51 :
          case 52 :
          case 53 :
          case 54 :
          case 55 :
          case 56 :
          case 57 :
              exit = 3;
              break;
          default:
            exit = 1;
        }
      }
      switch (exit) {
        case 1 :
            _i = i + 1 | 0;
            continue ;
        case 2 :
            f.signstyle = String.fromCharCode(c);
            _i = i + 1 | 0;
            continue ;
        case 3 :
            f.width = 0;
            var j$1 = i;
            while((function(j$1){
                return function () {
                  var w = fmt.charCodeAt(j$1) - /* "0" */48 | 0;
                  return w >= 0 && w <= 9;
                }
                }(j$1))()) {
              f.width = (caml_int32.imul(f.width, 10) + fmt.charCodeAt(j$1) | 0) - /* "0" */48 | 0;
              j$1 = j$1 + 1 | 0;
            }            _i = j$1;
            continue ;
        case 4 :
            f.signedconv = true;
            f.base = /* Dec */2;
            _i = i + 1 | 0;
            continue ;
        case 5 :
            f.signedconv = true;
            f.conv = String.fromCharCode(c);
            _i = i + 1 | 0;
            continue ;
        
      }
    }
  }}

function finish_formatting(config, rawbuffer) {
  var justify = config.justify;
  var signstyle = config.signstyle;
  var filter = config.filter;
  var alternate = config.alternate;
  var base = config.base;
  var signedconv = config.signedconv;
  var width = config.width;
  var uppercase = config.uppercase;
  var sign = config.sign;
  var len = rawbuffer.length;
  if (signedconv && (sign < 0 || signstyle !== "-")) {
    len = len + 1 | 0;
  }
  if (alternate) {
    if (base === /* Oct */0) {
      len = len + 1 | 0;
    } else if (base === /* Hex */1) {
      len = len + 2 | 0;
    }
    
  }
  var buffer = "";
  if (justify === "+" && filter === " ") {
    for(var i = len ,i_finish = width - 1 | 0; i <= i_finish; ++i){
      buffer = buffer + filter;
    }
  }
  if (signedconv) {
    if (sign < 0) {
      buffer = buffer + "-";
    } else if (signstyle !== "-") {
      buffer = buffer + signstyle;
    }
    
  }
  if (alternate && base === /* Oct */0) {
    buffer = buffer + "0";
  }
  if (alternate && base === /* Hex */1) {
    buffer = buffer + "0x";
  }
  if (justify === "+" && filter === "0") {
    for(var i$1 = len ,i_finish$1 = width - 1 | 0; i$1 <= i_finish$1; ++i$1){
      buffer = buffer + filter;
    }
  }
  buffer = uppercase ? buffer + rawbuffer.toUpperCase() : buffer + rawbuffer;
  if (justify === "-") {
    for(var i$2 = len ,i_finish$2 = width - 1 | 0; i$2 <= i_finish$2; ++i$2){
      buffer = buffer + " ";
    }
  }
  return buffer;
}

function caml_format_int(fmt, i) {
  if (fmt === "%d") {
    return String(i);
  } else {
    var f = parse_format(fmt);
    var f$1 = f;
    var i$1 = i;
    var i$2 = i$1 < 0 ? (
        f$1.signedconv ? (f$1.sign = -1, -i$1) : (i$1 >>> 0)
      ) : i$1;
    var s = i$2.toString(int_of_base(f$1.base));
    if (f$1.prec >= 0) {
      f$1.filter = " ";
      var n = f$1.prec - s.length | 0;
      if (n > 0) {
        s = caml_utils.repeat(n, "0") + s;
      }
      
    }
    return finish_formatting(f$1, s);
  }
}

function caml_int64_format(fmt, x) {
  var f = parse_format(fmt);
  var x$1 = f.signedconv && caml_int64.lt(x, /* int64 */{
        hi: 0,
        lo: 0
      }) ? (f.sign = -1, caml_int64.neg(x)) : x;
  var s = "";
  var match = f.base;
  switch (match) {
    case /* Oct */0 :
        var wbase = /* int64 */{
          hi: 0,
          lo: 8
        };
        var cvtbl = "01234567";
        if (caml_int64.lt(x$1, /* int64 */{
                hi: 0,
                lo: 0
              })) {
          var y = caml_int64.discard_sign(x$1);
          var match$1 = caml_int64.div_mod(y, wbase);
          var quotient = caml_int64.add(/* int64 */{
                hi: 268435456,
                lo: 0
              }, match$1[0]);
          var modulus = match$1[1];
          s = String.fromCharCode(cvtbl.charCodeAt(caml_int64.to_int32(modulus))) + s;
          while(caml_int64.neq(quotient, /* int64 */{
                  hi: 0,
                  lo: 0
                })) {
            var match$2 = caml_int64.div_mod(quotient, wbase);
            quotient = match$2[0];
            modulus = match$2[1];
            s = String.fromCharCode(cvtbl.charCodeAt(caml_int64.to_int32(modulus))) + s;
          }        } else {
          var match$3 = caml_int64.div_mod(x$1, wbase);
          var quotient$1 = match$3[0];
          var modulus$1 = match$3[1];
          s = String.fromCharCode(cvtbl.charCodeAt(caml_int64.to_int32(modulus$1))) + s;
          while(caml_int64.neq(quotient$1, /* int64 */{
                  hi: 0,
                  lo: 0
                })) {
            var match$4 = caml_int64.div_mod(quotient$1, wbase);
            quotient$1 = match$4[0];
            modulus$1 = match$4[1];
            s = String.fromCharCode(cvtbl.charCodeAt(caml_int64.to_int32(modulus$1))) + s;
          }        }
        break;
    case /* Hex */1 :
        s = caml_int64.to_hex(x$1) + s;
        break;
    case /* Dec */2 :
        var wbase$1 = /* int64 */{
          hi: 0,
          lo: 10
        };
        var cvtbl$1 = "0123456789";
        if (caml_int64.lt(x$1, /* int64 */{
                hi: 0,
                lo: 0
              })) {
          var y$1 = caml_int64.discard_sign(x$1);
          var match$5 = caml_int64.div_mod(y$1, wbase$1);
          var match$6 = caml_int64.div_mod(caml_int64.add(/* int64 */{
                    hi: 0,
                    lo: 8
                  }, match$5[1]), wbase$1);
          var quotient$2 = caml_int64.add(caml_int64.add(/* int64 */{
                    hi: 214748364,
                    lo: 3435973836
                  }, match$5[0]), match$6[0]);
          var modulus$2 = match$6[1];
          s = String.fromCharCode(cvtbl$1.charCodeAt(caml_int64.to_int32(modulus$2))) + s;
          while(caml_int64.neq(quotient$2, /* int64 */{
                  hi: 0,
                  lo: 0
                })) {
            var match$7 = caml_int64.div_mod(quotient$2, wbase$1);
            quotient$2 = match$7[0];
            modulus$2 = match$7[1];
            s = String.fromCharCode(cvtbl$1.charCodeAt(caml_int64.to_int32(modulus$2))) + s;
          }        } else {
          var match$8 = caml_int64.div_mod(x$1, wbase$1);
          var quotient$3 = match$8[0];
          var modulus$3 = match$8[1];
          s = String.fromCharCode(cvtbl$1.charCodeAt(caml_int64.to_int32(modulus$3))) + s;
          while(caml_int64.neq(quotient$3, /* int64 */{
                  hi: 0,
                  lo: 0
                })) {
            var match$9 = caml_int64.div_mod(quotient$3, wbase$1);
            quotient$3 = match$9[0];
            modulus$3 = match$9[1];
            s = String.fromCharCode(cvtbl$1.charCodeAt(caml_int64.to_int32(modulus$3))) + s;
          }        }
        break;
    
  }
  if (f.prec >= 0) {
    f.filter = " ";
    var n = f.prec - s.length | 0;
    if (n > 0) {
      s = caml_utils.repeat(n, "0") + s;
    }
    
  }
  return finish_formatting(f, s);
}

function caml_format_float(fmt, x) {
  var f = parse_format(fmt);
  var prec = f.prec < 0 ? 6 : f.prec;
  var x$1 = x < 0 ? (f.sign = -1, -x) : x;
  var s = "";
  if (isNaN(x$1)) {
    s = "nan";
    f.filter = " ";
  } else if (isFinite(x$1)) {
    var match = f.conv;
    switch (match) {
      case "e" :
          s = x$1.toExponential(prec);
          var i = s.length;
          if (s[i - 3 | 0] === "e") {
            s = s.slice(0, i - 1 | 0) + ("0" + s.slice(i - 1 | 0));
          }
          break;
      case "f" :
          s = x$1.toFixed(prec);
          break;
      case "g" :
          var prec$1 = prec !== 0 ? prec : 1;
          s = x$1.toExponential(prec$1 - 1 | 0);
          var j = s.indexOf("e");
          var exp = Number(s.slice(j + 1 | 0)) | 0;
          if (exp < -4 || x$1 >= 1e21 || x$1.toFixed().length > prec$1) {
            var i$1 = j - 1 | 0;
            while(s[i$1] === "0") {
              i$1 = i$1 - 1 | 0;
            }            if (s[i$1] === ".") {
              i$1 = i$1 - 1 | 0;
            }
            s = s.slice(0, i$1 + 1 | 0) + s.slice(j);
            var i$2 = s.length;
            if (s[i$2 - 3 | 0] === "e") {
              s = s.slice(0, i$2 - 1 | 0) + ("0" + s.slice(i$2 - 1 | 0));
            }
            
          } else {
            var p = prec$1;
            if (exp < 0) {
              p = p - (exp + 1 | 0) | 0;
              s = x$1.toFixed(p);
            } else {
              while((function () {
                      s = x$1.toFixed(p);
                      return s.length > (prec$1 + 1 | 0);
                    })()) {
                p = p - 1 | 0;
              }            }
            if (p !== 0) {
              var k = s.length - 1 | 0;
              while(s[k] === "0") {
                k = k - 1 | 0;
              }              if (s[k] === ".") {
                k = k - 1 | 0;
              }
              s = s.slice(0, k + 1 | 0);
            }
            
          }
          break;
        
    }
  } else {
    s = "inf";
    f.filter = " ";
  }
  return finish_formatting(f, s);
}

function caml_hexstring_of_float (x,prec,style){ 
  if (!isFinite(x)) {
    if (isNaN(x)) return "nan";
    return x > 0 ? "infinity":"-infinity";
  }
  var sign = (x==0 && 1/x == -Infinity)?1:(x>=0)?0:1;
  if(sign) x = -x;
  var exp = 0;
  if (x == 0) ;
  else if (x < 1) {
    while (x < 1 && exp > -1022)  { x *= 2; exp--; }
  } else {
    while (x >= 2) { x /= 2; exp++; }
  }
  var exp_sign = exp < 0 ? '' : '+';
  var sign_str = '';
  if (sign) sign_str = '-';
  else {
    switch(style){
    case 43 /* '+' */: sign_str = '+'; break;
    case 32 /* ' ' */: sign_str = ' '; break;
    }
  }
  if (prec >= 0 && prec < 13) {
    /* If a precision is given, and is small, round mantissa accordingly */
      var cst = Math.pow(2,prec * 4);
      x = Math.round(x * cst) / cst;
  }
  var x_str = x.toString(16);
  if(prec >= 0){
      var idx = x_str.indexOf('.');
    if(idx<0) {
      x_str += '.' +  '0'.repeat(prec);
    }
    else {
      var size = idx+1+prec;
      if(x_str.length < size)
        x_str += '0'.repeat(size - x_str.length);
      else
        x_str = x_str.substr(0,size);
    }
  }
  return  (sign_str + '0x' + x_str + 'p' + exp_sign + exp.toString(10));
}
function float_of_string (s,exn){ 

    var res = +s;
    if ((s.length > 0) && (res === res))
        return res;
    s = s.replace(/_/g, "");
    res = +s;
    if (((s.length > 0) && (res === res)) || /^[+-]?nan$/i.test(s)) {
        return res;
    }    var m = /^ *([+-]?)0x([0-9a-f]+)\.?([0-9a-f]*)p([+-]?[0-9]+)/i.exec(s);
    //            1        2             3           4
    if(m){
        var m3 = m[3].replace(/0+$/,'');
        var mantissa = parseInt(m[1] + m[2] + m3, 16);
        var exponent = (m[4]|0) - 4*m3.length;
        res = mantissa * Math.pow(2, exponent);
        return res;
    }
    if (/^\+?inf(inity)?$/i.test(s))
        return Infinity;
    if (/^-inf(inity)?$/i.test(s))
        return -Infinity;
    throw exn;

}
function caml_float_of_string(s) {
  return float_of_string(s, [
              caml_builtin_exceptions.failure,
              "float_of_string"
            ]);
}

var caml_nativeint_format = caml_format_int;

var caml_int32_format = caml_format_int;

var caml_int32_of_string = caml_int_of_string;

var caml_nativeint_of_string = caml_int_of_string;

var caml_format_float_1 = caml_format_float;
var caml_hexstring_of_float_1 = caml_hexstring_of_float;
var caml_format_int_1 = caml_format_int;
var caml_nativeint_format_1 = caml_nativeint_format;
var caml_int32_format_1 = caml_int32_format;
var caml_float_of_string_1 = caml_float_of_string;
var caml_int64_format_1 = caml_int64_format;
var caml_int_of_string_1 = caml_int_of_string;
var caml_int32_of_string_1 = caml_int32_of_string;
var caml_int64_of_string_1 = caml_int64_of_string;
var caml_nativeint_of_string_1 = caml_nativeint_of_string;
/* No side effect */

var caml_format = {
	caml_format_float: caml_format_float_1,
	caml_hexstring_of_float: caml_hexstring_of_float_1,
	caml_format_int: caml_format_int_1,
	caml_nativeint_format: caml_nativeint_format_1,
	caml_int32_format: caml_int32_format_1,
	caml_float_of_string: caml_float_of_string_1,
	caml_int64_format: caml_int64_format_1,
	caml_int_of_string: caml_int_of_string_1,
	caml_int32_of_string: caml_int32_of_string_1,
	caml_int64_of_string: caml_int64_of_string_1,
	caml_nativeint_of_string: caml_nativeint_of_string_1
};

function caml_string_get(s, i) {
  if (i >= s.length || i < 0) {
    throw [
          caml_builtin_exceptions.invalid_argument,
          "index out of bounds"
        ];
  }
  return s.charCodeAt(i);
}

function caml_string_get16(s, i) {
  return s.charCodeAt(i) + (s.charCodeAt(i + 1 | 0) << 8) | 0;
}

function caml_string_get32(s, i) {
  return ((s.charCodeAt(i) + (s.charCodeAt(i + 1 | 0) << 8) | 0) + (s.charCodeAt(i + 2 | 0) << 16) | 0) + (s.charCodeAt(i + 3 | 0) << 24) | 0;
}

function get$1(s, i) {
  if (i < 0 || i >= s.length) {
    throw [
          caml_builtin_exceptions.invalid_argument,
          "index out of bounds"
        ];
  }
  return s.charCodeAt(i);
}

var caml_string_get_1 = caml_string_get;
var caml_string_get16_1 = caml_string_get16;
var caml_string_get32_1 = caml_string_get32;
var get_1$1 = get$1;
/* No side effect */

var caml_string = {
	caml_string_get: caml_string_get_1,
	caml_string_get16: caml_string_get16_1,
	caml_string_get32: caml_string_get32_1,
	get: get_1$1
};

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

function getGlobalThis (){
  if (typeof globalThis !== 'undefined') return globalThis;
	if (typeof self !== 'undefined') return self;
	if (typeof window !== 'undefined') return window;
	if (typeof commonjsGlobal !== 'undefined') return commonjsGlobal;
	if (typeof this !== 'undefined') return this;
	throw new Error('Unable to locate global `this`');
}
function resolve (s){
  var myGlobal = getGlobalThis();
  if (myGlobal[s] === undefined){
    throw new Error(s + " not polyfilled by BuckleScript yet\n")
  }
  return myGlobal[s]
}
function register (s,fn){
  var myGlobal = getGlobalThis();
  myGlobal[s] = fn; 
  return 0
}
var getGlobalThis_1 = getGlobalThis;
var resolve_1 = resolve;
var register_1 = register;
/* No side effect */

var caml_external_polyfill = {
	getGlobalThis: getGlobalThis_1,
	resolve: resolve_1,
	register: register_1
};

function erase_rel(param) {
  if (typeof param === "number") {
    return /* End_of_fmtty */0;
  } else {
    switch (param.tag | 0) {
      case /* Char_ty */0 :
          return /* Char_ty */block.__(0, [erase_rel(param[0])]);
      case /* String_ty */1 :
          return /* String_ty */block.__(1, [erase_rel(param[0])]);
      case /* Int_ty */2 :
          return /* Int_ty */block.__(2, [erase_rel(param[0])]);
      case /* Int32_ty */3 :
          return /* Int32_ty */block.__(3, [erase_rel(param[0])]);
      case /* Nativeint_ty */4 :
          return /* Nativeint_ty */block.__(4, [erase_rel(param[0])]);
      case /* Int64_ty */5 :
          return /* Int64_ty */block.__(5, [erase_rel(param[0])]);
      case /* Float_ty */6 :
          return /* Float_ty */block.__(6, [erase_rel(param[0])]);
      case /* Bool_ty */7 :
          return /* Bool_ty */block.__(7, [erase_rel(param[0])]);
      case /* Format_arg_ty */8 :
          return /* Format_arg_ty */block.__(8, [
                    param[0],
                    erase_rel(param[1])
                  ]);
      case /* Format_subst_ty */9 :
          var ty1 = param[0];
          return /* Format_subst_ty */block.__(9, [
                    ty1,
                    ty1,
                    erase_rel(param[2])
                  ]);
      case /* Alpha_ty */10 :
          return /* Alpha_ty */block.__(10, [erase_rel(param[0])]);
      case /* Theta_ty */11 :
          return /* Theta_ty */block.__(11, [erase_rel(param[0])]);
      case /* Any_ty */12 :
          return /* Any_ty */block.__(12, [erase_rel(param[0])]);
      case /* Reader_ty */13 :
          return /* Reader_ty */block.__(13, [erase_rel(param[0])]);
      case /* Ignored_reader_ty */14 :
          return /* Ignored_reader_ty */block.__(14, [erase_rel(param[0])]);
      
    }
  }
}

function concat_fmtty(fmtty1, fmtty2) {
  if (typeof fmtty1 === "number") {
    return fmtty2;
  } else {
    switch (fmtty1.tag | 0) {
      case /* Char_ty */0 :
          return /* Char_ty */block.__(0, [concat_fmtty(fmtty1[0], fmtty2)]);
      case /* String_ty */1 :
          return /* String_ty */block.__(1, [concat_fmtty(fmtty1[0], fmtty2)]);
      case /* Int_ty */2 :
          return /* Int_ty */block.__(2, [concat_fmtty(fmtty1[0], fmtty2)]);
      case /* Int32_ty */3 :
          return /* Int32_ty */block.__(3, [concat_fmtty(fmtty1[0], fmtty2)]);
      case /* Nativeint_ty */4 :
          return /* Nativeint_ty */block.__(4, [concat_fmtty(fmtty1[0], fmtty2)]);
      case /* Int64_ty */5 :
          return /* Int64_ty */block.__(5, [concat_fmtty(fmtty1[0], fmtty2)]);
      case /* Float_ty */6 :
          return /* Float_ty */block.__(6, [concat_fmtty(fmtty1[0], fmtty2)]);
      case /* Bool_ty */7 :
          return /* Bool_ty */block.__(7, [concat_fmtty(fmtty1[0], fmtty2)]);
      case /* Format_arg_ty */8 :
          return /* Format_arg_ty */block.__(8, [
                    fmtty1[0],
                    concat_fmtty(fmtty1[1], fmtty2)
                  ]);
      case /* Format_subst_ty */9 :
          return /* Format_subst_ty */block.__(9, [
                    fmtty1[0],
                    fmtty1[1],
                    concat_fmtty(fmtty1[2], fmtty2)
                  ]);
      case /* Alpha_ty */10 :
          return /* Alpha_ty */block.__(10, [concat_fmtty(fmtty1[0], fmtty2)]);
      case /* Theta_ty */11 :
          return /* Theta_ty */block.__(11, [concat_fmtty(fmtty1[0], fmtty2)]);
      case /* Any_ty */12 :
          return /* Any_ty */block.__(12, [concat_fmtty(fmtty1[0], fmtty2)]);
      case /* Reader_ty */13 :
          return /* Reader_ty */block.__(13, [concat_fmtty(fmtty1[0], fmtty2)]);
      case /* Ignored_reader_ty */14 :
          return /* Ignored_reader_ty */block.__(14, [concat_fmtty(fmtty1[0], fmtty2)]);
      
    }
  }
}

function concat_fmt(fmt1, fmt2) {
  if (typeof fmt1 === "number") {
    return fmt2;
  } else {
    switch (fmt1.tag | 0) {
      case /* Char */0 :
          return /* Char */block.__(0, [concat_fmt(fmt1[0], fmt2)]);
      case /* Caml_char */1 :
          return /* Caml_char */block.__(1, [concat_fmt(fmt1[0], fmt2)]);
      case /* String */2 :
          return /* String */block.__(2, [
                    fmt1[0],
                    concat_fmt(fmt1[1], fmt2)
                  ]);
      case /* Caml_string */3 :
          return /* Caml_string */block.__(3, [
                    fmt1[0],
                    concat_fmt(fmt1[1], fmt2)
                  ]);
      case /* Int */4 :
          return /* Int */block.__(4, [
                    fmt1[0],
                    fmt1[1],
                    fmt1[2],
                    concat_fmt(fmt1[3], fmt2)
                  ]);
      case /* Int32 */5 :
          return /* Int32 */block.__(5, [
                    fmt1[0],
                    fmt1[1],
                    fmt1[2],
                    concat_fmt(fmt1[3], fmt2)
                  ]);
      case /* Nativeint */6 :
          return /* Nativeint */block.__(6, [
                    fmt1[0],
                    fmt1[1],
                    fmt1[2],
                    concat_fmt(fmt1[3], fmt2)
                  ]);
      case /* Int64 */7 :
          return /* Int64 */block.__(7, [
                    fmt1[0],
                    fmt1[1],
                    fmt1[2],
                    concat_fmt(fmt1[3], fmt2)
                  ]);
      case /* Float */8 :
          return /* Float */block.__(8, [
                    fmt1[0],
                    fmt1[1],
                    fmt1[2],
                    concat_fmt(fmt1[3], fmt2)
                  ]);
      case /* Bool */9 :
          return /* Bool */block.__(9, [
                    fmt1[0],
                    concat_fmt(fmt1[1], fmt2)
                  ]);
      case /* Flush */10 :
          return /* Flush */block.__(10, [concat_fmt(fmt1[0], fmt2)]);
      case /* String_literal */11 :
          return /* String_literal */block.__(11, [
                    fmt1[0],
                    concat_fmt(fmt1[1], fmt2)
                  ]);
      case /* Char_literal */12 :
          return /* Char_literal */block.__(12, [
                    fmt1[0],
                    concat_fmt(fmt1[1], fmt2)
                  ]);
      case /* Format_arg */13 :
          return /* Format_arg */block.__(13, [
                    fmt1[0],
                    fmt1[1],
                    concat_fmt(fmt1[2], fmt2)
                  ]);
      case /* Format_subst */14 :
          return /* Format_subst */block.__(14, [
                    fmt1[0],
                    fmt1[1],
                    concat_fmt(fmt1[2], fmt2)
                  ]);
      case /* Alpha */15 :
          return /* Alpha */block.__(15, [concat_fmt(fmt1[0], fmt2)]);
      case /* Theta */16 :
          return /* Theta */block.__(16, [concat_fmt(fmt1[0], fmt2)]);
      case /* Formatting_lit */17 :
          return /* Formatting_lit */block.__(17, [
                    fmt1[0],
                    concat_fmt(fmt1[1], fmt2)
                  ]);
      case /* Formatting_gen */18 :
          return /* Formatting_gen */block.__(18, [
                    fmt1[0],
                    concat_fmt(fmt1[1], fmt2)
                  ]);
      case /* Reader */19 :
          return /* Reader */block.__(19, [concat_fmt(fmt1[0], fmt2)]);
      case /* Scan_char_set */20 :
          return /* Scan_char_set */block.__(20, [
                    fmt1[0],
                    fmt1[1],
                    concat_fmt(fmt1[2], fmt2)
                  ]);
      case /* Scan_get_counter */21 :
          return /* Scan_get_counter */block.__(21, [
                    fmt1[0],
                    concat_fmt(fmt1[1], fmt2)
                  ]);
      case /* Scan_next_char */22 :
          return /* Scan_next_char */block.__(22, [concat_fmt(fmt1[0], fmt2)]);
      case /* Ignored_param */23 :
          return /* Ignored_param */block.__(23, [
                    fmt1[0],
                    concat_fmt(fmt1[1], fmt2)
                  ]);
      case /* Custom */24 :
          return /* Custom */block.__(24, [
                    fmt1[0],
                    fmt1[1],
                    concat_fmt(fmt1[2], fmt2)
                  ]);
      
    }
  }
}

var concat_fmtty_1 = concat_fmtty;
var erase_rel_1 = erase_rel;
var concat_fmt_1 = concat_fmt;
/* No side effect */

var camlinternalFormatBasics = {
	concat_fmtty: concat_fmtty_1,
	erase_rel: erase_rel_1,
	concat_fmt: concat_fmt_1
};

function failwith(s) {
  throw [
        caml_builtin_exceptions.failure,
        s
      ];
}

function invalid_arg(s) {
  throw [
        caml_builtin_exceptions.invalid_argument,
        s
      ];
}

var Exit = caml_exceptions.create("Pervasives.Exit");

function abs(x) {
  if (x >= 0) {
    return x;
  } else {
    return -x | 0;
  }
}

function lnot(x) {
  return x ^ -1;
}

var min_int$1 = -2147483648;

function classify_float(x) {
  if (isFinite(x)) {
    if (Math.abs(x) >= 2.22507385850720138e-308) {
      return /* FP_normal */0;
    } else if (x !== 0) {
      return /* FP_subnormal */1;
    } else {
      return /* FP_zero */2;
    }
  } else if (isNaN(x)) {
    return /* FP_nan */4;
  } else {
    return /* FP_infinite */3;
  }
}

function char_of_int(n) {
  if (n < 0 || n > 255) {
    throw [
          caml_builtin_exceptions.invalid_argument,
          "char_of_int"
        ];
  }
  return n;
}

function string_of_bool(b) {
  if (b) {
    return "true";
  } else {
    return "false";
  }
}

function bool_of_string(param) {
  switch (param) {
    case "false" :
        return false;
    case "true" :
        return true;
    default:
      throw [
            caml_builtin_exceptions.invalid_argument,
            "bool_of_string"
          ];
  }
}

function bool_of_string_opt(param) {
  switch (param) {
    case "false" :
        return false;
    case "true" :
        return true;
    default:
      return ;
  }
}

function int_of_string_opt(s) {
  try {
    return caml_format.caml_int_of_string(s);
  }
  catch (raw_exn){
    var exn = caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] === caml_builtin_exceptions.failure) {
      return ;
    } else {
      throw exn;
    }
  }
}

function valid_float_lexem(s) {
  var l = s.length;
  var _i = 0;
  while(true) {
    var i = _i;
    if (i >= l) {
      return s + ".";
    } else {
      var match = caml_string.get(s, i);
      if (match >= 48) {
        if (match >= 58) {
          return s;
        } else {
          _i = i + 1 | 0;
          continue ;
        }
      } else if (match !== 45) {
        return s;
      } else {
        _i = i + 1 | 0;
        continue ;
      }
    }
  }}

function string_of_float(f) {
  return valid_float_lexem(caml_format.caml_format_float("%.12g", f));
}

function float_of_string_opt(s) {
  try {
    return caml_format.caml_float_of_string(s);
  }
  catch (raw_exn){
    var exn = caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] === caml_builtin_exceptions.failure) {
      return ;
    } else {
      throw exn;
    }
  }
}

function $at(l1, l2) {
  if (l1) {
    return /* :: */[
            l1[0],
            $at(l1[1], l2)
          ];
  } else {
    return l2;
  }
}

var stdin$1 = caml_io.stdin;

var stdout$1 = caml_io.stdout;

var stderr$1 = caml_io.stderr;

function open_out_gen(mode, perm, name) {
  var c = caml_external_polyfill.resolve("caml_ml_open_descriptor_out")(caml_external_polyfill.resolve("caml_sys_open")(name, mode, perm));
  caml_external_polyfill.resolve("caml_ml_set_channel_name")(c, name);
  return c;
}

function open_out(name) {
  return open_out_gen(/* :: */[
              /* Open_wronly */1,
              /* :: */[
                /* Open_creat */3,
                /* :: */[
                  /* Open_trunc */4,
                  /* :: */[
                    /* Open_text */7,
                    /* [] */0
                  ]
                ]
              ]
            ], 438, name);
}

function open_out_bin(name) {
  return open_out_gen(/* :: */[
              /* Open_wronly */1,
              /* :: */[
                /* Open_creat */3,
                /* :: */[
                  /* Open_trunc */4,
                  /* :: */[
                    /* Open_binary */6,
                    /* [] */0
                  ]
                ]
              ]
            ], 438, name);
}

function flush_all(param) {
  var _param = caml_io.caml_ml_out_channels_list(/* () */0);
  while(true) {
    var param$1 = _param;
    if (param$1) {
      try {
        caml_io.caml_ml_flush(param$1[0]);
      }
      catch (raw_exn){
        var exn = caml_js_exceptions.internalToOCamlException(raw_exn);
        if (exn[0] !== caml_builtin_exceptions.sys_error) {
          throw exn;
        }
        
      }
      _param = param$1[1];
      continue ;
    } else {
      return /* () */0;
    }
  }}

function output_bytes(oc, s) {
  return caml_external_polyfill.resolve("caml_ml_output_bytes")(oc, s, 0, s.length);
}

function output_string(oc, s) {
  return caml_io.caml_ml_output(oc, s, 0, s.length);
}

function output(oc, s, ofs, len) {
  if (ofs < 0 || len < 0 || ofs > (s.length - len | 0)) {
    throw [
          caml_builtin_exceptions.invalid_argument,
          "output"
        ];
  }
  return caml_external_polyfill.resolve("caml_ml_output_bytes")(oc, s, ofs, len);
}

function output_substring(oc, s, ofs, len) {
  if (ofs < 0 || len < 0 || ofs > (s.length - len | 0)) {
    throw [
          caml_builtin_exceptions.invalid_argument,
          "output_substring"
        ];
  }
  return caml_io.caml_ml_output(oc, s, ofs, len);
}

function output_value(chan, v) {
  return caml_external_polyfill.resolve("caml_output_value")(chan, v, /* [] */0);
}

function close_out(oc) {
  caml_io.caml_ml_flush(oc);
  return caml_external_polyfill.resolve("caml_ml_close_channel")(oc);
}

function close_out_noerr(oc) {
  try {
    caml_io.caml_ml_flush(oc);
  }
  catch (exn){
    
  }
  try {
    return caml_external_polyfill.resolve("caml_ml_close_channel")(oc);
  }
  catch (exn$1){
    return /* () */0;
  }
}

function open_in_gen(mode, perm, name) {
  var c = caml_external_polyfill.resolve("caml_ml_open_descriptor_in")(caml_external_polyfill.resolve("caml_sys_open")(name, mode, perm));
  caml_external_polyfill.resolve("caml_ml_set_channel_name")(c, name);
  return c;
}

function open_in(name) {
  return open_in_gen(/* :: */[
              /* Open_rdonly */0,
              /* :: */[
                /* Open_text */7,
                /* [] */0
              ]
            ], 0, name);
}

function open_in_bin(name) {
  return open_in_gen(/* :: */[
              /* Open_rdonly */0,
              /* :: */[
                /* Open_binary */6,
                /* [] */0
              ]
            ], 0, name);
}

function input(ic, s, ofs, len) {
  if (ofs < 0 || len < 0 || ofs > (s.length - len | 0)) {
    throw [
          caml_builtin_exceptions.invalid_argument,
          "input"
        ];
  }
  return caml_external_polyfill.resolve("caml_ml_input")(ic, s, ofs, len);
}

function unsafe_really_input(ic, s, _ofs, _len) {
  while(true) {
    var len = _len;
    var ofs = _ofs;
    if (len <= 0) {
      return /* () */0;
    } else {
      var r = caml_external_polyfill.resolve("caml_ml_input")(ic, s, ofs, len);
      if (r === 0) {
        throw caml_builtin_exceptions.end_of_file;
      }
      _len = len - r | 0;
      _ofs = ofs + r | 0;
      continue ;
    }
  }}

function really_input(ic, s, ofs, len) {
  if (ofs < 0 || len < 0 || ofs > (s.length - len | 0)) {
    throw [
          caml_builtin_exceptions.invalid_argument,
          "really_input"
        ];
  }
  return unsafe_really_input(ic, s, ofs, len);
}

function really_input_string(ic, len) {
  var s = caml_bytes.caml_create_bytes(len);
  really_input(ic, s, 0, len);
  return caml_bytes.bytes_to_string(s);
}

function input_line(chan) {
  var build_result = function (buf, _pos, _param) {
    while(true) {
      var param = _param;
      var pos = _pos;
      if (param) {
        var hd = param[0];
        var len = hd.length;
        caml_bytes.caml_blit_bytes(hd, 0, buf, pos - len | 0, len);
        _param = param[1];
        _pos = pos - len | 0;
        continue ;
      } else {
        return buf;
      }
    }  };
  var scan = function (_accu, _len) {
    while(true) {
      var len = _len;
      var accu = _accu;
      var n = caml_external_polyfill.resolve("caml_ml_input_scan_line")(chan);
      if (n === 0) {
        if (accu) {
          return build_result(caml_bytes.caml_create_bytes(len), len, accu);
        } else {
          throw caml_builtin_exceptions.end_of_file;
        }
      } else if (n > 0) {
        var res = caml_bytes.caml_create_bytes(n - 1 | 0);
        caml_external_polyfill.resolve("caml_ml_input")(chan, res, 0, n - 1 | 0);
        caml_external_polyfill.resolve("caml_ml_input_char")(chan);
        if (accu) {
          var len$1 = (len + n | 0) - 1 | 0;
          return build_result(caml_bytes.caml_create_bytes(len$1), len$1, /* :: */[
                      res,
                      accu
                    ]);
        } else {
          return res;
        }
      } else {
        var beg = caml_bytes.caml_create_bytes(-n | 0);
        caml_external_polyfill.resolve("caml_ml_input")(chan, beg, 0, -n | 0);
        _len = len - n | 0;
        _accu = /* :: */[
          beg,
          accu
        ];
        continue ;
      }
    }  };
  return caml_bytes.bytes_to_string(scan(/* [] */0, 0));
}

function close_in_noerr(ic) {
  try {
    return caml_external_polyfill.resolve("caml_ml_close_channel")(ic);
  }
  catch (exn){
    return /* () */0;
  }
}

function print_char(c) {
  return caml_io.caml_ml_output_char(stdout$1, c);
}

function print_string(s) {
  return output_string(stdout$1, s);
}

function print_bytes(s) {
  return output_bytes(stdout$1, s);
}

function print_int(i) {
  return output_string(stdout$1, String(i));
}

function print_float(f) {
  return output_string(stdout$1, valid_float_lexem(caml_format.caml_format_float("%.12g", f)));
}

function print_newline(param) {
  caml_io.caml_ml_output_char(stdout$1, /* "\n" */10);
  return caml_io.caml_ml_flush(stdout$1);
}

function prerr_char(c) {
  return caml_io.caml_ml_output_char(stderr$1, c);
}

function prerr_string(s) {
  return output_string(stderr$1, s);
}

function prerr_bytes(s) {
  return output_bytes(stderr$1, s);
}

function prerr_int(i) {
  return output_string(stderr$1, String(i));
}

function prerr_float(f) {
  return output_string(stderr$1, valid_float_lexem(caml_format.caml_format_float("%.12g", f)));
}

function prerr_newline(param) {
  caml_io.caml_ml_output_char(stderr$1, /* "\n" */10);
  return caml_io.caml_ml_flush(stderr$1);
}

function read_line(param) {
  caml_io.caml_ml_flush(stdout$1);
  return input_line(stdin$1);
}

function read_int(param) {
  return caml_format.caml_int_of_string((caml_io.caml_ml_flush(stdout$1), input_line(stdin$1)));
}

function read_int_opt(param) {
  return int_of_string_opt((caml_io.caml_ml_flush(stdout$1), input_line(stdin$1)));
}

function read_float(param) {
  return caml_format.caml_float_of_string((caml_io.caml_ml_flush(stdout$1), input_line(stdin$1)));
}

function read_float_opt(param) {
  return float_of_string_opt((caml_io.caml_ml_flush(stdout$1), input_line(stdin$1)));
}

function string_of_format(param) {
  return param[1];
}

function $caret$caret(param, param$1) {
  return /* Format */[
          camlinternalFormatBasics.concat_fmt(param[0], param$1[0]),
          param[1] + ("%," + param$1[1])
        ];
}

var exit_function = {
  contents: flush_all
};

function at_exit(f) {
  var g = exit_function.contents;
  exit_function.contents = (function (param) {
      curry._1(f, /* () */0);
      return curry._1(g, /* () */0);
    });
  return /* () */0;
}

function do_at_exit(param) {
  return curry._1(exit_function.contents, /* () */0);
}

function exit(retcode) {
  do_at_exit();
  return caml_sys.caml_sys_exit(retcode);
}

var max_int$1 = 2147483647;

var infinity = Infinity;

var neg_infinity = -Infinity;

var max_float = 1.79769313486231571e+308;

var min_float = 2.22507385850720138e-308;

var epsilon_float = 2.22044604925031308e-16;

var flush = caml_io.caml_ml_flush;

var output_char = caml_io.caml_ml_output_char;

var output_byte = caml_io.caml_ml_output_char;

function output_binary_int(prim, prim$1) {
  return caml_external_polyfill.resolve("caml_ml_output_int")(prim, prim$1);
}

function seek_out(prim, prim$1) {
  return caml_external_polyfill.resolve("caml_ml_seek_out")(prim, prim$1);
}

function pos_out(prim) {
  return caml_external_polyfill.resolve("caml_ml_pos_out")(prim);
}

function out_channel_length(prim) {
  return caml_external_polyfill.resolve("caml_ml_channel_size")(prim);
}

function set_binary_mode_out(prim, prim$1) {
  return caml_external_polyfill.resolve("caml_ml_set_binary_mode")(prim, prim$1);
}

function input_char(prim) {
  return caml_external_polyfill.resolve("caml_ml_input_char")(prim);
}

function input_byte(prim) {
  return caml_external_polyfill.resolve("caml_ml_input_char")(prim);
}

function input_binary_int(prim) {
  return caml_external_polyfill.resolve("caml_ml_input_int")(prim);
}

function input_value(prim) {
  return caml_external_polyfill.resolve("caml_input_value")(prim);
}

function seek_in(prim, prim$1) {
  return caml_external_polyfill.resolve("caml_ml_seek_in")(prim, prim$1);
}

function pos_in(prim) {
  return caml_external_polyfill.resolve("caml_ml_pos_in")(prim);
}

function in_channel_length(prim) {
  return caml_external_polyfill.resolve("caml_ml_channel_size")(prim);
}

function close_in(prim) {
  return caml_external_polyfill.resolve("caml_ml_close_channel")(prim);
}

function set_binary_mode_in(prim, prim$1) {
  return caml_external_polyfill.resolve("caml_ml_set_binary_mode")(prim, prim$1);
}

function LargeFile_seek_out(prim, prim$1) {
  return caml_external_polyfill.resolve("caml_ml_seek_out_64")(prim, prim$1);
}

function LargeFile_pos_out(prim) {
  return caml_external_polyfill.resolve("caml_ml_pos_out_64")(prim);
}

function LargeFile_out_channel_length(prim) {
  return caml_external_polyfill.resolve("caml_ml_channel_size_64")(prim);
}

function LargeFile_seek_in(prim, prim$1) {
  return caml_external_polyfill.resolve("caml_ml_seek_in_64")(prim, prim$1);
}

function LargeFile_pos_in(prim) {
  return caml_external_polyfill.resolve("caml_ml_pos_in_64")(prim);
}

function LargeFile_in_channel_length(prim) {
  return caml_external_polyfill.resolve("caml_ml_channel_size_64")(prim);
}

var LargeFile = {
  seek_out: LargeFile_seek_out,
  pos_out: LargeFile_pos_out,
  out_channel_length: LargeFile_out_channel_length,
  seek_in: LargeFile_seek_in,
  pos_in: LargeFile_pos_in,
  in_channel_length: LargeFile_in_channel_length
};

var invalid_arg_1 = invalid_arg;
var failwith_1 = failwith;
var Exit_1 = Exit;
var abs_1 = abs;
var max_int_1$1 = max_int$1;
var min_int_1$1 = min_int$1;
var lnot_1 = lnot;
var infinity_1 = infinity;
var neg_infinity_1 = neg_infinity;
var max_float_1 = max_float;
var min_float_1 = min_float;
var epsilon_float_1 = epsilon_float;
var classify_float_1 = classify_float;
var char_of_int_1 = char_of_int;
var string_of_bool_1 = string_of_bool;
var bool_of_string_1 = bool_of_string;
var bool_of_string_opt_1 = bool_of_string_opt;
var int_of_string_opt_1 = int_of_string_opt;
var string_of_float_1 = string_of_float;
var float_of_string_opt_1 = float_of_string_opt;
var $at_1 = $at;
var stdin_1$1 = stdin$1;
var stdout_1$1 = stdout$1;
var stderr_1$1 = stderr$1;
var print_char_1 = print_char;
var print_string_1 = print_string;
var print_bytes_1 = print_bytes;
var print_int_1 = print_int;
var print_float_1 = print_float;
var print_newline_1 = print_newline;
var prerr_char_1 = prerr_char;
var prerr_string_1 = prerr_string;
var prerr_bytes_1 = prerr_bytes;
var prerr_int_1 = prerr_int;
var prerr_float_1 = prerr_float;
var prerr_newline_1 = prerr_newline;
var read_line_1 = read_line;
var read_int_1 = read_int;
var read_int_opt_1 = read_int_opt;
var read_float_1 = read_float;
var read_float_opt_1 = read_float_opt;
var open_out_1 = open_out;
var open_out_bin_1 = open_out_bin;
var open_out_gen_1 = open_out_gen;
var flush_1 = flush;
var flush_all_1 = flush_all;
var output_char_1 = output_char;
var output_string_1 = output_string;
var output_bytes_1 = output_bytes;
var output_1 = output;
var output_substring_1 = output_substring;
var output_byte_1 = output_byte;
var output_binary_int_1 = output_binary_int;
var output_value_1 = output_value;
var seek_out_1 = seek_out;
var pos_out_1 = pos_out;
var out_channel_length_1 = out_channel_length;
var close_out_1 = close_out;
var close_out_noerr_1 = close_out_noerr;
var set_binary_mode_out_1 = set_binary_mode_out;
var open_in_1 = open_in;
var open_in_bin_1 = open_in_bin;
var open_in_gen_1 = open_in_gen;
var input_char_1 = input_char;
var input_line_1 = input_line;
var input_1 = input;
var really_input_1 = really_input;
var really_input_string_1 = really_input_string;
var input_byte_1 = input_byte;
var input_binary_int_1 = input_binary_int;
var input_value_1 = input_value;
var seek_in_1 = seek_in;
var pos_in_1 = pos_in;
var in_channel_length_1 = in_channel_length;
var close_in_1 = close_in;
var close_in_noerr_1 = close_in_noerr;
var set_binary_mode_in_1 = set_binary_mode_in;
var LargeFile_1 = LargeFile;
var string_of_format_1 = string_of_format;
var $caret$caret_1 = $caret$caret;
var exit_1 = exit;
var at_exit_1 = at_exit;
var valid_float_lexem_1 = valid_float_lexem;
var unsafe_really_input_1 = unsafe_really_input;
var do_at_exit_1 = do_at_exit;
/* No side effect */

var pervasives = {
	invalid_arg: invalid_arg_1,
	failwith: failwith_1,
	Exit: Exit_1,
	abs: abs_1,
	max_int: max_int_1$1,
	min_int: min_int_1$1,
	lnot: lnot_1,
	infinity: infinity_1,
	neg_infinity: neg_infinity_1,
	max_float: max_float_1,
	min_float: min_float_1,
	epsilon_float: epsilon_float_1,
	classify_float: classify_float_1,
	char_of_int: char_of_int_1,
	string_of_bool: string_of_bool_1,
	bool_of_string: bool_of_string_1,
	bool_of_string_opt: bool_of_string_opt_1,
	int_of_string_opt: int_of_string_opt_1,
	string_of_float: string_of_float_1,
	float_of_string_opt: float_of_string_opt_1,
	$at: $at_1,
	stdin: stdin_1$1,
	stdout: stdout_1$1,
	stderr: stderr_1$1,
	print_char: print_char_1,
	print_string: print_string_1,
	print_bytes: print_bytes_1,
	print_int: print_int_1,
	print_float: print_float_1,
	print_newline: print_newline_1,
	prerr_char: prerr_char_1,
	prerr_string: prerr_string_1,
	prerr_bytes: prerr_bytes_1,
	prerr_int: prerr_int_1,
	prerr_float: prerr_float_1,
	prerr_newline: prerr_newline_1,
	read_line: read_line_1,
	read_int: read_int_1,
	read_int_opt: read_int_opt_1,
	read_float: read_float_1,
	read_float_opt: read_float_opt_1,
	open_out: open_out_1,
	open_out_bin: open_out_bin_1,
	open_out_gen: open_out_gen_1,
	flush: flush_1,
	flush_all: flush_all_1,
	output_char: output_char_1,
	output_string: output_string_1,
	output_bytes: output_bytes_1,
	output: output_1,
	output_substring: output_substring_1,
	output_byte: output_byte_1,
	output_binary_int: output_binary_int_1,
	output_value: output_value_1,
	seek_out: seek_out_1,
	pos_out: pos_out_1,
	out_channel_length: out_channel_length_1,
	close_out: close_out_1,
	close_out_noerr: close_out_noerr_1,
	set_binary_mode_out: set_binary_mode_out_1,
	open_in: open_in_1,
	open_in_bin: open_in_bin_1,
	open_in_gen: open_in_gen_1,
	input_char: input_char_1,
	input_line: input_line_1,
	input: input_1,
	really_input: really_input_1,
	really_input_string: really_input_string_1,
	input_byte: input_byte_1,
	input_binary_int: input_binary_int_1,
	input_value: input_value_1,
	seek_in: seek_in_1,
	pos_in: pos_in_1,
	in_channel_length: in_channel_length_1,
	close_in: close_in_1,
	close_in_noerr: close_in_noerr_1,
	set_binary_mode_in: set_binary_mode_in_1,
	LargeFile: LargeFile_1,
	string_of_format: string_of_format_1,
	$caret$caret: $caret$caret_1,
	exit: exit_1,
	at_exit: at_exit_1,
	valid_float_lexem: valid_float_lexem_1,
	unsafe_really_input: unsafe_really_input_1,
	do_at_exit: do_at_exit_1
};

function create$1(n) {
  var n$1 = n < 1 ? 1 : n;
  var s = caml_bytes.caml_create_bytes(n$1);
  return {
          buffer: s,
          position: 0,
          length: n$1,
          initial_buffer: s
        };
}

function contents(b) {
  return bytes.sub_string(b.buffer, 0, b.position);
}

function to_bytes(b) {
  return bytes.sub(b.buffer, 0, b.position);
}

function sub$4(b, ofs, len) {
  if (ofs < 0 || len < 0 || ofs > (b.position - len | 0)) {
    throw [
          caml_builtin_exceptions.invalid_argument,
          "Buffer.sub"
        ];
  }
  return bytes.sub_string(b.buffer, ofs, len);
}

function blit$3(src, srcoff, dst, dstoff, len) {
  if (len < 0 || srcoff < 0 || srcoff > (src.position - len | 0) || dstoff < 0 || dstoff > (dst.length - len | 0)) {
    throw [
          caml_builtin_exceptions.invalid_argument,
          "Buffer.blit"
        ];
  }
  return caml_bytes.caml_blit_bytes(src.buffer, srcoff, dst, dstoff, len);
}

function nth(b, ofs) {
  if (ofs < 0 || ofs >= b.position) {
    throw [
          caml_builtin_exceptions.invalid_argument,
          "Buffer.nth"
        ];
  }
  return b.buffer[ofs];
}

function length(b) {
  return b.position;
}

function clear(b) {
  b.position = 0;
  return /* () */0;
}

function reset(b) {
  b.position = 0;
  b.buffer = b.initial_buffer;
  b.length = b.buffer.length;
  return /* () */0;
}

function resize(b, more) {
  var len = b.length;
  var new_len = len;
  while((b.position + more | 0) > new_len) {
    new_len = (new_len << 1);
  }  var new_buffer = caml_bytes.caml_create_bytes(new_len);
  bytes.blit(b.buffer, 0, new_buffer, 0, b.position);
  b.buffer = new_buffer;
  b.length = new_len;
  return /* () */0;
}

function add_char(b, c) {
  var pos = b.position;
  if (pos >= b.length) {
    resize(b, 1);
  }
  b.buffer[pos] = c;
  b.position = pos + 1 | 0;
  return /* () */0;
}

function add_utf_8_uchar(b, u) {
  var u$1 = u;
  if (u$1 < 0) {
    throw [
          caml_builtin_exceptions.assert_failure,
          /* tuple */[
            "buffer.ml",
            90,
            19
          ]
        ];
  }
  if (u$1 <= 127) {
    return add_char(b, u$1);
  } else if (u$1 <= 2047) {
    var pos = b.position;
    if ((pos + 2 | 0) > b.length) {
      resize(b, 2);
    }
    b.buffer[pos] = 192 | (u$1 >>> 6);
    b.buffer[pos + 1 | 0] = 128 | u$1 & 63;
    b.position = pos + 2 | 0;
    return /* () */0;
  } else if (u$1 <= 65535) {
    var pos$1 = b.position;
    if ((pos$1 + 3 | 0) > b.length) {
      resize(b, 3);
    }
    b.buffer[pos$1] = 224 | (u$1 >>> 12);
    b.buffer[pos$1 + 1 | 0] = 128 | (u$1 >>> 6) & 63;
    b.buffer[pos$1 + 2 | 0] = 128 | u$1 & 63;
    b.position = pos$1 + 3 | 0;
    return /* () */0;
  } else if (u$1 <= 1114111) {
    var pos$2 = b.position;
    if ((pos$2 + 4 | 0) > b.length) {
      resize(b, 4);
    }
    b.buffer[pos$2] = 240 | (u$1 >>> 18);
    b.buffer[pos$2 + 1 | 0] = 128 | (u$1 >>> 12) & 63;
    b.buffer[pos$2 + 2 | 0] = 128 | (u$1 >>> 6) & 63;
    b.buffer[pos$2 + 3 | 0] = 128 | u$1 & 63;
    b.position = pos$2 + 4 | 0;
    return /* () */0;
  } else {
    throw [
          caml_builtin_exceptions.assert_failure,
          /* tuple */[
            "buffer.ml",
            123,
            8
          ]
        ];
  }
}

function add_utf_16be_uchar(b, u) {
  var u$1 = u;
  if (u$1 < 0) {
    throw [
          caml_builtin_exceptions.assert_failure,
          /* tuple */[
            "buffer.ml",
            126,
            19
          ]
        ];
  }
  if (u$1 <= 65535) {
    var pos = b.position;
    if ((pos + 2 | 0) > b.length) {
      resize(b, 2);
    }
    b.buffer[pos] = (u$1 >>> 8);
    b.buffer[pos + 1 | 0] = u$1 & 255;
    b.position = pos + 2 | 0;
    return /* () */0;
  } else if (u$1 <= 1114111) {
    var u$prime = u$1 - 65536 | 0;
    var hi = 55296 | (u$prime >>> 10);
    var lo = 56320 | u$prime & 1023;
    var pos$1 = b.position;
    if ((pos$1 + 4 | 0) > b.length) {
      resize(b, 4);
    }
    b.buffer[pos$1] = (hi >>> 8);
    b.buffer[pos$1 + 1 | 0] = hi & 255;
    b.buffer[pos$1 + 2 | 0] = (lo >>> 8);
    b.buffer[pos$1 + 3 | 0] = lo & 255;
    b.position = pos$1 + 4 | 0;
    return /* () */0;
  } else {
    throw [
          caml_builtin_exceptions.assert_failure,
          /* tuple */[
            "buffer.ml",
            144,
            8
          ]
        ];
  }
}

function add_utf_16le_uchar(b, u) {
  var u$1 = u;
  if (u$1 < 0) {
    throw [
          caml_builtin_exceptions.assert_failure,
          /* tuple */[
            "buffer.ml",
            147,
            19
          ]
        ];
  }
  if (u$1 <= 65535) {
    var pos = b.position;
    if ((pos + 2 | 0) > b.length) {
      resize(b, 2);
    }
    b.buffer[pos] = u$1 & 255;
    b.buffer[pos + 1 | 0] = (u$1 >>> 8);
    b.position = pos + 2 | 0;
    return /* () */0;
  } else if (u$1 <= 1114111) {
    var u$prime = u$1 - 65536 | 0;
    var hi = 55296 | (u$prime >>> 10);
    var lo = 56320 | u$prime & 1023;
    var pos$1 = b.position;
    if ((pos$1 + 4 | 0) > b.length) {
      resize(b, 4);
    }
    b.buffer[pos$1] = hi & 255;
    b.buffer[pos$1 + 1 | 0] = (hi >>> 8);
    b.buffer[pos$1 + 2 | 0] = lo & 255;
    b.buffer[pos$1 + 3 | 0] = (lo >>> 8);
    b.position = pos$1 + 4 | 0;
    return /* () */0;
  } else {
    throw [
          caml_builtin_exceptions.assert_failure,
          /* tuple */[
            "buffer.ml",
            165,
            8
          ]
        ];
  }
}

function add_substring(b, s, offset, len) {
  if (offset < 0 || len < 0 || offset > (s.length - len | 0)) {
    throw [
          caml_builtin_exceptions.invalid_argument,
          "Buffer.add_substring/add_subbytes"
        ];
  }
  var new_position = b.position + len | 0;
  if (new_position > b.length) {
    resize(b, len);
  }
  bytes.blit_string(s, offset, b.buffer, b.position, len);
  b.position = new_position;
  return /* () */0;
}

function add_subbytes(b, s, offset, len) {
  return add_substring(b, caml_bytes.bytes_to_string(s), offset, len);
}

function add_string(b, s) {
  var len = s.length;
  var new_position = b.position + len | 0;
  if (new_position > b.length) {
    resize(b, len);
  }
  bytes.blit_string(s, 0, b.buffer, b.position, len);
  b.position = new_position;
  return /* () */0;
}

function add_bytes(b, s) {
  return add_string(b, caml_bytes.bytes_to_string(s));
}

function add_buffer(b, bs) {
  return add_subbytes(b, bs.buffer, 0, bs.position);
}

function add_channel(b, ic, len) {
  if (len < 0) {
    throw [
          caml_builtin_exceptions.invalid_argument,
          "Buffer.add_channel"
        ];
  }
  if ((b.position + len | 0) > b.length) {
    resize(b, len);
  }
  var b$1 = b;
  var ic$1 = ic;
  var _len = len;
  while(true) {
    var len$1 = _len;
    if (len$1 > 0) {
      var n = pervasives.input(ic$1, b$1.buffer, b$1.position, len$1);
      b$1.position = b$1.position + n | 0;
      if (n === 0) {
        throw caml_builtin_exceptions.end_of_file;
      }
      _len = len$1 - n | 0;
      continue ;
    } else {
      return 0;
    }
  }}

function output_buffer(oc, b) {
  return pervasives.output(oc, b.buffer, 0, b.position);
}

function closing(param) {
  if (param !== 40) {
    if (param !== 123) {
      throw [
            caml_builtin_exceptions.assert_failure,
            /* tuple */[
              "buffer.ml",
              216,
              9
            ]
          ];
    } else {
      return /* "}" */125;
    }
  } else {
    return /* ")" */41;
  }
}

function advance_to_closing(opening, closing, k, s, start) {
  var _k = k;
  var _i = start;
  var lim = s.length;
  while(true) {
    var i = _i;
    var k$1 = _k;
    if (i >= lim) {
      throw caml_builtin_exceptions.not_found;
    }
    if (caml_string.get(s, i) === opening) {
      _i = i + 1 | 0;
      _k = k$1 + 1 | 0;
      continue ;
    } else if (caml_string.get(s, i) === closing) {
      if (k$1 === 0) {
        return i;
      } else {
        _i = i + 1 | 0;
        _k = k$1 - 1 | 0;
        continue ;
      }
    } else {
      _i = i + 1 | 0;
      continue ;
    }
  }}

function advance_to_non_alpha(s, start) {
  var _i = start;
  var lim = s.length;
  while(true) {
    var i = _i;
    if (i >= lim) {
      return lim;
    } else {
      var match = caml_string.get(s, i);
      if (match >= 91) {
        if (match >= 97) {
          if (match >= 123) {
            return i;
          }
          
        } else if (match !== 95) {
          return i;
        }
        
      } else if (match >= 58) {
        if (match < 65) {
          return i;
        }
        
      } else if (match < 48) {
        return i;
      }
      _i = i + 1 | 0;
      continue ;
    }
  }}

function find_ident(s, start, lim) {
  if (start >= lim) {
    throw caml_builtin_exceptions.not_found;
  }
  var c = caml_string.get(s, start);
  if (c !== 40 && c !== 123) {
    var stop = advance_to_non_alpha(s, start + 1 | 0);
    return /* tuple */[
            string.sub(s, start, stop - start | 0),
            stop
          ];
  }
  var new_start = start + 1 | 0;
  var stop$1 = advance_to_closing(c, closing(c), 0, s, new_start);
  return /* tuple */[
          string.sub(s, new_start, (stop$1 - start | 0) - 1 | 0),
          stop$1 + 1 | 0
        ];
}

function add_substitute(b, f, s) {
  var lim = s.length;
  var _previous = /* " " */32;
  var _i = 0;
  while(true) {
    var i = _i;
    var previous = _previous;
    if (i < lim) {
      var current = caml_string.get(s, i);
      if (current !== 36) {
        if (previous === /* "\\" */92) {
          add_char(b, /* "\\" */92);
          add_char(b, current);
          _i = i + 1 | 0;
          _previous = /* " " */32;
          continue ;
        } else if (current !== 92) {
          add_char(b, current);
          _i = i + 1 | 0;
          _previous = current;
          continue ;
        } else {
          _i = i + 1 | 0;
          _previous = current;
          continue ;
        }
      } else if (previous === /* "\\" */92) {
        add_char(b, current);
        _i = i + 1 | 0;
        _previous = /* " " */32;
        continue ;
      } else {
        var j = i + 1 | 0;
        var match = find_ident(s, j, lim);
        add_string(b, curry._1(f, match[0]));
        _i = match[1];
        _previous = /* " " */32;
        continue ;
      }
    } else if (previous === /* "\\" */92) {
      return add_char(b, previous);
    } else {
      return 0;
    }
  }}

function truncate(b, len) {
  if (len < 0 || len > b.position) {
    throw [
          caml_builtin_exceptions.invalid_argument,
          "Buffer.truncate"
        ];
  }
  b.position = len;
  return /* () */0;
}

var create_1$1 = create$1;
var contents_1 = contents;
var to_bytes_1 = to_bytes;
var sub_1$4 = sub$4;
var blit_1$3 = blit$3;
var nth_1 = nth;
var length_1 = length;
var clear_1 = clear;
var reset_1 = reset;
var add_char_1 = add_char;
var add_utf_8_uchar_1 = add_utf_8_uchar;
var add_utf_16le_uchar_1 = add_utf_16le_uchar;
var add_utf_16be_uchar_1 = add_utf_16be_uchar;
var add_string_1 = add_string;
var add_bytes_1 = add_bytes;
var add_substring_1 = add_substring;
var add_subbytes_1 = add_subbytes;
var add_substitute_1 = add_substitute;
var add_buffer_1 = add_buffer;
var add_channel_1 = add_channel;
var output_buffer_1 = output_buffer;
var truncate_1 = truncate;
/* No side effect */

var buffer = {
	create: create_1$1,
	contents: contents_1,
	to_bytes: to_bytes_1,
	sub: sub_1$4,
	blit: blit_1$3,
	nth: nth_1,
	length: length_1,
	clear: clear_1,
	reset: reset_1,
	add_char: add_char_1,
	add_utf_8_uchar: add_utf_8_uchar_1,
	add_utf_16le_uchar: add_utf_16le_uchar_1,
	add_utf_16be_uchar: add_utf_16be_uchar_1,
	add_string: add_string_1,
	add_bytes: add_bytes_1,
	add_substring: add_substring_1,
	add_subbytes: add_subbytes_1,
	add_substitute: add_substitute_1,
	add_buffer: add_buffer_1,
	add_channel: add_channel_1,
	output_buffer: output_buffer_1,
	truncate: truncate_1
};

function create_char_set(param) {
  return bytes.make(32, /* "\000" */0);
}

function add_in_char_set(char_set, c) {
  var str_ind = (c >>> 3);
  var mask = (1 << (c & 7));
  char_set[str_ind] = pervasives.char_of_int(caml_bytes.get(char_set, str_ind) | mask);
  return /* () */0;
}

var freeze_char_set = bytes.to_string;

function rev_char_set(char_set) {
  var char_set$prime = bytes.make(32, /* "\000" */0);
  for(var i = 0; i <= 31; ++i){
    char_set$prime[i] = pervasives.char_of_int(caml_string.get(char_set, i) ^ 255);
  }
  return caml_bytes.bytes_to_string(char_set$prime);
}

function is_in_char_set(char_set, c) {
  var str_ind = (c >>> 3);
  var mask = (1 << (c & 7));
  return (caml_string.get(char_set, str_ind) & mask) !== 0;
}

function pad_of_pad_opt(pad_opt) {
  if (pad_opt !== undefined) {
    return /* Lit_padding */block.__(0, [
              /* Right */1,
              pad_opt
            ]);
  } else {
    return /* No_padding */0;
  }
}

function prec_of_prec_opt(prec_opt) {
  if (prec_opt !== undefined) {
    return /* Lit_precision */[prec_opt];
  } else {
    return /* No_precision */0;
  }
}

function param_format_of_ignored_format(ign, fmt) {
  if (typeof ign === "number") {
    switch (ign) {
      case /* Ignored_char */0 :
          return /* Param_format_EBB */[/* Char */block.__(0, [fmt])];
      case /* Ignored_caml_char */1 :
          return /* Param_format_EBB */[/* Caml_char */block.__(1, [fmt])];
      case /* Ignored_reader */2 :
          return /* Param_format_EBB */[/* Reader */block.__(19, [fmt])];
      case /* Ignored_scan_next_char */3 :
          return /* Param_format_EBB */[/* Scan_next_char */block.__(22, [fmt])];
      
    }
  } else {
    switch (ign.tag | 0) {
      case /* Ignored_string */0 :
          return /* Param_format_EBB */[/* String */block.__(2, [
                      pad_of_pad_opt(ign[0]),
                      fmt
                    ])];
      case /* Ignored_caml_string */1 :
          return /* Param_format_EBB */[/* Caml_string */block.__(3, [
                      pad_of_pad_opt(ign[0]),
                      fmt
                    ])];
      case /* Ignored_int */2 :
          return /* Param_format_EBB */[/* Int */block.__(4, [
                      ign[0],
                      pad_of_pad_opt(ign[1]),
                      /* No_precision */0,
                      fmt
                    ])];
      case /* Ignored_int32 */3 :
          return /* Param_format_EBB */[/* Int32 */block.__(5, [
                      ign[0],
                      pad_of_pad_opt(ign[1]),
                      /* No_precision */0,
                      fmt
                    ])];
      case /* Ignored_nativeint */4 :
          return /* Param_format_EBB */[/* Nativeint */block.__(6, [
                      ign[0],
                      pad_of_pad_opt(ign[1]),
                      /* No_precision */0,
                      fmt
                    ])];
      case /* Ignored_int64 */5 :
          return /* Param_format_EBB */[/* Int64 */block.__(7, [
                      ign[0],
                      pad_of_pad_opt(ign[1]),
                      /* No_precision */0,
                      fmt
                    ])];
      case /* Ignored_float */6 :
          return /* Param_format_EBB */[/* Float */block.__(8, [
                      /* Float_f */0,
                      pad_of_pad_opt(ign[0]),
                      prec_of_prec_opt(ign[1]),
                      fmt
                    ])];
      case /* Ignored_bool */7 :
          return /* Param_format_EBB */[/* Bool */block.__(9, [
                      pad_of_pad_opt(ign[0]),
                      fmt
                    ])];
      case /* Ignored_format_arg */8 :
          return /* Param_format_EBB */[/* Format_arg */block.__(13, [
                      ign[0],
                      ign[1],
                      fmt
                    ])];
      case /* Ignored_format_subst */9 :
          return /* Param_format_EBB */[/* Format_subst */block.__(14, [
                      ign[0],
                      ign[1],
                      fmt
                    ])];
      case /* Ignored_scan_char_set */10 :
          return /* Param_format_EBB */[/* Scan_char_set */block.__(20, [
                      ign[0],
                      ign[1],
                      fmt
                    ])];
      case /* Ignored_scan_get_counter */11 :
          return /* Param_format_EBB */[/* Scan_get_counter */block.__(21, [
                      ign[0],
                      fmt
                    ])];
      
    }
  }
}

function buffer_check_size(buf, overhead) {
  var len = buf.bytes.length;
  var min_len = buf.ind + overhead | 0;
  if (min_len > len) {
    var new_len = caml_primitive.caml_int_max((len << 1), min_len);
    var new_str = caml_bytes.caml_create_bytes(new_len);
    bytes.blit(buf.bytes, 0, new_str, 0, len);
    buf.bytes = new_str;
    return /* () */0;
  } else {
    return 0;
  }
}

function buffer_add_char(buf, c) {
  buffer_check_size(buf, 1);
  buf.bytes[buf.ind] = c;
  buf.ind = buf.ind + 1 | 0;
  return /* () */0;
}

function buffer_add_string(buf, s) {
  var str_len = s.length;
  buffer_check_size(buf, str_len);
  string.blit(s, 0, buf.bytes, buf.ind, str_len);
  buf.ind = buf.ind + str_len | 0;
  return /* () */0;
}

function buffer_contents(buf) {
  return bytes.sub_string(buf.bytes, 0, buf.ind);
}

function char_of_iconv(iconv) {
  switch (iconv) {
    case /* Int_d */0 :
    case /* Int_pd */1 :
    case /* Int_sd */2 :
        return /* "d" */100;
    case /* Int_i */3 :
    case /* Int_pi */4 :
    case /* Int_si */5 :
        return /* "i" */105;
    case /* Int_x */6 :
    case /* Int_Cx */7 :
        return /* "x" */120;
    case /* Int_X */8 :
    case /* Int_CX */9 :
        return /* "X" */88;
    case /* Int_o */10 :
    case /* Int_Co */11 :
        return /* "o" */111;
    case /* Int_u */12 :
        return /* "u" */117;
    
  }
}

function char_of_fconv(fconv) {
  switch (fconv) {
    case /* Float_f */0 :
    case /* Float_pf */1 :
    case /* Float_sf */2 :
        return /* "f" */102;
    case /* Float_e */3 :
    case /* Float_pe */4 :
    case /* Float_se */5 :
        return /* "e" */101;
    case /* Float_E */6 :
    case /* Float_pE */7 :
    case /* Float_sE */8 :
        return /* "E" */69;
    case /* Float_g */9 :
    case /* Float_pg */10 :
    case /* Float_sg */11 :
        return /* "g" */103;
    case /* Float_G */12 :
    case /* Float_pG */13 :
    case /* Float_sG */14 :
        return /* "G" */71;
    case /* Float_F */15 :
        return /* "F" */70;
    case /* Float_h */16 :
    case /* Float_ph */17 :
    case /* Float_sh */18 :
        return /* "h" */104;
    case /* Float_H */19 :
    case /* Float_pH */20 :
    case /* Float_sH */21 :
        return /* "H" */72;
    
  }
}

function char_of_counter(counter) {
  switch (counter) {
    case /* Line_counter */0 :
        return /* "l" */108;
    case /* Char_counter */1 :
        return /* "n" */110;
    case /* Token_counter */2 :
        return /* "N" */78;
    
  }
}

function bprint_char_set(buf, char_set) {
  var print_char = function (buf, i) {
    var c = pervasives.char_of_int(i);
    if (c !== 37) {
      if (c !== 64) {
        return buffer_add_char(buf, c);
      } else {
        buffer_add_char(buf, /* "%" */37);
        return buffer_add_char(buf, /* "@" */64);
      }
    } else {
      buffer_add_char(buf, /* "%" */37);
      return buffer_add_char(buf, /* "%" */37);
    }
  };
  var print_out = function (set, _i) {
    while(true) {
      var i = _i;
      if (i < 256) {
        if (is_in_char_set(set, pervasives.char_of_int(i))) {
          var set$1 = set;
          var i$1 = i;
          var match = pervasives.char_of_int(i$1);
          var switcher = match - 45 | 0;
          if (switcher > 48 || switcher < 0) {
            if (switcher >= 210) {
              return print_char(buf, 255);
            } else {
              return print_second(set$1, i$1 + 1 | 0);
            }
          } else if (switcher > 47 || switcher < 1) {
            return print_out(set$1, i$1 + 1 | 0);
          } else {
            return print_second(set$1, i$1 + 1 | 0);
          }
        } else {
          _i = i + 1 | 0;
          continue ;
        }
      } else {
        return 0;
      }
    }  };
  var print_second = function (set, i) {
    if (is_in_char_set(set, pervasives.char_of_int(i))) {
      var match = pervasives.char_of_int(i);
      var switcher = match - 45 | 0;
      if (switcher > 48 || switcher < 0) {
        if (switcher >= 210) {
          print_char(buf, 254);
          return print_char(buf, 255);
        }
        
      } else if ((switcher > 47 || switcher < 1) && !is_in_char_set(set, pervasives.char_of_int(i + 1 | 0))) {
        print_char(buf, i - 1 | 0);
        return print_out(set, i + 1 | 0);
      }
      if (is_in_char_set(set, pervasives.char_of_int(i + 1 | 0))) {
        var set$1 = set;
        var i$1 = i - 1 | 0;
        var _j = i + 2 | 0;
        while(true) {
          var j = _j;
          if (j === 256 || !is_in_char_set(set$1, pervasives.char_of_int(j))) {
            print_char(buf, i$1);
            print_char(buf, /* "-" */45);
            print_char(buf, j - 1 | 0);
            if (j < 256) {
              return print_out(set$1, j + 1 | 0);
            } else {
              return 0;
            }
          } else {
            _j = j + 1 | 0;
            continue ;
          }
        }      } else {
        print_char(buf, i - 1 | 0);
        print_char(buf, i);
        return print_out(set, i + 2 | 0);
      }
    } else {
      print_char(buf, i - 1 | 0);
      return print_out(set, i + 1 | 0);
    }
  };
  var print_start = function (set) {
    var is_alone = function (c) {
      var before = char_1.chr(c - 1 | 0);
      var after = char_1.chr(c + 1 | 0);
      if (is_in_char_set(set, c)) {
        return !(is_in_char_set(set, before) && is_in_char_set(set, after));
      } else {
        return false;
      }
    };
    if (is_alone(/* "]" */93)) {
      buffer_add_char(buf, /* "]" */93);
    }
    print_out(set, 1);
    if (is_alone(/* "-" */45)) {
      return buffer_add_char(buf, /* "-" */45);
    } else {
      return 0;
    }
  };
  buffer_add_char(buf, /* "[" */91);
  print_start(is_in_char_set(char_set, /* "\000" */0) ? (buffer_add_char(buf, /* "^" */94), rev_char_set(char_set)) : char_set);
  return buffer_add_char(buf, /* "]" */93);
}

function bprint_padty(buf, padty) {
  switch (padty) {
    case /* Left */0 :
        return buffer_add_char(buf, /* "-" */45);
    case /* Right */1 :
        return /* () */0;
    case /* Zeros */2 :
        return buffer_add_char(buf, /* "0" */48);
    
  }
}

function bprint_ignored_flag(buf, ign_flag) {
  if (ign_flag) {
    return buffer_add_char(buf, /* "_" */95);
  } else {
    return 0;
  }
}

function bprint_pad_opt(buf, pad_opt) {
  if (pad_opt !== undefined) {
    return buffer_add_string(buf, String(pad_opt));
  } else {
    return /* () */0;
  }
}

function bprint_padding(buf, pad) {
  if (typeof pad === "number") {
    return /* () */0;
  } else {
    bprint_padty(buf, pad[0]);
    if (pad.tag) {
      return buffer_add_char(buf, /* "*" */42);
    } else {
      return buffer_add_string(buf, String(pad[1]));
    }
  }
}

function bprint_precision(buf, prec) {
  if (typeof prec === "number") {
    if (prec !== 0) {
      return buffer_add_string(buf, ".*");
    } else {
      return /* () */0;
    }
  } else {
    buffer_add_char(buf, /* "." */46);
    return buffer_add_string(buf, String(prec[0]));
  }
}

function bprint_iconv_flag(buf, iconv) {
  switch (iconv) {
    case /* Int_pd */1 :
    case /* Int_pi */4 :
        return buffer_add_char(buf, /* "+" */43);
    case /* Int_sd */2 :
    case /* Int_si */5 :
        return buffer_add_char(buf, /* " " */32);
    case /* Int_Cx */7 :
    case /* Int_CX */9 :
    case /* Int_Co */11 :
        return buffer_add_char(buf, /* "#" */35);
    case /* Int_d */0 :
    case /* Int_i */3 :
    case /* Int_x */6 :
    case /* Int_X */8 :
    case /* Int_o */10 :
    case /* Int_u */12 :
        return /* () */0;
    
  }
}

function bprint_int_fmt(buf, ign_flag, iconv, pad, prec) {
  buffer_add_char(buf, /* "%" */37);
  bprint_ignored_flag(buf, ign_flag);
  bprint_iconv_flag(buf, iconv);
  bprint_padding(buf, pad);
  bprint_precision(buf, prec);
  return buffer_add_char(buf, char_of_iconv(iconv));
}

function bprint_altint_fmt(buf, ign_flag, iconv, pad, prec, c) {
  buffer_add_char(buf, /* "%" */37);
  bprint_ignored_flag(buf, ign_flag);
  bprint_iconv_flag(buf, iconv);
  bprint_padding(buf, pad);
  bprint_precision(buf, prec);
  buffer_add_char(buf, c);
  return buffer_add_char(buf, char_of_iconv(iconv));
}

function bprint_fconv_flag(buf, fconv) {
  switch (fconv) {
    case /* Float_f */0 :
    case /* Float_e */3 :
    case /* Float_E */6 :
    case /* Float_g */9 :
    case /* Float_G */12 :
    case /* Float_F */15 :
    case /* Float_h */16 :
    case /* Float_H */19 :
        return /* () */0;
    case /* Float_pf */1 :
    case /* Float_pe */4 :
    case /* Float_pE */7 :
    case /* Float_pg */10 :
    case /* Float_pG */13 :
    case /* Float_ph */17 :
    case /* Float_pH */20 :
        return buffer_add_char(buf, /* "+" */43);
    case /* Float_sf */2 :
    case /* Float_se */5 :
    case /* Float_sE */8 :
    case /* Float_sg */11 :
    case /* Float_sG */14 :
    case /* Float_sh */18 :
    case /* Float_sH */21 :
        return buffer_add_char(buf, /* " " */32);
    
  }
}

function bprint_float_fmt(buf, ign_flag, fconv, pad, prec) {
  buffer_add_char(buf, /* "%" */37);
  bprint_ignored_flag(buf, ign_flag);
  bprint_fconv_flag(buf, fconv);
  bprint_padding(buf, pad);
  bprint_precision(buf, prec);
  return buffer_add_char(buf, char_of_fconv(fconv));
}

function string_of_formatting_lit(formatting_lit) {
  if (typeof formatting_lit === "number") {
    switch (formatting_lit) {
      case /* Close_box */0 :
          return "@]";
      case /* Close_tag */1 :
          return "@}";
      case /* FFlush */2 :
          return "@?";
      case /* Force_newline */3 :
          return "@\n";
      case /* Flush_newline */4 :
          return "@.";
      case /* Escaped_at */5 :
          return "@@";
      case /* Escaped_percent */6 :
          return "@%";
      
    }
  } else {
    switch (formatting_lit.tag | 0) {
      case /* Break */0 :
      case /* Magic_size */1 :
          return formatting_lit[0];
      case /* Scan_indic */2 :
          return "@" + caml_bytes.bytes_to_string(bytes.make(1, formatting_lit[0]));
      
    }
  }
}

function string_of_formatting_gen(formatting_gen) {
  return formatting_gen[0][1];
}

function bprint_char_literal(buf, chr) {
  if (chr !== 37) {
    return buffer_add_char(buf, chr);
  } else {
    return buffer_add_string(buf, "%%");
  }
}

function bprint_string_literal(buf, str) {
  for(var i = 0 ,i_finish = str.length - 1 | 0; i <= i_finish; ++i){
    bprint_char_literal(buf, caml_string.get(str, i));
  }
  return /* () */0;
}

function bprint_fmtty(buf, _fmtty) {
  while(true) {
    var fmtty = _fmtty;
    if (typeof fmtty === "number") {
      return /* () */0;
    } else {
      switch (fmtty.tag | 0) {
        case /* Char_ty */0 :
            buffer_add_string(buf, "%c");
            _fmtty = fmtty[0];
            continue ;
        case /* String_ty */1 :
            buffer_add_string(buf, "%s");
            _fmtty = fmtty[0];
            continue ;
        case /* Int_ty */2 :
            buffer_add_string(buf, "%i");
            _fmtty = fmtty[0];
            continue ;
        case /* Int32_ty */3 :
            buffer_add_string(buf, "%li");
            _fmtty = fmtty[0];
            continue ;
        case /* Nativeint_ty */4 :
            buffer_add_string(buf, "%ni");
            _fmtty = fmtty[0];
            continue ;
        case /* Int64_ty */5 :
            buffer_add_string(buf, "%Li");
            _fmtty = fmtty[0];
            continue ;
        case /* Float_ty */6 :
            buffer_add_string(buf, "%f");
            _fmtty = fmtty[0];
            continue ;
        case /* Bool_ty */7 :
            buffer_add_string(buf, "%B");
            _fmtty = fmtty[0];
            continue ;
        case /* Format_arg_ty */8 :
            buffer_add_string(buf, "%{");
            bprint_fmtty(buf, fmtty[0]);
            buffer_add_string(buf, "%}");
            _fmtty = fmtty[1];
            continue ;
        case /* Format_subst_ty */9 :
            buffer_add_string(buf, "%(");
            bprint_fmtty(buf, fmtty[0]);
            buffer_add_string(buf, "%)");
            _fmtty = fmtty[2];
            continue ;
        case /* Alpha_ty */10 :
            buffer_add_string(buf, "%a");
            _fmtty = fmtty[0];
            continue ;
        case /* Theta_ty */11 :
            buffer_add_string(buf, "%t");
            _fmtty = fmtty[0];
            continue ;
        case /* Any_ty */12 :
            buffer_add_string(buf, "%?");
            _fmtty = fmtty[0];
            continue ;
        case /* Reader_ty */13 :
            buffer_add_string(buf, "%r");
            _fmtty = fmtty[0];
            continue ;
        case /* Ignored_reader_ty */14 :
            buffer_add_string(buf, "%_r");
            _fmtty = fmtty[0];
            continue ;
        
      }
    }
  }}

function int_of_custom_arity(param) {
  if (param) {
    return 1 + int_of_custom_arity(param[0]) | 0;
  } else {
    return 0;
  }
}

function bprint_fmt(buf, fmt) {
  var _fmt = fmt;
  var _ign_flag = false;
  while(true) {
    var ign_flag = _ign_flag;
    var fmt$1 = _fmt;
    if (typeof fmt$1 === "number") {
      return /* () */0;
    } else {
      switch (fmt$1.tag | 0) {
        case /* Char */0 :
            buffer_add_char(buf, /* "%" */37);
            bprint_ignored_flag(buf, ign_flag);
            buffer_add_char(buf, /* "c" */99);
            _ign_flag = false;
            _fmt = fmt$1[0];
            continue ;
        case /* Caml_char */1 :
            buffer_add_char(buf, /* "%" */37);
            bprint_ignored_flag(buf, ign_flag);
            buffer_add_char(buf, /* "C" */67);
            _ign_flag = false;
            _fmt = fmt$1[0];
            continue ;
        case /* String */2 :
            buffer_add_char(buf, /* "%" */37);
            bprint_ignored_flag(buf, ign_flag);
            bprint_padding(buf, fmt$1[0]);
            buffer_add_char(buf, /* "s" */115);
            _ign_flag = false;
            _fmt = fmt$1[1];
            continue ;
        case /* Caml_string */3 :
            buffer_add_char(buf, /* "%" */37);
            bprint_ignored_flag(buf, ign_flag);
            bprint_padding(buf, fmt$1[0]);
            buffer_add_char(buf, /* "S" */83);
            _ign_flag = false;
            _fmt = fmt$1[1];
            continue ;
        case /* Int */4 :
            bprint_int_fmt(buf, ign_flag, fmt$1[0], fmt$1[1], fmt$1[2]);
            _ign_flag = false;
            _fmt = fmt$1[3];
            continue ;
        case /* Int32 */5 :
            bprint_altint_fmt(buf, ign_flag, fmt$1[0], fmt$1[1], fmt$1[2], /* "l" */108);
            _ign_flag = false;
            _fmt = fmt$1[3];
            continue ;
        case /* Nativeint */6 :
            bprint_altint_fmt(buf, ign_flag, fmt$1[0], fmt$1[1], fmt$1[2], /* "n" */110);
            _ign_flag = false;
            _fmt = fmt$1[3];
            continue ;
        case /* Int64 */7 :
            bprint_altint_fmt(buf, ign_flag, fmt$1[0], fmt$1[1], fmt$1[2], /* "L" */76);
            _ign_flag = false;
            _fmt = fmt$1[3];
            continue ;
        case /* Float */8 :
            bprint_float_fmt(buf, ign_flag, fmt$1[0], fmt$1[1], fmt$1[2]);
            _ign_flag = false;
            _fmt = fmt$1[3];
            continue ;
        case /* Bool */9 :
            buffer_add_char(buf, /* "%" */37);
            bprint_ignored_flag(buf, ign_flag);
            bprint_padding(buf, fmt$1[0]);
            buffer_add_char(buf, /* "B" */66);
            _ign_flag = false;
            _fmt = fmt$1[1];
            continue ;
        case /* Flush */10 :
            buffer_add_string(buf, "%!");
            _fmt = fmt$1[0];
            continue ;
        case /* String_literal */11 :
            bprint_string_literal(buf, fmt$1[0]);
            _fmt = fmt$1[1];
            continue ;
        case /* Char_literal */12 :
            bprint_char_literal(buf, fmt$1[0]);
            _fmt = fmt$1[1];
            continue ;
        case /* Format_arg */13 :
            buffer_add_char(buf, /* "%" */37);
            bprint_ignored_flag(buf, ign_flag);
            bprint_pad_opt(buf, fmt$1[0]);
            buffer_add_char(buf, /* "{" */123);
            bprint_fmtty(buf, fmt$1[1]);
            buffer_add_char(buf, /* "%" */37);
            buffer_add_char(buf, /* "}" */125);
            _ign_flag = false;
            _fmt = fmt$1[2];
            continue ;
        case /* Format_subst */14 :
            buffer_add_char(buf, /* "%" */37);
            bprint_ignored_flag(buf, ign_flag);
            bprint_pad_opt(buf, fmt$1[0]);
            buffer_add_char(buf, /* "(" */40);
            bprint_fmtty(buf, fmt$1[1]);
            buffer_add_char(buf, /* "%" */37);
            buffer_add_char(buf, /* ")" */41);
            _ign_flag = false;
            _fmt = fmt$1[2];
            continue ;
        case /* Alpha */15 :
            buffer_add_char(buf, /* "%" */37);
            bprint_ignored_flag(buf, ign_flag);
            buffer_add_char(buf, /* "a" */97);
            _ign_flag = false;
            _fmt = fmt$1[0];
            continue ;
        case /* Theta */16 :
            buffer_add_char(buf, /* "%" */37);
            bprint_ignored_flag(buf, ign_flag);
            buffer_add_char(buf, /* "t" */116);
            _ign_flag = false;
            _fmt = fmt$1[0];
            continue ;
        case /* Formatting_lit */17 :
            bprint_string_literal(buf, string_of_formatting_lit(fmt$1[0]));
            _fmt = fmt$1[1];
            continue ;
        case /* Formatting_gen */18 :
            bprint_string_literal(buf, "@{");
            bprint_string_literal(buf, string_of_formatting_gen(fmt$1[0]));
            _fmt = fmt$1[1];
            continue ;
        case /* Reader */19 :
            buffer_add_char(buf, /* "%" */37);
            bprint_ignored_flag(buf, ign_flag);
            buffer_add_char(buf, /* "r" */114);
            _ign_flag = false;
            _fmt = fmt$1[0];
            continue ;
        case /* Scan_char_set */20 :
            buffer_add_char(buf, /* "%" */37);
            bprint_ignored_flag(buf, ign_flag);
            bprint_pad_opt(buf, fmt$1[0]);
            bprint_char_set(buf, fmt$1[1]);
            _ign_flag = false;
            _fmt = fmt$1[2];
            continue ;
        case /* Scan_get_counter */21 :
            buffer_add_char(buf, /* "%" */37);
            bprint_ignored_flag(buf, ign_flag);
            buffer_add_char(buf, char_of_counter(fmt$1[0]));
            _ign_flag = false;
            _fmt = fmt$1[1];
            continue ;
        case /* Scan_next_char */22 :
            buffer_add_char(buf, /* "%" */37);
            bprint_ignored_flag(buf, ign_flag);
            bprint_string_literal(buf, "0c");
            _ign_flag = false;
            _fmt = fmt$1[0];
            continue ;
        case /* Ignored_param */23 :
            var match = param_format_of_ignored_format(fmt$1[0], fmt$1[1]);
            _ign_flag = true;
            _fmt = match[0];
            continue ;
        case /* Custom */24 :
            for(var _i = 1 ,_i_finish = int_of_custom_arity(fmt$1[0]); _i <= _i_finish; ++_i){
              buffer_add_char(buf, /* "%" */37);
              bprint_ignored_flag(buf, ign_flag);
              buffer_add_char(buf, /* "?" */63);
            }
            _ign_flag = false;
            _fmt = fmt$1[2];
            continue ;
        
      }
    }
  }}

function string_of_fmt(fmt) {
  var buf = {
    ind: 0,
    bytes: caml_bytes.caml_create_bytes(16)
  };
  bprint_fmt(buf, fmt);
  return buffer_contents(buf);
}

function symm(param) {
  if (typeof param === "number") {
    return /* End_of_fmtty */0;
  } else {
    switch (param.tag | 0) {
      case /* Char_ty */0 :
          return /* Char_ty */block.__(0, [symm(param[0])]);
      case /* String_ty */1 :
          return /* String_ty */block.__(1, [symm(param[0])]);
      case /* Int_ty */2 :
          return /* Int_ty */block.__(2, [symm(param[0])]);
      case /* Int32_ty */3 :
          return /* Int32_ty */block.__(3, [symm(param[0])]);
      case /* Nativeint_ty */4 :
          return /* Nativeint_ty */block.__(4, [symm(param[0])]);
      case /* Int64_ty */5 :
          return /* Int64_ty */block.__(5, [symm(param[0])]);
      case /* Float_ty */6 :
          return /* Float_ty */block.__(6, [symm(param[0])]);
      case /* Bool_ty */7 :
          return /* Bool_ty */block.__(7, [symm(param[0])]);
      case /* Format_arg_ty */8 :
          return /* Format_arg_ty */block.__(8, [
                    param[0],
                    symm(param[1])
                  ]);
      case /* Format_subst_ty */9 :
          return /* Format_subst_ty */block.__(9, [
                    param[1],
                    param[0],
                    symm(param[2])
                  ]);
      case /* Alpha_ty */10 :
          return /* Alpha_ty */block.__(10, [symm(param[0])]);
      case /* Theta_ty */11 :
          return /* Theta_ty */block.__(11, [symm(param[0])]);
      case /* Any_ty */12 :
          return /* Any_ty */block.__(12, [symm(param[0])]);
      case /* Reader_ty */13 :
          return /* Reader_ty */block.__(13, [symm(param[0])]);
      case /* Ignored_reader_ty */14 :
          return /* Ignored_reader_ty */block.__(14, [symm(param[0])]);
      
    }
  }
}

function fmtty_rel_det(param) {
  if (typeof param === "number") {
    return /* tuple */[
            (function (param) {
                return /* Refl */0;
              }),
            (function (param) {
                return /* Refl */0;
              }),
            (function (param) {
                return /* Refl */0;
              }),
            (function (param) {
                return /* Refl */0;
              })
          ];
  } else {
    switch (param.tag | 0) {
      case /* Char_ty */0 :
          var match = fmtty_rel_det(param[0]);
          var af = match[1];
          var fa = match[0];
          return /* tuple */[
                  (function (param) {
                      curry._1(fa, /* Refl */0);
                      return /* Refl */0;
                    }),
                  (function (param) {
                      curry._1(af, /* Refl */0);
                      return /* Refl */0;
                    }),
                  match[2],
                  match[3]
                ];
      case /* String_ty */1 :
          var match$1 = fmtty_rel_det(param[0]);
          var af$1 = match$1[1];
          var fa$1 = match$1[0];
          return /* tuple */[
                  (function (param) {
                      curry._1(fa$1, /* Refl */0);
                      return /* Refl */0;
                    }),
                  (function (param) {
                      curry._1(af$1, /* Refl */0);
                      return /* Refl */0;
                    }),
                  match$1[2],
                  match$1[3]
                ];
      case /* Int_ty */2 :
          var match$2 = fmtty_rel_det(param[0]);
          var af$2 = match$2[1];
          var fa$2 = match$2[0];
          return /* tuple */[
                  (function (param) {
                      curry._1(fa$2, /* Refl */0);
                      return /* Refl */0;
                    }),
                  (function (param) {
                      curry._1(af$2, /* Refl */0);
                      return /* Refl */0;
                    }),
                  match$2[2],
                  match$2[3]
                ];
      case /* Int32_ty */3 :
          var match$3 = fmtty_rel_det(param[0]);
          var af$3 = match$3[1];
          var fa$3 = match$3[0];
          return /* tuple */[
                  (function (param) {
                      curry._1(fa$3, /* Refl */0);
                      return /* Refl */0;
                    }),
                  (function (param) {
                      curry._1(af$3, /* Refl */0);
                      return /* Refl */0;
                    }),
                  match$3[2],
                  match$3[3]
                ];
      case /* Nativeint_ty */4 :
          var match$4 = fmtty_rel_det(param[0]);
          var af$4 = match$4[1];
          var fa$4 = match$4[0];
          return /* tuple */[
                  (function (param) {
                      curry._1(fa$4, /* Refl */0);
                      return /* Refl */0;
                    }),
                  (function (param) {
                      curry._1(af$4, /* Refl */0);
                      return /* Refl */0;
                    }),
                  match$4[2],
                  match$4[3]
                ];
      case /* Int64_ty */5 :
          var match$5 = fmtty_rel_det(param[0]);
          var af$5 = match$5[1];
          var fa$5 = match$5[0];
          return /* tuple */[
                  (function (param) {
                      curry._1(fa$5, /* Refl */0);
                      return /* Refl */0;
                    }),
                  (function (param) {
                      curry._1(af$5, /* Refl */0);
                      return /* Refl */0;
                    }),
                  match$5[2],
                  match$5[3]
                ];
      case /* Float_ty */6 :
          var match$6 = fmtty_rel_det(param[0]);
          var af$6 = match$6[1];
          var fa$6 = match$6[0];
          return /* tuple */[
                  (function (param) {
                      curry._1(fa$6, /* Refl */0);
                      return /* Refl */0;
                    }),
                  (function (param) {
                      curry._1(af$6, /* Refl */0);
                      return /* Refl */0;
                    }),
                  match$6[2],
                  match$6[3]
                ];
      case /* Bool_ty */7 :
          var match$7 = fmtty_rel_det(param[0]);
          var af$7 = match$7[1];
          var fa$7 = match$7[0];
          return /* tuple */[
                  (function (param) {
                      curry._1(fa$7, /* Refl */0);
                      return /* Refl */0;
                    }),
                  (function (param) {
                      curry._1(af$7, /* Refl */0);
                      return /* Refl */0;
                    }),
                  match$7[2],
                  match$7[3]
                ];
      case /* Format_arg_ty */8 :
          var match$8 = fmtty_rel_det(param[1]);
          var af$8 = match$8[1];
          var fa$8 = match$8[0];
          return /* tuple */[
                  (function (param) {
                      curry._1(fa$8, /* Refl */0);
                      return /* Refl */0;
                    }),
                  (function (param) {
                      curry._1(af$8, /* Refl */0);
                      return /* Refl */0;
                    }),
                  match$8[2],
                  match$8[3]
                ];
      case /* Format_subst_ty */9 :
          var match$9 = fmtty_rel_det(param[2]);
          var de = match$9[3];
          var ed = match$9[2];
          var af$9 = match$9[1];
          var fa$9 = match$9[0];
          var ty = trans(symm(param[0]), param[1]);
          var match$10 = fmtty_rel_det(ty);
          var jd = match$10[3];
          var dj = match$10[2];
          var ga = match$10[1];
          var ag = match$10[0];
          return /* tuple */[
                  (function (param) {
                      curry._1(fa$9, /* Refl */0);
                      curry._1(ag, /* Refl */0);
                      return /* Refl */0;
                    }),
                  (function (param) {
                      curry._1(ga, /* Refl */0);
                      curry._1(af$9, /* Refl */0);
                      return /* Refl */0;
                    }),
                  (function (param) {
                      curry._1(ed, /* Refl */0);
                      curry._1(dj, /* Refl */0);
                      return /* Refl */0;
                    }),
                  (function (param) {
                      curry._1(jd, /* Refl */0);
                      curry._1(de, /* Refl */0);
                      return /* Refl */0;
                    })
                ];
      case /* Alpha_ty */10 :
          var match$11 = fmtty_rel_det(param[0]);
          var af$10 = match$11[1];
          var fa$10 = match$11[0];
          return /* tuple */[
                  (function (param) {
                      curry._1(fa$10, /* Refl */0);
                      return /* Refl */0;
                    }),
                  (function (param) {
                      curry._1(af$10, /* Refl */0);
                      return /* Refl */0;
                    }),
                  match$11[2],
                  match$11[3]
                ];
      case /* Theta_ty */11 :
          var match$12 = fmtty_rel_det(param[0]);
          var af$11 = match$12[1];
          var fa$11 = match$12[0];
          return /* tuple */[
                  (function (param) {
                      curry._1(fa$11, /* Refl */0);
                      return /* Refl */0;
                    }),
                  (function (param) {
                      curry._1(af$11, /* Refl */0);
                      return /* Refl */0;
                    }),
                  match$12[2],
                  match$12[3]
                ];
      case /* Any_ty */12 :
          var match$13 = fmtty_rel_det(param[0]);
          var af$12 = match$13[1];
          var fa$12 = match$13[0];
          return /* tuple */[
                  (function (param) {
                      curry._1(fa$12, /* Refl */0);
                      return /* Refl */0;
                    }),
                  (function (param) {
                      curry._1(af$12, /* Refl */0);
                      return /* Refl */0;
                    }),
                  match$13[2],
                  match$13[3]
                ];
      case /* Reader_ty */13 :
          var match$14 = fmtty_rel_det(param[0]);
          var de$1 = match$14[3];
          var ed$1 = match$14[2];
          var af$13 = match$14[1];
          var fa$13 = match$14[0];
          return /* tuple */[
                  (function (param) {
                      curry._1(fa$13, /* Refl */0);
                      return /* Refl */0;
                    }),
                  (function (param) {
                      curry._1(af$13, /* Refl */0);
                      return /* Refl */0;
                    }),
                  (function (param) {
                      curry._1(ed$1, /* Refl */0);
                      return /* Refl */0;
                    }),
                  (function (param) {
                      curry._1(de$1, /* Refl */0);
                      return /* Refl */0;
                    })
                ];
      case /* Ignored_reader_ty */14 :
          var match$15 = fmtty_rel_det(param[0]);
          var de$2 = match$15[3];
          var ed$2 = match$15[2];
          var af$14 = match$15[1];
          var fa$14 = match$15[0];
          return /* tuple */[
                  (function (param) {
                      curry._1(fa$14, /* Refl */0);
                      return /* Refl */0;
                    }),
                  (function (param) {
                      curry._1(af$14, /* Refl */0);
                      return /* Refl */0;
                    }),
                  (function (param) {
                      curry._1(ed$2, /* Refl */0);
                      return /* Refl */0;
                    }),
                  (function (param) {
                      curry._1(de$2, /* Refl */0);
                      return /* Refl */0;
                    })
                ];
      
    }
  }
}

function trans(ty1, ty2) {
  var exit = 0;
  if (typeof ty1 === "number") {
    if (typeof ty2 === "number") {
      return /* End_of_fmtty */0;
    } else {
      switch (ty2.tag | 0) {
        case /* Format_arg_ty */8 :
            exit = 6;
            break;
        case /* Format_subst_ty */9 :
            exit = 7;
            break;
        case /* Alpha_ty */10 :
            exit = 1;
            break;
        case /* Theta_ty */11 :
            exit = 2;
            break;
        case /* Any_ty */12 :
            exit = 3;
            break;
        case /* Reader_ty */13 :
            exit = 4;
            break;
        case /* Ignored_reader_ty */14 :
            exit = 5;
            break;
        default:
          throw [
                caml_builtin_exceptions.assert_failure,
                /* tuple */[
                  "camlinternalFormat.ml",
                  846,
                  23
                ]
              ];
      }
    }
  } else {
    switch (ty1.tag | 0) {
      case /* Char_ty */0 :
          if (typeof ty2 === "number") {
            exit = 8;
          } else {
            switch (ty2.tag | 0) {
              case /* Char_ty */0 :
                  return /* Char_ty */block.__(0, [trans(ty1[0], ty2[0])]);
              case /* Format_arg_ty */8 :
                  exit = 6;
                  break;
              case /* Format_subst_ty */9 :
                  exit = 7;
                  break;
              case /* Alpha_ty */10 :
                  exit = 1;
                  break;
              case /* Theta_ty */11 :
                  exit = 2;
                  break;
              case /* Any_ty */12 :
                  exit = 3;
                  break;
              case /* Reader_ty */13 :
                  exit = 4;
                  break;
              case /* Ignored_reader_ty */14 :
                  exit = 5;
                  break;
              
            }
          }
          break;
      case /* String_ty */1 :
          if (typeof ty2 === "number") {
            exit = 8;
          } else {
            switch (ty2.tag | 0) {
              case /* String_ty */1 :
                  return /* String_ty */block.__(1, [trans(ty1[0], ty2[0])]);
              case /* Format_arg_ty */8 :
                  exit = 6;
                  break;
              case /* Format_subst_ty */9 :
                  exit = 7;
                  break;
              case /* Alpha_ty */10 :
                  exit = 1;
                  break;
              case /* Theta_ty */11 :
                  exit = 2;
                  break;
              case /* Any_ty */12 :
                  exit = 3;
                  break;
              case /* Reader_ty */13 :
                  exit = 4;
                  break;
              case /* Ignored_reader_ty */14 :
                  exit = 5;
                  break;
              
            }
          }
          break;
      case /* Int_ty */2 :
          if (typeof ty2 === "number") {
            exit = 8;
          } else {
            switch (ty2.tag | 0) {
              case /* Int_ty */2 :
                  return /* Int_ty */block.__(2, [trans(ty1[0], ty2[0])]);
              case /* Format_arg_ty */8 :
                  exit = 6;
                  break;
              case /* Format_subst_ty */9 :
                  exit = 7;
                  break;
              case /* Alpha_ty */10 :
                  exit = 1;
                  break;
              case /* Theta_ty */11 :
                  exit = 2;
                  break;
              case /* Any_ty */12 :
                  exit = 3;
                  break;
              case /* Reader_ty */13 :
                  exit = 4;
                  break;
              case /* Ignored_reader_ty */14 :
                  exit = 5;
                  break;
              
            }
          }
          break;
      case /* Int32_ty */3 :
          if (typeof ty2 === "number") {
            exit = 8;
          } else {
            switch (ty2.tag | 0) {
              case /* Int32_ty */3 :
                  return /* Int32_ty */block.__(3, [trans(ty1[0], ty2[0])]);
              case /* Format_arg_ty */8 :
                  exit = 6;
                  break;
              case /* Format_subst_ty */9 :
                  exit = 7;
                  break;
              case /* Alpha_ty */10 :
                  exit = 1;
                  break;
              case /* Theta_ty */11 :
                  exit = 2;
                  break;
              case /* Any_ty */12 :
                  exit = 3;
                  break;
              case /* Reader_ty */13 :
                  exit = 4;
                  break;
              case /* Ignored_reader_ty */14 :
                  exit = 5;
                  break;
              
            }
          }
          break;
      case /* Nativeint_ty */4 :
          if (typeof ty2 === "number") {
            exit = 8;
          } else {
            switch (ty2.tag | 0) {
              case /* Nativeint_ty */4 :
                  return /* Nativeint_ty */block.__(4, [trans(ty1[0], ty2[0])]);
              case /* Format_arg_ty */8 :
                  exit = 6;
                  break;
              case /* Format_subst_ty */9 :
                  exit = 7;
                  break;
              case /* Alpha_ty */10 :
                  exit = 1;
                  break;
              case /* Theta_ty */11 :
                  exit = 2;
                  break;
              case /* Any_ty */12 :
                  exit = 3;
                  break;
              case /* Reader_ty */13 :
                  exit = 4;
                  break;
              case /* Ignored_reader_ty */14 :
                  exit = 5;
                  break;
              
            }
          }
          break;
      case /* Int64_ty */5 :
          if (typeof ty2 === "number") {
            exit = 8;
          } else {
            switch (ty2.tag | 0) {
              case /* Int64_ty */5 :
                  return /* Int64_ty */block.__(5, [trans(ty1[0], ty2[0])]);
              case /* Format_arg_ty */8 :
                  exit = 6;
                  break;
              case /* Format_subst_ty */9 :
                  exit = 7;
                  break;
              case /* Alpha_ty */10 :
                  exit = 1;
                  break;
              case /* Theta_ty */11 :
                  exit = 2;
                  break;
              case /* Any_ty */12 :
                  exit = 3;
                  break;
              case /* Reader_ty */13 :
                  exit = 4;
                  break;
              case /* Ignored_reader_ty */14 :
                  exit = 5;
                  break;
              
            }
          }
          break;
      case /* Float_ty */6 :
          if (typeof ty2 === "number") {
            exit = 8;
          } else {
            switch (ty2.tag | 0) {
              case /* Float_ty */6 :
                  return /* Float_ty */block.__(6, [trans(ty1[0], ty2[0])]);
              case /* Format_arg_ty */8 :
                  exit = 6;
                  break;
              case /* Format_subst_ty */9 :
                  exit = 7;
                  break;
              case /* Alpha_ty */10 :
                  exit = 1;
                  break;
              case /* Theta_ty */11 :
                  exit = 2;
                  break;
              case /* Any_ty */12 :
                  exit = 3;
                  break;
              case /* Reader_ty */13 :
                  exit = 4;
                  break;
              case /* Ignored_reader_ty */14 :
                  exit = 5;
                  break;
              
            }
          }
          break;
      case /* Bool_ty */7 :
          if (typeof ty2 === "number") {
            exit = 8;
          } else {
            switch (ty2.tag | 0) {
              case /* Bool_ty */7 :
                  return /* Bool_ty */block.__(7, [trans(ty1[0], ty2[0])]);
              case /* Format_arg_ty */8 :
                  exit = 6;
                  break;
              case /* Format_subst_ty */9 :
                  exit = 7;
                  break;
              case /* Alpha_ty */10 :
                  exit = 1;
                  break;
              case /* Theta_ty */11 :
                  exit = 2;
                  break;
              case /* Any_ty */12 :
                  exit = 3;
                  break;
              case /* Reader_ty */13 :
                  exit = 4;
                  break;
              case /* Ignored_reader_ty */14 :
                  exit = 5;
                  break;
              
            }
          }
          break;
      case /* Format_arg_ty */8 :
          if (typeof ty2 === "number") {
            throw [
                  caml_builtin_exceptions.assert_failure,
                  /* tuple */[
                    "camlinternalFormat.ml",
                    832,
                    26
                  ]
                ];
          } else {
            switch (ty2.tag | 0) {
              case /* Format_arg_ty */8 :
                  return /* Format_arg_ty */block.__(8, [
                            trans(ty1[0], ty2[0]),
                            trans(ty1[1], ty2[1])
                          ]);
              case /* Alpha_ty */10 :
                  exit = 1;
                  break;
              case /* Theta_ty */11 :
                  exit = 2;
                  break;
              case /* Any_ty */12 :
                  exit = 3;
                  break;
              case /* Reader_ty */13 :
                  exit = 4;
                  break;
              case /* Ignored_reader_ty */14 :
                  exit = 5;
                  break;
              default:
                throw [
                      caml_builtin_exceptions.assert_failure,
                      /* tuple */[
                        "camlinternalFormat.ml",
                        832,
                        26
                      ]
                    ];
            }
          }
          break;
      case /* Format_subst_ty */9 :
          if (typeof ty2 === "number") {
            throw [
                  caml_builtin_exceptions.assert_failure,
                  /* tuple */[
                    "camlinternalFormat.ml",
                    842,
                    28
                  ]
                ];
          } else {
            switch (ty2.tag | 0) {
              case /* Format_arg_ty */8 :
                  exit = 6;
                  break;
              case /* Format_subst_ty */9 :
                  var ty = trans(symm(ty1[1]), ty2[0]);
                  var match = fmtty_rel_det(ty);
                  curry._1(match[1], /* Refl */0);
                  curry._1(match[3], /* Refl */0);
                  return /* Format_subst_ty */block.__(9, [
                            ty1[0],
                            ty2[1],
                            trans(ty1[2], ty2[2])
                          ]);
              case /* Alpha_ty */10 :
                  exit = 1;
                  break;
              case /* Theta_ty */11 :
                  exit = 2;
                  break;
              case /* Any_ty */12 :
                  exit = 3;
                  break;
              case /* Reader_ty */13 :
                  exit = 4;
                  break;
              case /* Ignored_reader_ty */14 :
                  exit = 5;
                  break;
              default:
                throw [
                      caml_builtin_exceptions.assert_failure,
                      /* tuple */[
                        "camlinternalFormat.ml",
                        842,
                        28
                      ]
                    ];
            }
          }
          break;
      case /* Alpha_ty */10 :
          if (typeof ty2 === "number") {
            throw [
                  caml_builtin_exceptions.assert_failure,
                  /* tuple */[
                    "camlinternalFormat.ml",
                    810,
                    21
                  ]
                ];
          } else if (ty2.tag === /* Alpha_ty */10) {
            return /* Alpha_ty */block.__(10, [trans(ty1[0], ty2[0])]);
          } else {
            throw [
                  caml_builtin_exceptions.assert_failure,
                  /* tuple */[
                    "camlinternalFormat.ml",
                    810,
                    21
                  ]
                ];
          }
      case /* Theta_ty */11 :
          if (typeof ty2 === "number") {
            throw [
                  caml_builtin_exceptions.assert_failure,
                  /* tuple */[
                    "camlinternalFormat.ml",
                    814,
                    21
                  ]
                ];
          } else {
            switch (ty2.tag | 0) {
              case /* Alpha_ty */10 :
                  exit = 1;
                  break;
              case /* Theta_ty */11 :
                  return /* Theta_ty */block.__(11, [trans(ty1[0], ty2[0])]);
              default:
                throw [
                      caml_builtin_exceptions.assert_failure,
                      /* tuple */[
                        "camlinternalFormat.ml",
                        814,
                        21
                      ]
                    ];
            }
          }
          break;
      case /* Any_ty */12 :
          if (typeof ty2 === "number") {
            throw [
                  caml_builtin_exceptions.assert_failure,
                  /* tuple */[
                    "camlinternalFormat.ml",
                    818,
                    19
                  ]
                ];
          } else {
            switch (ty2.tag | 0) {
              case /* Alpha_ty */10 :
                  exit = 1;
                  break;
              case /* Theta_ty */11 :
                  exit = 2;
                  break;
              case /* Any_ty */12 :
                  return /* Any_ty */block.__(12, [trans(ty1[0], ty2[0])]);
              default:
                throw [
                      caml_builtin_exceptions.assert_failure,
                      /* tuple */[
                        "camlinternalFormat.ml",
                        818,
                        19
                      ]
                    ];
            }
          }
          break;
      case /* Reader_ty */13 :
          if (typeof ty2 === "number") {
            throw [
                  caml_builtin_exceptions.assert_failure,
                  /* tuple */[
                    "camlinternalFormat.ml",
                    822,
                    22
                  ]
                ];
          } else {
            switch (ty2.tag | 0) {
              case /* Alpha_ty */10 :
                  exit = 1;
                  break;
              case /* Theta_ty */11 :
                  exit = 2;
                  break;
              case /* Any_ty */12 :
                  exit = 3;
                  break;
              case /* Reader_ty */13 :
                  return /* Reader_ty */block.__(13, [trans(ty1[0], ty2[0])]);
              default:
                throw [
                      caml_builtin_exceptions.assert_failure,
                      /* tuple */[
                        "camlinternalFormat.ml",
                        822,
                        22
                      ]
                    ];
            }
          }
          break;
      case /* Ignored_reader_ty */14 :
          if (typeof ty2 === "number") {
            throw [
                  caml_builtin_exceptions.assert_failure,
                  /* tuple */[
                    "camlinternalFormat.ml",
                    827,
                    30
                  ]
                ];
          } else {
            switch (ty2.tag | 0) {
              case /* Alpha_ty */10 :
                  exit = 1;
                  break;
              case /* Theta_ty */11 :
                  exit = 2;
                  break;
              case /* Any_ty */12 :
                  exit = 3;
                  break;
              case /* Reader_ty */13 :
                  exit = 4;
                  break;
              case /* Ignored_reader_ty */14 :
                  return /* Ignored_reader_ty */block.__(14, [trans(ty1[0], ty2[0])]);
              default:
                throw [
                      caml_builtin_exceptions.assert_failure,
                      /* tuple */[
                        "camlinternalFormat.ml",
                        827,
                        30
                      ]
                    ];
            }
          }
          break;
      
    }
  }
  switch (exit) {
    case 1 :
        throw [
              caml_builtin_exceptions.assert_failure,
              /* tuple */[
                "camlinternalFormat.ml",
                811,
                21
              ]
            ];
    case 2 :
        throw [
              caml_builtin_exceptions.assert_failure,
              /* tuple */[
                "camlinternalFormat.ml",
                815,
                21
              ]
            ];
    case 3 :
        throw [
              caml_builtin_exceptions.assert_failure,
              /* tuple */[
                "camlinternalFormat.ml",
                819,
                19
              ]
            ];
    case 4 :
        throw [
              caml_builtin_exceptions.assert_failure,
              /* tuple */[
                "camlinternalFormat.ml",
                823,
                22
              ]
            ];
    case 5 :
        throw [
              caml_builtin_exceptions.assert_failure,
              /* tuple */[
                "camlinternalFormat.ml",
                828,
                30
              ]
            ];
    case 6 :
        throw [
              caml_builtin_exceptions.assert_failure,
              /* tuple */[
                "camlinternalFormat.ml",
                833,
                26
              ]
            ];
    case 7 :
        throw [
              caml_builtin_exceptions.assert_failure,
              /* tuple */[
                "camlinternalFormat.ml",
                843,
                28
              ]
            ];
    case 8 :
        throw [
              caml_builtin_exceptions.assert_failure,
              /* tuple */[
                "camlinternalFormat.ml",
                847,
                23
              ]
            ];
    
  }
}

function fmtty_of_formatting_gen(formatting_gen) {
  return fmtty_of_fmt(formatting_gen[0][0]);
}

function fmtty_of_fmt(_fmtty) {
  while(true) {
    var fmtty = _fmtty;
    if (typeof fmtty === "number") {
      return /* End_of_fmtty */0;
    } else {
      switch (fmtty.tag | 0) {
        case /* String */2 :
        case /* Caml_string */3 :
            break;
        case /* Int */4 :
            var ty_rest = fmtty_of_fmt(fmtty[3]);
            var prec_ty = fmtty_of_precision_fmtty(fmtty[2], /* Int_ty */block.__(2, [ty_rest]));
            return fmtty_of_padding_fmtty(fmtty[1], prec_ty);
        case /* Int32 */5 :
            var ty_rest$1 = fmtty_of_fmt(fmtty[3]);
            var prec_ty$1 = fmtty_of_precision_fmtty(fmtty[2], /* Int32_ty */block.__(3, [ty_rest$1]));
            return fmtty_of_padding_fmtty(fmtty[1], prec_ty$1);
        case /* Nativeint */6 :
            var ty_rest$2 = fmtty_of_fmt(fmtty[3]);
            var prec_ty$2 = fmtty_of_precision_fmtty(fmtty[2], /* Nativeint_ty */block.__(4, [ty_rest$2]));
            return fmtty_of_padding_fmtty(fmtty[1], prec_ty$2);
        case /* Int64 */7 :
            var ty_rest$3 = fmtty_of_fmt(fmtty[3]);
            var prec_ty$3 = fmtty_of_precision_fmtty(fmtty[2], /* Int64_ty */block.__(5, [ty_rest$3]));
            return fmtty_of_padding_fmtty(fmtty[1], prec_ty$3);
        case /* Float */8 :
            var ty_rest$4 = fmtty_of_fmt(fmtty[3]);
            var prec_ty$4 = fmtty_of_precision_fmtty(fmtty[2], /* Float_ty */block.__(6, [ty_rest$4]));
            return fmtty_of_padding_fmtty(fmtty[1], prec_ty$4);
        case /* Bool */9 :
            return fmtty_of_padding_fmtty(fmtty[0], /* Bool_ty */block.__(7, [fmtty_of_fmt(fmtty[1])]));
        case /* Flush */10 :
            _fmtty = fmtty[0];
            continue ;
        case /* Format_arg */13 :
            return /* Format_arg_ty */block.__(8, [
                      fmtty[1],
                      fmtty_of_fmt(fmtty[2])
                    ]);
        case /* Format_subst */14 :
            var ty = fmtty[1];
            return /* Format_subst_ty */block.__(9, [
                      ty,
                      ty,
                      fmtty_of_fmt(fmtty[2])
                    ]);
        case /* Alpha */15 :
            return /* Alpha_ty */block.__(10, [fmtty_of_fmt(fmtty[0])]);
        case /* Theta */16 :
            return /* Theta_ty */block.__(11, [fmtty_of_fmt(fmtty[0])]);
        case /* String_literal */11 :
        case /* Char_literal */12 :
        case /* Formatting_lit */17 :
            _fmtty = fmtty[1];
            continue ;
        case /* Formatting_gen */18 :
            return camlinternalFormatBasics.concat_fmtty(fmtty_of_formatting_gen(fmtty[0]), fmtty_of_fmt(fmtty[1]));
        case /* Reader */19 :
            return /* Reader_ty */block.__(13, [fmtty_of_fmt(fmtty[0])]);
        case /* Scan_char_set */20 :
            return /* String_ty */block.__(1, [fmtty_of_fmt(fmtty[2])]);
        case /* Scan_get_counter */21 :
            return /* Int_ty */block.__(2, [fmtty_of_fmt(fmtty[1])]);
        case /* Ignored_param */23 :
            var ign = fmtty[0];
            var fmt = fmtty[1];
            if (typeof ign === "number") {
              if (ign === /* Ignored_reader */2) {
                return /* Ignored_reader_ty */block.__(14, [fmtty_of_fmt(fmt)]);
              } else {
                return fmtty_of_fmt(fmt);
              }
            } else if (ign.tag === /* Ignored_format_subst */9) {
              return camlinternalFormatBasics.concat_fmtty(ign[1], fmtty_of_fmt(fmt));
            } else {
              return fmtty_of_fmt(fmt);
            }
        case /* Custom */24 :
            return fmtty_of_custom(fmtty[0], fmtty_of_fmt(fmtty[2]));
        default:
          return /* Char_ty */block.__(0, [fmtty_of_fmt(fmtty[0])]);
      }
    }
    return fmtty_of_padding_fmtty(fmtty[0], /* String_ty */block.__(1, [fmtty_of_fmt(fmtty[1])]));
  }}

function fmtty_of_custom(arity, fmtty) {
  if (arity) {
    return /* Any_ty */block.__(12, [fmtty_of_custom(arity[0], fmtty)]);
  } else {
    return fmtty;
  }
}

function fmtty_of_padding_fmtty(pad, fmtty) {
  if (typeof pad === "number" || !pad.tag) {
    return fmtty;
  } else {
    return /* Int_ty */block.__(2, [fmtty]);
  }
}

function fmtty_of_precision_fmtty(prec, fmtty) {
  if (typeof prec === "number" && prec !== 0) {
    return /* Int_ty */block.__(2, [fmtty]);
  } else {
    return fmtty;
  }
}

var Type_mismatch = caml_exceptions.create("CamlinternalFormat.Type_mismatch");

function type_padding(pad, fmtty) {
  if (typeof pad === "number") {
    return /* Padding_fmtty_EBB */[
            /* No_padding */0,
            fmtty
          ];
  } else if (pad.tag) {
    if (typeof fmtty === "number") {
      throw Type_mismatch;
    } else if (fmtty.tag === /* Int_ty */2) {
      return /* Padding_fmtty_EBB */[
              /* Arg_padding */block.__(1, [pad[0]]),
              fmtty[0]
            ];
    } else {
      throw Type_mismatch;
    }
  } else {
    return /* Padding_fmtty_EBB */[
            /* Lit_padding */block.__(0, [
                pad[0],
                pad[1]
              ]),
            fmtty
          ];
  }
}

function type_padprec(pad, prec, fmtty) {
  var match = type_padding(pad, fmtty);
  if (typeof prec === "number") {
    if (prec !== 0) {
      var match$1 = match[1];
      if (typeof match$1 === "number") {
        throw Type_mismatch;
      } else if (match$1.tag === /* Int_ty */2) {
        return /* Padprec_fmtty_EBB */[
                match[0],
                /* Arg_precision */1,
                match$1[0]
              ];
      } else {
        throw Type_mismatch;
      }
    } else {
      return /* Padprec_fmtty_EBB */[
              match[0],
              /* No_precision */0,
              match[1]
            ];
    }
  } else {
    return /* Padprec_fmtty_EBB */[
            match[0],
            /* Lit_precision */[prec[0]],
            match[1]
          ];
  }
}

function type_ignored_format_substitution(sub_fmtty, fmt, fmtty) {
  if (typeof sub_fmtty === "number") {
    return /* Fmtty_fmt_EBB */[
            /* End_of_fmtty */0,
            type_format_gen(fmt, fmtty)
          ];
  } else {
    switch (sub_fmtty.tag | 0) {
      case /* Char_ty */0 :
          if (typeof fmtty === "number") {
            throw Type_mismatch;
          } else if (fmtty.tag) {
            throw Type_mismatch;
          } else {
            var match = type_ignored_format_substitution(sub_fmtty[0], fmt, fmtty[0]);
            return /* Fmtty_fmt_EBB */[
                    /* Char_ty */block.__(0, [match[0]]),
                    match[1]
                  ];
          }
      case /* String_ty */1 :
          if (typeof fmtty === "number") {
            throw Type_mismatch;
          } else if (fmtty.tag === /* String_ty */1) {
            var match$1 = type_ignored_format_substitution(sub_fmtty[0], fmt, fmtty[0]);
            return /* Fmtty_fmt_EBB */[
                    /* String_ty */block.__(1, [match$1[0]]),
                    match$1[1]
                  ];
          } else {
            throw Type_mismatch;
          }
      case /* Int_ty */2 :
          if (typeof fmtty === "number") {
            throw Type_mismatch;
          } else if (fmtty.tag === /* Int_ty */2) {
            var match$2 = type_ignored_format_substitution(sub_fmtty[0], fmt, fmtty[0]);
            return /* Fmtty_fmt_EBB */[
                    /* Int_ty */block.__(2, [match$2[0]]),
                    match$2[1]
                  ];
          } else {
            throw Type_mismatch;
          }
      case /* Int32_ty */3 :
          if (typeof fmtty === "number") {
            throw Type_mismatch;
          } else if (fmtty.tag === /* Int32_ty */3) {
            var match$3 = type_ignored_format_substitution(sub_fmtty[0], fmt, fmtty[0]);
            return /* Fmtty_fmt_EBB */[
                    /* Int32_ty */block.__(3, [match$3[0]]),
                    match$3[1]
                  ];
          } else {
            throw Type_mismatch;
          }
      case /* Nativeint_ty */4 :
          if (typeof fmtty === "number") {
            throw Type_mismatch;
          } else if (fmtty.tag === /* Nativeint_ty */4) {
            var match$4 = type_ignored_format_substitution(sub_fmtty[0], fmt, fmtty[0]);
            return /* Fmtty_fmt_EBB */[
                    /* Nativeint_ty */block.__(4, [match$4[0]]),
                    match$4[1]
                  ];
          } else {
            throw Type_mismatch;
          }
      case /* Int64_ty */5 :
          if (typeof fmtty === "number") {
            throw Type_mismatch;
          } else if (fmtty.tag === /* Int64_ty */5) {
            var match$5 = type_ignored_format_substitution(sub_fmtty[0], fmt, fmtty[0]);
            return /* Fmtty_fmt_EBB */[
                    /* Int64_ty */block.__(5, [match$5[0]]),
                    match$5[1]
                  ];
          } else {
            throw Type_mismatch;
          }
      case /* Float_ty */6 :
          if (typeof fmtty === "number") {
            throw Type_mismatch;
          } else if (fmtty.tag === /* Float_ty */6) {
            var match$6 = type_ignored_format_substitution(sub_fmtty[0], fmt, fmtty[0]);
            return /* Fmtty_fmt_EBB */[
                    /* Float_ty */block.__(6, [match$6[0]]),
                    match$6[1]
                  ];
          } else {
            throw Type_mismatch;
          }
      case /* Bool_ty */7 :
          if (typeof fmtty === "number") {
            throw Type_mismatch;
          } else if (fmtty.tag === /* Bool_ty */7) {
            var match$7 = type_ignored_format_substitution(sub_fmtty[0], fmt, fmtty[0]);
            return /* Fmtty_fmt_EBB */[
                    /* Bool_ty */block.__(7, [match$7[0]]),
                    match$7[1]
                  ];
          } else {
            throw Type_mismatch;
          }
      case /* Format_arg_ty */8 :
          if (typeof fmtty === "number") {
            throw Type_mismatch;
          } else if (fmtty.tag === /* Format_arg_ty */8) {
            var sub2_fmtty$prime = fmtty[0];
            if (caml_obj.caml_notequal(/* Fmtty_EBB */[sub_fmtty[0]], /* Fmtty_EBB */[sub2_fmtty$prime])) {
              throw Type_mismatch;
            }
            var match$8 = type_ignored_format_substitution(sub_fmtty[1], fmt, fmtty[1]);
            return /* Fmtty_fmt_EBB */[
                    /* Format_arg_ty */block.__(8, [
                        sub2_fmtty$prime,
                        match$8[0]
                      ]),
                    match$8[1]
                  ];
          } else {
            throw Type_mismatch;
          }
      case /* Format_subst_ty */9 :
          if (typeof fmtty === "number") {
            throw Type_mismatch;
          } else if (fmtty.tag === /* Format_subst_ty */9) {
            var sub2_fmtty$prime$1 = fmtty[1];
            var sub1_fmtty$prime = fmtty[0];
            if (caml_obj.caml_notequal(/* Fmtty_EBB */[camlinternalFormatBasics.erase_rel(sub_fmtty[0])], /* Fmtty_EBB */[camlinternalFormatBasics.erase_rel(sub1_fmtty$prime)])) {
              throw Type_mismatch;
            }
            if (caml_obj.caml_notequal(/* Fmtty_EBB */[camlinternalFormatBasics.erase_rel(sub_fmtty[1])], /* Fmtty_EBB */[camlinternalFormatBasics.erase_rel(sub2_fmtty$prime$1)])) {
              throw Type_mismatch;
            }
            var sub_fmtty$prime = trans(symm(sub1_fmtty$prime), sub2_fmtty$prime$1);
            var match$9 = fmtty_rel_det(sub_fmtty$prime);
            curry._1(match$9[1], /* Refl */0);
            curry._1(match$9[3], /* Refl */0);
            var match$10 = type_ignored_format_substitution(camlinternalFormatBasics.erase_rel(sub_fmtty[2]), fmt, fmtty[2]);
            return /* Fmtty_fmt_EBB */[
                    /* Format_subst_ty */block.__(9, [
                        sub1_fmtty$prime,
                        sub2_fmtty$prime$1,
                        symm(match$10[0])
                      ]),
                    match$10[1]
                  ];
          } else {
            throw Type_mismatch;
          }
      case /* Alpha_ty */10 :
          if (typeof fmtty === "number") {
            throw Type_mismatch;
          } else if (fmtty.tag === /* Alpha_ty */10) {
            var match$11 = type_ignored_format_substitution(sub_fmtty[0], fmt, fmtty[0]);
            return /* Fmtty_fmt_EBB */[
                    /* Alpha_ty */block.__(10, [match$11[0]]),
                    match$11[1]
                  ];
          } else {
            throw Type_mismatch;
          }
      case /* Theta_ty */11 :
          if (typeof fmtty === "number") {
            throw Type_mismatch;
          } else if (fmtty.tag === /* Theta_ty */11) {
            var match$12 = type_ignored_format_substitution(sub_fmtty[0], fmt, fmtty[0]);
            return /* Fmtty_fmt_EBB */[
                    /* Theta_ty */block.__(11, [match$12[0]]),
                    match$12[1]
                  ];
          } else {
            throw Type_mismatch;
          }
      case /* Any_ty */12 :
          throw Type_mismatch;
      case /* Reader_ty */13 :
          if (typeof fmtty === "number") {
            throw Type_mismatch;
          } else if (fmtty.tag === /* Reader_ty */13) {
            var match$13 = type_ignored_format_substitution(sub_fmtty[0], fmt, fmtty[0]);
            return /* Fmtty_fmt_EBB */[
                    /* Reader_ty */block.__(13, [match$13[0]]),
                    match$13[1]
                  ];
          } else {
            throw Type_mismatch;
          }
      case /* Ignored_reader_ty */14 :
          if (typeof fmtty === "number") {
            throw Type_mismatch;
          } else if (fmtty.tag === /* Ignored_reader_ty */14) {
            var match$14 = type_ignored_format_substitution(sub_fmtty[0], fmt, fmtty[0]);
            return /* Fmtty_fmt_EBB */[
                    /* Ignored_reader_ty */block.__(14, [match$14[0]]),
                    match$14[1]
                  ];
          } else {
            throw Type_mismatch;
          }
      
    }
  }
}

function type_format_gen(fmt, fmtty) {
  if (typeof fmt === "number") {
    return /* Fmt_fmtty_EBB */[
            /* End_of_format */0,
            fmtty
          ];
  } else {
    switch (fmt.tag | 0) {
      case /* Char */0 :
          if (typeof fmtty === "number") {
            throw Type_mismatch;
          } else if (fmtty.tag) {
            throw Type_mismatch;
          } else {
            var match = type_format_gen(fmt[0], fmtty[0]);
            return /* Fmt_fmtty_EBB */[
                    /* Char */block.__(0, [match[0]]),
                    match[1]
                  ];
          }
      case /* Caml_char */1 :
          if (typeof fmtty === "number") {
            throw Type_mismatch;
          } else if (fmtty.tag) {
            throw Type_mismatch;
          } else {
            var match$1 = type_format_gen(fmt[0], fmtty[0]);
            return /* Fmt_fmtty_EBB */[
                    /* Caml_char */block.__(1, [match$1[0]]),
                    match$1[1]
                  ];
          }
      case /* String */2 :
          var match$2 = type_padding(fmt[0], fmtty);
          var match$3 = match$2[1];
          if (typeof match$3 === "number") {
            throw Type_mismatch;
          } else if (match$3.tag === /* String_ty */1) {
            var match$4 = type_format_gen(fmt[1], match$3[0]);
            return /* Fmt_fmtty_EBB */[
                    /* String */block.__(2, [
                        match$2[0],
                        match$4[0]
                      ]),
                    match$4[1]
                  ];
          } else {
            throw Type_mismatch;
          }
      case /* Caml_string */3 :
          var match$5 = type_padding(fmt[0], fmtty);
          var match$6 = match$5[1];
          if (typeof match$6 === "number") {
            throw Type_mismatch;
          } else if (match$6.tag === /* String_ty */1) {
            var match$7 = type_format_gen(fmt[1], match$6[0]);
            return /* Fmt_fmtty_EBB */[
                    /* Caml_string */block.__(3, [
                        match$5[0],
                        match$7[0]
                      ]),
                    match$7[1]
                  ];
          } else {
            throw Type_mismatch;
          }
      case /* Int */4 :
          var match$8 = type_padprec(fmt[1], fmt[2], fmtty);
          var match$9 = match$8[2];
          if (typeof match$9 === "number") {
            throw Type_mismatch;
          } else if (match$9.tag === /* Int_ty */2) {
            var match$10 = type_format_gen(fmt[3], match$9[0]);
            return /* Fmt_fmtty_EBB */[
                    /* Int */block.__(4, [
                        fmt[0],
                        match$8[0],
                        match$8[1],
                        match$10[0]
                      ]),
                    match$10[1]
                  ];
          } else {
            throw Type_mismatch;
          }
      case /* Int32 */5 :
          var match$11 = type_padprec(fmt[1], fmt[2], fmtty);
          var match$12 = match$11[2];
          if (typeof match$12 === "number") {
            throw Type_mismatch;
          } else if (match$12.tag === /* Int32_ty */3) {
            var match$13 = type_format_gen(fmt[3], match$12[0]);
            return /* Fmt_fmtty_EBB */[
                    /* Int32 */block.__(5, [
                        fmt[0],
                        match$11[0],
                        match$11[1],
                        match$13[0]
                      ]),
                    match$13[1]
                  ];
          } else {
            throw Type_mismatch;
          }
      case /* Nativeint */6 :
          var match$14 = type_padprec(fmt[1], fmt[2], fmtty);
          var match$15 = match$14[2];
          if (typeof match$15 === "number") {
            throw Type_mismatch;
          } else if (match$15.tag === /* Nativeint_ty */4) {
            var match$16 = type_format_gen(fmt[3], match$15[0]);
            return /* Fmt_fmtty_EBB */[
                    /* Nativeint */block.__(6, [
                        fmt[0],
                        match$14[0],
                        match$14[1],
                        match$16[0]
                      ]),
                    match$16[1]
                  ];
          } else {
            throw Type_mismatch;
          }
      case /* Int64 */7 :
          var match$17 = type_padprec(fmt[1], fmt[2], fmtty);
          var match$18 = match$17[2];
          if (typeof match$18 === "number") {
            throw Type_mismatch;
          } else if (match$18.tag === /* Int64_ty */5) {
            var match$19 = type_format_gen(fmt[3], match$18[0]);
            return /* Fmt_fmtty_EBB */[
                    /* Int64 */block.__(7, [
                        fmt[0],
                        match$17[0],
                        match$17[1],
                        match$19[0]
                      ]),
                    match$19[1]
                  ];
          } else {
            throw Type_mismatch;
          }
      case /* Float */8 :
          var match$20 = type_padprec(fmt[1], fmt[2], fmtty);
          var match$21 = match$20[2];
          if (typeof match$21 === "number") {
            throw Type_mismatch;
          } else if (match$21.tag === /* Float_ty */6) {
            var match$22 = type_format_gen(fmt[3], match$21[0]);
            return /* Fmt_fmtty_EBB */[
                    /* Float */block.__(8, [
                        fmt[0],
                        match$20[0],
                        match$20[1],
                        match$22[0]
                      ]),
                    match$22[1]
                  ];
          } else {
            throw Type_mismatch;
          }
      case /* Bool */9 :
          var match$23 = type_padding(fmt[0], fmtty);
          var match$24 = match$23[1];
          if (typeof match$24 === "number") {
            throw Type_mismatch;
          } else if (match$24.tag === /* Bool_ty */7) {
            var match$25 = type_format_gen(fmt[1], match$24[0]);
            return /* Fmt_fmtty_EBB */[
                    /* Bool */block.__(9, [
                        match$23[0],
                        match$25[0]
                      ]),
                    match$25[1]
                  ];
          } else {
            throw Type_mismatch;
          }
      case /* Flush */10 :
          var match$26 = type_format_gen(fmt[0], fmtty);
          return /* Fmt_fmtty_EBB */[
                  /* Flush */block.__(10, [match$26[0]]),
                  match$26[1]
                ];
      case /* String_literal */11 :
          var match$27 = type_format_gen(fmt[1], fmtty);
          return /* Fmt_fmtty_EBB */[
                  /* String_literal */block.__(11, [
                      fmt[0],
                      match$27[0]
                    ]),
                  match$27[1]
                ];
      case /* Char_literal */12 :
          var match$28 = type_format_gen(fmt[1], fmtty);
          return /* Fmt_fmtty_EBB */[
                  /* Char_literal */block.__(12, [
                      fmt[0],
                      match$28[0]
                    ]),
                  match$28[1]
                ];
      case /* Format_arg */13 :
          if (typeof fmtty === "number") {
            throw Type_mismatch;
          } else if (fmtty.tag === /* Format_arg_ty */8) {
            var sub_fmtty$prime = fmtty[0];
            if (caml_obj.caml_notequal(/* Fmtty_EBB */[fmt[1]], /* Fmtty_EBB */[sub_fmtty$prime])) {
              throw Type_mismatch;
            }
            var match$29 = type_format_gen(fmt[2], fmtty[1]);
            return /* Fmt_fmtty_EBB */[
                    /* Format_arg */block.__(13, [
                        fmt[0],
                        sub_fmtty$prime,
                        match$29[0]
                      ]),
                    match$29[1]
                  ];
          } else {
            throw Type_mismatch;
          }
      case /* Format_subst */14 :
          if (typeof fmtty === "number") {
            throw Type_mismatch;
          } else if (fmtty.tag === /* Format_subst_ty */9) {
            var sub_fmtty1 = fmtty[0];
            if (caml_obj.caml_notequal(/* Fmtty_EBB */[camlinternalFormatBasics.erase_rel(fmt[1])], /* Fmtty_EBB */[camlinternalFormatBasics.erase_rel(sub_fmtty1)])) {
              throw Type_mismatch;
            }
            var match$30 = type_format_gen(fmt[2], camlinternalFormatBasics.erase_rel(fmtty[2]));
            return /* Fmt_fmtty_EBB */[
                    /* Format_subst */block.__(14, [
                        fmt[0],
                        sub_fmtty1,
                        match$30[0]
                      ]),
                    match$30[1]
                  ];
          } else {
            throw Type_mismatch;
          }
      case /* Alpha */15 :
          if (typeof fmtty === "number") {
            throw Type_mismatch;
          } else if (fmtty.tag === /* Alpha_ty */10) {
            var match$31 = type_format_gen(fmt[0], fmtty[0]);
            return /* Fmt_fmtty_EBB */[
                    /* Alpha */block.__(15, [match$31[0]]),
                    match$31[1]
                  ];
          } else {
            throw Type_mismatch;
          }
      case /* Theta */16 :
          if (typeof fmtty === "number") {
            throw Type_mismatch;
          } else if (fmtty.tag === /* Theta_ty */11) {
            var match$32 = type_format_gen(fmt[0], fmtty[0]);
            return /* Fmt_fmtty_EBB */[
                    /* Theta */block.__(16, [match$32[0]]),
                    match$32[1]
                  ];
          } else {
            throw Type_mismatch;
          }
      case /* Formatting_lit */17 :
          var match$33 = type_format_gen(fmt[1], fmtty);
          return /* Fmt_fmtty_EBB */[
                  /* Formatting_lit */block.__(17, [
                      fmt[0],
                      match$33[0]
                    ]),
                  match$33[1]
                ];
      case /* Formatting_gen */18 :
          var formatting_gen = fmt[0];
          var fmt0 = fmt[1];
          var fmtty0 = fmtty;
          if (formatting_gen.tag) {
            var match$34 = formatting_gen[0];
            var match$35 = type_format_gen(match$34[0], fmtty0);
            var match$36 = type_format_gen(fmt0, match$35[1]);
            return /* Fmt_fmtty_EBB */[
                    /* Formatting_gen */block.__(18, [
                        /* Open_box */block.__(1, [/* Format */[
                              match$35[0],
                              match$34[1]
                            ]]),
                        match$36[0]
                      ]),
                    match$36[1]
                  ];
          } else {
            var match$37 = formatting_gen[0];
            var match$38 = type_format_gen(match$37[0], fmtty0);
            var match$39 = type_format_gen(fmt0, match$38[1]);
            return /* Fmt_fmtty_EBB */[
                    /* Formatting_gen */block.__(18, [
                        /* Open_tag */block.__(0, [/* Format */[
                              match$38[0],
                              match$37[1]
                            ]]),
                        match$39[0]
                      ]),
                    match$39[1]
                  ];
          }
      case /* Reader */19 :
          if (typeof fmtty === "number") {
            throw Type_mismatch;
          } else if (fmtty.tag === /* Reader_ty */13) {
            var match$40 = type_format_gen(fmt[0], fmtty[0]);
            return /* Fmt_fmtty_EBB */[
                    /* Reader */block.__(19, [match$40[0]]),
                    match$40[1]
                  ];
          } else {
            throw Type_mismatch;
          }
      case /* Scan_char_set */20 :
          if (typeof fmtty === "number") {
            throw Type_mismatch;
          } else if (fmtty.tag === /* String_ty */1) {
            var match$41 = type_format_gen(fmt[2], fmtty[0]);
            return /* Fmt_fmtty_EBB */[
                    /* Scan_char_set */block.__(20, [
                        fmt[0],
                        fmt[1],
                        match$41[0]
                      ]),
                    match$41[1]
                  ];
          } else {
            throw Type_mismatch;
          }
      case /* Scan_get_counter */21 :
          if (typeof fmtty === "number") {
            throw Type_mismatch;
          } else if (fmtty.tag === /* Int_ty */2) {
            var match$42 = type_format_gen(fmt[1], fmtty[0]);
            return /* Fmt_fmtty_EBB */[
                    /* Scan_get_counter */block.__(21, [
                        fmt[0],
                        match$42[0]
                      ]),
                    match$42[1]
                  ];
          } else {
            throw Type_mismatch;
          }
      case /* Ignored_param */23 :
          var ign = fmt[0];
          var fmt$1 = fmt[1];
          var fmtty$1 = fmtty;
          if (typeof ign === "number") {
            if (ign === /* Ignored_reader */2) {
              if (typeof fmtty$1 === "number") {
                throw Type_mismatch;
              } else if (fmtty$1.tag === /* Ignored_reader_ty */14) {
                var match$43 = type_format_gen(fmt$1, fmtty$1[0]);
                return /* Fmt_fmtty_EBB */[
                        /* Ignored_param */block.__(23, [
                            /* Ignored_reader */2,
                            match$43[0]
                          ]),
                        match$43[1]
                      ];
              } else {
                throw Type_mismatch;
              }
            } else {
              return type_ignored_param_one(ign, fmt$1, fmtty$1);
            }
          } else {
            switch (ign.tag | 0) {
              case /* Ignored_format_arg */8 :
                  return type_ignored_param_one(/* Ignored_format_arg */block.__(8, [
                                ign[0],
                                ign[1]
                              ]), fmt$1, fmtty$1);
              case /* Ignored_format_subst */9 :
                  var match$44 = type_ignored_format_substitution(ign[1], fmt$1, fmtty$1);
                  var match$45 = match$44[1];
                  return /* Fmt_fmtty_EBB */[
                          /* Ignored_param */block.__(23, [
                              /* Ignored_format_subst */block.__(9, [
                                  ign[0],
                                  match$44[0]
                                ]),
                              match$45[0]
                            ]),
                          match$45[1]
                        ];
              default:
                return type_ignored_param_one(ign, fmt$1, fmtty$1);
            }
          }
      case /* Scan_next_char */22 :
      case /* Custom */24 :
          throw Type_mismatch;
      
    }
  }
}

function type_ignored_param_one(ign, fmt, fmtty) {
  var match = type_format_gen(fmt, fmtty);
  return /* Fmt_fmtty_EBB */[
          /* Ignored_param */block.__(23, [
              ign,
              match[0]
            ]),
          match[1]
        ];
}

function type_format(fmt, fmtty) {
  var match = type_format_gen(fmt, fmtty);
  if (typeof match[1] === "number") {
    return match[0];
  } else {
    throw Type_mismatch;
  }
}

function recast(fmt, fmtty) {
  return type_format(fmt, camlinternalFormatBasics.erase_rel(symm(fmtty)));
}

function fix_padding(padty, width, str) {
  var len = str.length;
  var width$1 = pervasives.abs(width);
  var padty$1 = width < 0 ? /* Left */0 : padty;
  if (width$1 <= len) {
    return str;
  } else {
    var res = bytes.make(width$1, padty$1 === /* Zeros */2 ? /* "0" */48 : /* " " */32);
    switch (padty$1) {
      case /* Left */0 :
          string.blit(str, 0, res, 0, len);
          break;
      case /* Right */1 :
          string.blit(str, 0, res, width$1 - len | 0, len);
          break;
      case /* Zeros */2 :
          if (len > 0 && (caml_string.get(str, 0) === /* "+" */43 || caml_string.get(str, 0) === /* "-" */45 || caml_string.get(str, 0) === /* " " */32)) {
            res[0] = caml_string.get(str, 0);
            string.blit(str, 1, res, (width$1 - len | 0) + 1 | 0, len - 1 | 0);
          } else if (len > 1 && caml_string.get(str, 0) === /* "0" */48 && (caml_string.get(str, 1) === /* "x" */120 || caml_string.get(str, 1) === /* "X" */88)) {
            res[1] = caml_string.get(str, 1);
            string.blit(str, 2, res, (width$1 - len | 0) + 2 | 0, len - 2 | 0);
          } else {
            string.blit(str, 0, res, width$1 - len | 0, len);
          }
          break;
      
    }
    return caml_bytes.bytes_to_string(res);
  }
}

function fix_int_precision(prec, str) {
  var prec$1 = pervasives.abs(prec);
  var len = str.length;
  var c = caml_string.get(str, 0);
  var exit = 0;
  if (c >= 58) {
    if (c >= 71) {
      if (c > 102 || c < 97) {
        return str;
      } else {
        exit = 2;
      }
    } else if (c >= 65) {
      exit = 2;
    } else {
      return str;
    }
  } else if (c !== 32) {
    if (c >= 43) {
      switch (c - 43 | 0) {
        case 0 :
        case 2 :
            exit = 1;
            break;
        case 1 :
        case 3 :
        case 4 :
            return str;
        case 5 :
            if ((prec$1 + 2 | 0) > len && len > 1 && (caml_string.get(str, 1) === /* "x" */120 || caml_string.get(str, 1) === /* "X" */88)) {
              var res = bytes.make(prec$1 + 2 | 0, /* "0" */48);
              res[1] = caml_string.get(str, 1);
              string.blit(str, 2, res, (prec$1 - len | 0) + 4 | 0, len - 2 | 0);
              return caml_bytes.bytes_to_string(res);
            } else {
              exit = 2;
            }
            break;
        case 6 :
        case 7 :
        case 8 :
        case 9 :
        case 10 :
        case 11 :
        case 12 :
        case 13 :
        case 14 :
            exit = 2;
            break;
        
      }
    } else {
      return str;
    }
  } else {
    exit = 1;
  }
  switch (exit) {
    case 1 :
        if ((prec$1 + 1 | 0) > len) {
          var res$1 = bytes.make(prec$1 + 1 | 0, /* "0" */48);
          res$1[0] = c;
          string.blit(str, 1, res$1, (prec$1 - len | 0) + 2 | 0, len - 1 | 0);
          return caml_bytes.bytes_to_string(res$1);
        } else {
          return str;
        }
    case 2 :
        if (prec$1 > len) {
          var res$2 = bytes.make(prec$1, /* "0" */48);
          string.blit(str, 0, res$2, prec$1 - len | 0, len);
          return caml_bytes.bytes_to_string(res$2);
        } else {
          return str;
        }
    
  }
}

function string_to_caml_string(str) {
  var str$1 = string.escaped(str);
  var l = str$1.length;
  var res = bytes.make(l + 2 | 0, /* "\"" */34);
  caml_bytes.caml_blit_string(str$1, 0, res, 1, l);
  return caml_bytes.bytes_to_string(res);
}

function format_of_iconv(param) {
  switch (param) {
    case /* Int_d */0 :
        return "%d";
    case /* Int_pd */1 :
        return "%+d";
    case /* Int_sd */2 :
        return "% d";
    case /* Int_i */3 :
        return "%i";
    case /* Int_pi */4 :
        return "%+i";
    case /* Int_si */5 :
        return "% i";
    case /* Int_x */6 :
        return "%x";
    case /* Int_Cx */7 :
        return "%#x";
    case /* Int_X */8 :
        return "%X";
    case /* Int_CX */9 :
        return "%#X";
    case /* Int_o */10 :
        return "%o";
    case /* Int_Co */11 :
        return "%#o";
    case /* Int_u */12 :
        return "%u";
    
  }
}

function format_of_iconvL(param) {
  switch (param) {
    case /* Int_d */0 :
        return "%Ld";
    case /* Int_pd */1 :
        return "%+Ld";
    case /* Int_sd */2 :
        return "% Ld";
    case /* Int_i */3 :
        return "%Li";
    case /* Int_pi */4 :
        return "%+Li";
    case /* Int_si */5 :
        return "% Li";
    case /* Int_x */6 :
        return "%Lx";
    case /* Int_Cx */7 :
        return "%#Lx";
    case /* Int_X */8 :
        return "%LX";
    case /* Int_CX */9 :
        return "%#LX";
    case /* Int_o */10 :
        return "%Lo";
    case /* Int_Co */11 :
        return "%#Lo";
    case /* Int_u */12 :
        return "%Lu";
    
  }
}

function format_of_iconvl(param) {
  switch (param) {
    case /* Int_d */0 :
        return "%ld";
    case /* Int_pd */1 :
        return "%+ld";
    case /* Int_sd */2 :
        return "% ld";
    case /* Int_i */3 :
        return "%li";
    case /* Int_pi */4 :
        return "%+li";
    case /* Int_si */5 :
        return "% li";
    case /* Int_x */6 :
        return "%lx";
    case /* Int_Cx */7 :
        return "%#lx";
    case /* Int_X */8 :
        return "%lX";
    case /* Int_CX */9 :
        return "%#lX";
    case /* Int_o */10 :
        return "%lo";
    case /* Int_Co */11 :
        return "%#lo";
    case /* Int_u */12 :
        return "%lu";
    
  }
}

function format_of_iconvn(param) {
  switch (param) {
    case /* Int_d */0 :
        return "%nd";
    case /* Int_pd */1 :
        return "%+nd";
    case /* Int_sd */2 :
        return "% nd";
    case /* Int_i */3 :
        return "%ni";
    case /* Int_pi */4 :
        return "%+ni";
    case /* Int_si */5 :
        return "% ni";
    case /* Int_x */6 :
        return "%nx";
    case /* Int_Cx */7 :
        return "%#nx";
    case /* Int_X */8 :
        return "%nX";
    case /* Int_CX */9 :
        return "%#nX";
    case /* Int_o */10 :
        return "%no";
    case /* Int_Co */11 :
        return "%#no";
    case /* Int_u */12 :
        return "%nu";
    
  }
}

function format_of_fconv(fconv, prec) {
  if (fconv === /* Float_F */15) {
    return "%.12g";
  } else {
    var prec$1 = pervasives.abs(prec);
    var symb = char_of_fconv(fconv);
    var buf = {
      ind: 0,
      bytes: caml_bytes.caml_create_bytes(16)
    };
    buffer_add_char(buf, /* "%" */37);
    bprint_fconv_flag(buf, fconv);
    buffer_add_char(buf, /* "." */46);
    buffer_add_string(buf, String(prec$1));
    buffer_add_char(buf, symb);
    return buffer_contents(buf);
  }
}

function convert_int(iconv, n) {
  return caml_format.caml_format_int(format_of_iconv(iconv), n);
}

function convert_int32(iconv, n) {
  return caml_format.caml_int32_format(format_of_iconvl(iconv), n);
}

function convert_nativeint(iconv, n) {
  return caml_format.caml_nativeint_format(format_of_iconvn(iconv), n);
}

function convert_int64(iconv, n) {
  return caml_format.caml_int64_format(format_of_iconvL(iconv), n);
}

function convert_float(fconv, prec, x) {
  if (fconv >= 16) {
    var sign;
    if (fconv >= 17) {
      switch (fconv - 17 | 0) {
        case /* Float_sf */2 :
            sign = /* "-" */45;
            break;
        case /* Float_f */0 :
        case /* Float_e */3 :
            sign = /* "+" */43;
            break;
        case /* Float_pf */1 :
        case /* Float_pe */4 :
            sign = /* " " */32;
            break;
        
      }
    } else {
      sign = /* "-" */45;
    }
    var str = caml_format.caml_hexstring_of_float(x, prec, sign);
    if (fconv >= 19) {
      return caml_bytes.bytes_to_string(bytes.uppercase_ascii(caml_bytes.bytes_of_string(str)));
    } else {
      return str;
    }
  } else {
    var str$1 = caml_format.caml_format_float(format_of_fconv(fconv, prec), x);
    if (fconv !== /* Float_F */15) {
      return str$1;
    } else {
      var len = str$1.length;
      var is_valid = function (_i) {
        while(true) {
          var i = _i;
          if (i === len) {
            return false;
          } else {
            var match = caml_string.get(str$1, i);
            var switcher = match - 46 | 0;
            if (switcher > 23 || switcher < 0) {
              if (switcher !== 55) {
                _i = i + 1 | 0;
                continue ;
              } else {
                return true;
              }
            } else if (switcher > 22 || switcher < 1) {
              return true;
            } else {
              _i = i + 1 | 0;
              continue ;
            }
          }
        }      };
      var match = pervasives.classify_float(x);
      if (match !== 3) {
        if (match >= 4) {
          return "nan";
        } else if (is_valid(0)) {
          return str$1;
        } else {
          return str$1 + ".";
        }
      } else if (x < 0.0) {
        return "neg_infinity";
      } else {
        return "infinity";
      }
    }
  }
}

function format_caml_char(c) {
  var str = char_1.escaped(c);
  var l = str.length;
  var res = bytes.make(l + 2 | 0, /* "'" */39);
  caml_bytes.caml_blit_string(str, 0, res, 1, l);
  return caml_bytes.bytes_to_string(res);
}

function string_of_fmtty(fmtty) {
  var buf = {
    ind: 0,
    bytes: caml_bytes.caml_create_bytes(16)
  };
  bprint_fmtty(buf, fmtty);
  return buffer_contents(buf);
}

function make_printf(_k, o, _acc, _fmt) {
  while(true) {
    var fmt = _fmt;
    var acc = _acc;
    var k = _k;
    if (typeof fmt === "number") {
      return curry._2(k, o, acc);
    } else {
      switch (fmt.tag | 0) {
        case /* Char */0 :
            var rest = fmt[0];
            return (function(k,acc,rest){
            return function (c) {
              var new_acc = /* Acc_data_char */block.__(5, [
                  acc,
                  c
                ]);
              return make_printf(k, o, new_acc, rest);
            }
            }(k,acc,rest));
        case /* Caml_char */1 :
            var rest$1 = fmt[0];
            return (function(k,acc,rest$1){
            return function (c) {
              var new_acc_001 = format_caml_char(c);
              var new_acc = /* Acc_data_string */block.__(4, [
                  acc,
                  new_acc_001
                ]);
              return make_printf(k, o, new_acc, rest$1);
            }
            }(k,acc,rest$1));
        case /* String */2 :
            return make_padding(k, o, acc, fmt[1], fmt[0], (function (str) {
                          return str;
                        }));
        case /* Caml_string */3 :
            return make_padding(k, o, acc, fmt[1], fmt[0], string_to_caml_string);
        case /* Int */4 :
            return make_int_padding_precision(k, o, acc, fmt[3], fmt[1], fmt[2], convert_int, fmt[0]);
        case /* Int32 */5 :
            return make_int_padding_precision(k, o, acc, fmt[3], fmt[1], fmt[2], convert_int32, fmt[0]);
        case /* Nativeint */6 :
            return make_int_padding_precision(k, o, acc, fmt[3], fmt[1], fmt[2], convert_nativeint, fmt[0]);
        case /* Int64 */7 :
            return make_int_padding_precision(k, o, acc, fmt[3], fmt[1], fmt[2], convert_int64, fmt[0]);
        case /* Float */8 :
            var k$1 = k;
            var o$1 = o;
            var acc$1 = acc;
            var fmt$1 = fmt[3];
            var pad = fmt[1];
            var prec = fmt[2];
            var fconv = fmt[0];
            if (typeof pad === "number") {
              if (typeof prec === "number") {
                if (prec !== 0) {
                  return (function(k$1,o$1,acc$1,fmt$1,fconv){
                  return function (p, x) {
                    var str = convert_float(fconv, p, x);
                    return make_printf(k$1, o$1, /* Acc_data_string */block.__(4, [
                                  acc$1,
                                  str
                                ]), fmt$1);
                  }
                  }(k$1,o$1,acc$1,fmt$1,fconv));
                } else {
                  return (function(k$1,o$1,acc$1,fmt$1,fconv){
                  return function (x) {
                    var str = convert_float(fconv, -6, x);
                    return make_printf(k$1, o$1, /* Acc_data_string */block.__(4, [
                                  acc$1,
                                  str
                                ]), fmt$1);
                  }
                  }(k$1,o$1,acc$1,fmt$1,fconv));
                }
              } else {
                var p = prec[0];
                return (function(k$1,o$1,acc$1,fmt$1,fconv,p){
                return function (x) {
                  var str = convert_float(fconv, p, x);
                  return make_printf(k$1, o$1, /* Acc_data_string */block.__(4, [
                                acc$1,
                                str
                              ]), fmt$1);
                }
                }(k$1,o$1,acc$1,fmt$1,fconv,p));
              }
            } else if (pad.tag) {
              var padty = pad[0];
              if (typeof prec === "number") {
                if (prec !== 0) {
                  return (function(k$1,o$1,acc$1,fmt$1,fconv,padty){
                  return function (w, p, x) {
                    var str = fix_padding(padty, w, convert_float(fconv, p, x));
                    return make_printf(k$1, o$1, /* Acc_data_string */block.__(4, [
                                  acc$1,
                                  str
                                ]), fmt$1);
                  }
                  }(k$1,o$1,acc$1,fmt$1,fconv,padty));
                } else {
                  return (function(k$1,o$1,acc$1,fmt$1,fconv,padty){
                  return function (w, x) {
                    var str = convert_float(fconv, -6, x);
                    var str$prime = fix_padding(padty, w, str);
                    return make_printf(k$1, o$1, /* Acc_data_string */block.__(4, [
                                  acc$1,
                                  str$prime
                                ]), fmt$1);
                  }
                  }(k$1,o$1,acc$1,fmt$1,fconv,padty));
                }
              } else {
                var p$1 = prec[0];
                return (function(k$1,o$1,acc$1,fmt$1,fconv,padty,p$1){
                return function (w, x) {
                  var str = fix_padding(padty, w, convert_float(fconv, p$1, x));
                  return make_printf(k$1, o$1, /* Acc_data_string */block.__(4, [
                                acc$1,
                                str
                              ]), fmt$1);
                }
                }(k$1,o$1,acc$1,fmt$1,fconv,padty,p$1));
              }
            } else {
              var w = pad[1];
              var padty$1 = pad[0];
              if (typeof prec === "number") {
                if (prec !== 0) {
                  return (function(k$1,o$1,acc$1,fmt$1,fconv,padty$1,w){
                  return function (p, x) {
                    var str = fix_padding(padty$1, w, convert_float(fconv, p, x));
                    return make_printf(k$1, o$1, /* Acc_data_string */block.__(4, [
                                  acc$1,
                                  str
                                ]), fmt$1);
                  }
                  }(k$1,o$1,acc$1,fmt$1,fconv,padty$1,w));
                } else {
                  return (function(k$1,o$1,acc$1,fmt$1,fconv,padty$1,w){
                  return function (x) {
                    var str = convert_float(fconv, -6, x);
                    var str$prime = fix_padding(padty$1, w, str);
                    return make_printf(k$1, o$1, /* Acc_data_string */block.__(4, [
                                  acc$1,
                                  str$prime
                                ]), fmt$1);
                  }
                  }(k$1,o$1,acc$1,fmt$1,fconv,padty$1,w));
                }
              } else {
                var p$2 = prec[0];
                return (function(k$1,o$1,acc$1,fmt$1,fconv,padty$1,w,p$2){
                return function (x) {
                  var str = fix_padding(padty$1, w, convert_float(fconv, p$2, x));
                  return make_printf(k$1, o$1, /* Acc_data_string */block.__(4, [
                                acc$1,
                                str
                              ]), fmt$1);
                }
                }(k$1,o$1,acc$1,fmt$1,fconv,padty$1,w,p$2));
              }
            }
        case /* Bool */9 :
            return make_padding(k, o, acc, fmt[1], fmt[0], pervasives.string_of_bool);
        case /* Flush */10 :
            _fmt = fmt[0];
            _acc = /* Acc_flush */block.__(7, [acc]);
            continue ;
        case /* String_literal */11 :
            _fmt = fmt[1];
            _acc = /* Acc_string_literal */block.__(2, [
                acc,
                fmt[0]
              ]);
            continue ;
        case /* Char_literal */12 :
            _fmt = fmt[1];
            _acc = /* Acc_char_literal */block.__(3, [
                acc,
                fmt[0]
              ]);
            continue ;
        case /* Format_arg */13 :
            var rest$2 = fmt[2];
            var ty = string_of_fmtty(fmt[1]);
            return (function(k,acc,rest$2,ty){
            return function (str) {
              return make_printf(k, o, /* Acc_data_string */block.__(4, [
                            acc,
                            ty
                          ]), rest$2);
            }
            }(k,acc,rest$2,ty));
        case /* Format_subst */14 :
            var rest$3 = fmt[2];
            var fmtty = fmt[1];
            return (function(k,acc,fmtty,rest$3){
            return function (param) {
              return make_printf(k, o, acc, camlinternalFormatBasics.concat_fmt(recast(param[0], fmtty), rest$3));
            }
            }(k,acc,fmtty,rest$3));
        case /* Alpha */15 :
            var rest$4 = fmt[0];
            return (function(k,acc,rest$4){
            return function (f, x) {
              return make_printf(k, o, /* Acc_delay */block.__(6, [
                            acc,
                            (function (o) {
                                return curry._2(f, o, x);
                              })
                          ]), rest$4);
            }
            }(k,acc,rest$4));
        case /* Theta */16 :
            var rest$5 = fmt[0];
            return (function(k,acc,rest$5){
            return function (f) {
              return make_printf(k, o, /* Acc_delay */block.__(6, [
                            acc,
                            f
                          ]), rest$5);
            }
            }(k,acc,rest$5));
        case /* Formatting_lit */17 :
            _fmt = fmt[1];
            _acc = /* Acc_formatting_lit */block.__(0, [
                acc,
                fmt[0]
              ]);
            continue ;
        case /* Formatting_gen */18 :
            var match = fmt[0];
            if (match.tag) {
              var rest$6 = fmt[1];
              var k$prime = (function(k,acc,rest$6){
              return function k$prime(koc, kacc) {
                return make_printf(k, koc, /* Acc_formatting_gen */block.__(1, [
                              acc,
                              /* Acc_open_box */block.__(1, [kacc])
                            ]), rest$6);
              }
              }(k,acc,rest$6));
              _fmt = match[0][0];
              _acc = /* End_of_acc */0;
              _k = k$prime;
              continue ;
            } else {
              var rest$7 = fmt[1];
              var k$prime$1 = (function(k,acc,rest$7){
              return function k$prime$1(koc, kacc) {
                return make_printf(k, koc, /* Acc_formatting_gen */block.__(1, [
                              acc,
                              /* Acc_open_tag */block.__(0, [kacc])
                            ]), rest$7);
              }
              }(k,acc,rest$7));
              _fmt = match[0][0];
              _acc = /* End_of_acc */0;
              _k = k$prime$1;
              continue ;
            }
        case /* Reader */19 :
            throw [
                  caml_builtin_exceptions.assert_failure,
                  /* tuple */[
                    "camlinternalFormat.ml",
                    1525,
                    4
                  ]
                ];
        case /* Scan_char_set */20 :
            var rest$8 = fmt[2];
            var new_acc = /* Acc_invalid_arg */block.__(8, [
                acc,
                "Printf: bad conversion %["
              ]);
            return (function(k,rest$8,new_acc){
            return function (param) {
              return make_printf(k, o, new_acc, rest$8);
            }
            }(k,rest$8,new_acc));
        case /* Scan_get_counter */21 :
            var rest$9 = fmt[1];
            return (function(k,acc,rest$9){
            return function (n) {
              var new_acc_001 = caml_format.caml_format_int("%u", n);
              var new_acc = /* Acc_data_string */block.__(4, [
                  acc,
                  new_acc_001
                ]);
              return make_printf(k, o, new_acc, rest$9);
            }
            }(k,acc,rest$9));
        case /* Scan_next_char */22 :
            var rest$10 = fmt[0];
            return (function(k,acc,rest$10){
            return function (c) {
              var new_acc = /* Acc_data_char */block.__(5, [
                  acc,
                  c
                ]);
              return make_printf(k, o, new_acc, rest$10);
            }
            }(k,acc,rest$10));
        case /* Ignored_param */23 :
            return make_ignored_param(k, o, acc, fmt[0], fmt[1]);
        case /* Custom */24 :
            return make_custom(k, o, acc, fmt[2], fmt[0], curry._1(fmt[1], /* () */0));
        
      }
    }
  }}

function make_ignored_param(k, o, acc, ign, fmt) {
  if (typeof ign === "number") {
    if (ign === /* Ignored_reader */2) {
      throw [
            caml_builtin_exceptions.assert_failure,
            /* tuple */[
              "camlinternalFormat.ml",
              1593,
              39
            ]
          ];
    } else {
      return make_invalid_arg(k, o, acc, fmt);
    }
  } else if (ign.tag === /* Ignored_format_subst */9) {
    return make_from_fmtty(k, o, acc, ign[1], fmt);
  } else {
    return make_invalid_arg(k, o, acc, fmt);
  }
}

function make_from_fmtty(k, o, acc, fmtty, fmt) {
  if (typeof fmtty === "number") {
    return make_invalid_arg(k, o, acc, fmt);
  } else {
    switch (fmtty.tag | 0) {
      case /* Char_ty */0 :
          var rest = fmtty[0];
          return (function (param) {
              return make_from_fmtty(k, o, acc, rest, fmt);
            });
      case /* String_ty */1 :
          var rest$1 = fmtty[0];
          return (function (param) {
              return make_from_fmtty(k, o, acc, rest$1, fmt);
            });
      case /* Int_ty */2 :
          var rest$2 = fmtty[0];
          return (function (param) {
              return make_from_fmtty(k, o, acc, rest$2, fmt);
            });
      case /* Int32_ty */3 :
          var rest$3 = fmtty[0];
          return (function (param) {
              return make_from_fmtty(k, o, acc, rest$3, fmt);
            });
      case /* Nativeint_ty */4 :
          var rest$4 = fmtty[0];
          return (function (param) {
              return make_from_fmtty(k, o, acc, rest$4, fmt);
            });
      case /* Int64_ty */5 :
          var rest$5 = fmtty[0];
          return (function (param) {
              return make_from_fmtty(k, o, acc, rest$5, fmt);
            });
      case /* Float_ty */6 :
          var rest$6 = fmtty[0];
          return (function (param) {
              return make_from_fmtty(k, o, acc, rest$6, fmt);
            });
      case /* Bool_ty */7 :
          var rest$7 = fmtty[0];
          return (function (param) {
              return make_from_fmtty(k, o, acc, rest$7, fmt);
            });
      case /* Format_arg_ty */8 :
          var rest$8 = fmtty[1];
          return (function (param) {
              return make_from_fmtty(k, o, acc, rest$8, fmt);
            });
      case /* Format_subst_ty */9 :
          var rest$9 = fmtty[2];
          var ty = trans(symm(fmtty[0]), fmtty[1]);
          return (function (param) {
              return make_from_fmtty(k, o, acc, camlinternalFormatBasics.concat_fmtty(ty, rest$9), fmt);
            });
      case /* Alpha_ty */10 :
          var rest$10 = fmtty[0];
          return (function (param, param$1) {
              return make_from_fmtty(k, o, acc, rest$10, fmt);
            });
      case /* Theta_ty */11 :
          var rest$11 = fmtty[0];
          return (function (param) {
              return make_from_fmtty(k, o, acc, rest$11, fmt);
            });
      case /* Any_ty */12 :
          var rest$12 = fmtty[0];
          return (function (param) {
              return make_from_fmtty(k, o, acc, rest$12, fmt);
            });
      case /* Reader_ty */13 :
          throw [
                caml_builtin_exceptions.assert_failure,
                /* tuple */[
                  "camlinternalFormat.ml",
                  1616,
                  31
                ]
              ];
      case /* Ignored_reader_ty */14 :
          throw [
                caml_builtin_exceptions.assert_failure,
                /* tuple */[
                  "camlinternalFormat.ml",
                  1617,
                  31
                ]
              ];
      
    }
  }
}

function make_invalid_arg(k, o, acc, fmt) {
  return make_printf(k, o, /* Acc_invalid_arg */block.__(8, [
                acc,
                "Printf: bad conversion %_"
              ]), fmt);
}

function make_padding(k, o, acc, fmt, pad, trans) {
  if (typeof pad === "number") {
    return (function (x) {
        var new_acc_001 = curry._1(trans, x);
        var new_acc = /* Acc_data_string */block.__(4, [
            acc,
            new_acc_001
          ]);
        return make_printf(k, o, new_acc, fmt);
      });
  } else if (pad.tag) {
    var padty = pad[0];
    return (function (w, x) {
        var new_acc_001 = fix_padding(padty, w, curry._1(trans, x));
        var new_acc = /* Acc_data_string */block.__(4, [
            acc,
            new_acc_001
          ]);
        return make_printf(k, o, new_acc, fmt);
      });
  } else {
    var width = pad[1];
    var padty$1 = pad[0];
    return (function (x) {
        var new_acc_001 = fix_padding(padty$1, width, curry._1(trans, x));
        var new_acc = /* Acc_data_string */block.__(4, [
            acc,
            new_acc_001
          ]);
        return make_printf(k, o, new_acc, fmt);
      });
  }
}

function make_int_padding_precision(k, o, acc, fmt, pad, prec, trans, iconv) {
  if (typeof pad === "number") {
    if (typeof prec === "number") {
      if (prec !== 0) {
        return (function (p, x) {
            var str = fix_int_precision(p, curry._2(trans, iconv, x));
            return make_printf(k, o, /* Acc_data_string */block.__(4, [
                          acc,
                          str
                        ]), fmt);
          });
      } else {
        return (function (x) {
            var str = curry._2(trans, iconv, x);
            return make_printf(k, o, /* Acc_data_string */block.__(4, [
                          acc,
                          str
                        ]), fmt);
          });
      }
    } else {
      var p = prec[0];
      return (function (x) {
          var str = fix_int_precision(p, curry._2(trans, iconv, x));
          return make_printf(k, o, /* Acc_data_string */block.__(4, [
                        acc,
                        str
                      ]), fmt);
        });
    }
  } else if (pad.tag) {
    var padty = pad[0];
    if (typeof prec === "number") {
      if (prec !== 0) {
        return (function (w, p, x) {
            var str = fix_padding(padty, w, fix_int_precision(p, curry._2(trans, iconv, x)));
            return make_printf(k, o, /* Acc_data_string */block.__(4, [
                          acc,
                          str
                        ]), fmt);
          });
      } else {
        return (function (w, x) {
            var str = fix_padding(padty, w, curry._2(trans, iconv, x));
            return make_printf(k, o, /* Acc_data_string */block.__(4, [
                          acc,
                          str
                        ]), fmt);
          });
      }
    } else {
      var p$1 = prec[0];
      return (function (w, x) {
          var str = fix_padding(padty, w, fix_int_precision(p$1, curry._2(trans, iconv, x)));
          return make_printf(k, o, /* Acc_data_string */block.__(4, [
                        acc,
                        str
                      ]), fmt);
        });
    }
  } else {
    var w = pad[1];
    var padty$1 = pad[0];
    if (typeof prec === "number") {
      if (prec !== 0) {
        return (function (p, x) {
            var str = fix_padding(padty$1, w, fix_int_precision(p, curry._2(trans, iconv, x)));
            return make_printf(k, o, /* Acc_data_string */block.__(4, [
                          acc,
                          str
                        ]), fmt);
          });
      } else {
        return (function (x) {
            var str = fix_padding(padty$1, w, curry._2(trans, iconv, x));
            return make_printf(k, o, /* Acc_data_string */block.__(4, [
                          acc,
                          str
                        ]), fmt);
          });
      }
    } else {
      var p$2 = prec[0];
      return (function (x) {
          var str = fix_padding(padty$1, w, fix_int_precision(p$2, curry._2(trans, iconv, x)));
          return make_printf(k, o, /* Acc_data_string */block.__(4, [
                        acc,
                        str
                      ]), fmt);
        });
    }
  }
}

function make_custom(k, o, acc, rest, arity, f) {
  if (arity) {
    var arity$1 = arity[0];
    return (function (x) {
        return make_custom(k, o, acc, rest, arity$1, curry._1(f, x));
      });
  } else {
    return make_printf(k, o, /* Acc_data_string */block.__(4, [
                  acc,
                  f
                ]), rest);
  }
}

function make_iprintf(_k, o, _fmt) {
  while(true) {
    var fmt = _fmt;
    var k = _k;
    var exit = 0;
    if (typeof fmt === "number") {
      return curry._1(k, o);
    } else {
      switch (fmt.tag | 0) {
        case /* String */2 :
            var tmp = fmt[0];
            if (typeof tmp !== "number" && tmp.tag) {
              var partial_arg = make_iprintf(k, o, fmt[1]);
              var partial_arg$1 = (function(partial_arg){
              return function partial_arg$1(param) {
                return partial_arg;
              }
              }(partial_arg));
              return (function (param) {
                  return partial_arg$1;
                });
            }
            var partial_arg$2 = make_iprintf(k, o, fmt[1]);
            return (function(partial_arg$2){
            return function (param) {
              return partial_arg$2;
            }
            }(partial_arg$2));
        case /* Caml_string */3 :
            var tmp$1 = fmt[0];
            if (typeof tmp$1 !== "number" && tmp$1.tag) {
              var partial_arg$3 = make_iprintf(k, o, fmt[1]);
              var partial_arg$4 = (function(partial_arg$3){
              return function partial_arg$4(param) {
                return partial_arg$3;
              }
              }(partial_arg$3));
              return (function (param) {
                  return partial_arg$4;
                });
            }
            var partial_arg$5 = make_iprintf(k, o, fmt[1]);
            return (function(partial_arg$5){
            return function (param) {
              return partial_arg$5;
            }
            }(partial_arg$5));
        case /* Bool */9 :
            var tmp$2 = fmt[0];
            if (typeof tmp$2 !== "number" && tmp$2.tag) {
              var partial_arg$6 = make_iprintf(k, o, fmt[1]);
              var partial_arg$7 = (function(partial_arg$6){
              return function partial_arg$7(param) {
                return partial_arg$6;
              }
              }(partial_arg$6));
              return (function (param) {
                  return partial_arg$7;
                });
            }
            var partial_arg$8 = make_iprintf(k, o, fmt[1]);
            return (function(partial_arg$8){
            return function (param) {
              return partial_arg$8;
            }
            }(partial_arg$8));
        case /* Flush */10 :
            _fmt = fmt[0];
            continue ;
        case /* Format_subst */14 :
            var rest = fmt[2];
            var fmtty = fmt[1];
            return (function(k,fmtty,rest){
            return function (param) {
              return make_iprintf(k, o, camlinternalFormatBasics.concat_fmt(recast(param[0], fmtty), rest));
            }
            }(k,fmtty,rest));
        case /* Alpha */15 :
            var partial_arg$9 = make_iprintf(k, o, fmt[0]);
            var partial_arg$10 = (function(partial_arg$9){
            return function partial_arg$10(param) {
              return partial_arg$9;
            }
            }(partial_arg$9));
            return (function (param) {
                return partial_arg$10;
              });
        case /* String_literal */11 :
        case /* Char_literal */12 :
        case /* Formatting_lit */17 :
            exit = 2;
            break;
        case /* Formatting_gen */18 :
            var match = fmt[0];
            if (match.tag) {
              var rest$1 = fmt[1];
              _fmt = match[0][0];
              _k = (function(k,rest$1){
              return function (koc) {
                return make_iprintf(k, koc, rest$1);
              }
              }(k,rest$1));
              continue ;
            } else {
              var rest$2 = fmt[1];
              _fmt = match[0][0];
              _k = (function(k,rest$2){
              return function (koc) {
                return make_iprintf(k, koc, rest$2);
              }
              }(k,rest$2));
              continue ;
            }
        case /* Reader */19 :
            throw [
                  caml_builtin_exceptions.assert_failure,
                  /* tuple */[
                    "camlinternalFormat.ml",
                    1797,
                    8
                  ]
                ];
        case /* Format_arg */13 :
        case /* Scan_char_set */20 :
            exit = 3;
            break;
        case /* Scan_get_counter */21 :
            var partial_arg$11 = make_iprintf(k, o, fmt[1]);
            return (function(partial_arg$11){
            return function (param) {
              return partial_arg$11;
            }
            }(partial_arg$11));
        case /* Char */0 :
        case /* Caml_char */1 :
        case /* Theta */16 :
        case /* Scan_next_char */22 :
            exit = 1;
            break;
        case /* Ignored_param */23 :
            return make_ignored_param((function(k){
                      return function (x, param) {
                        return curry._1(k, x);
                      }
                      }(k)), o, /* End_of_acc */0, fmt[0], fmt[1]);
        case /* Custom */24 :
            return fn_of_custom_arity(k, o, fmt[2], fmt[0]);
        default:
          var k$1 = k;
          var o$1 = o;
          var fmt$1 = fmt[3];
          var pad = fmt[1];
          var prec = fmt[2];
          if (typeof pad === "number") {
            if (typeof prec === "number") {
              if (prec !== 0) {
                var partial_arg$12 = make_iprintf(k$1, o$1, fmt$1);
                var partial_arg$13 = (function(partial_arg$12){
                return function partial_arg$13(param) {
                  return partial_arg$12;
                }
                }(partial_arg$12));
                return (function (param) {
                    return partial_arg$13;
                  });
              } else {
                var partial_arg$14 = make_iprintf(k$1, o$1, fmt$1);
                return (function(partial_arg$14){
                return function (param) {
                  return partial_arg$14;
                }
                }(partial_arg$14));
              }
            } else {
              var partial_arg$15 = make_iprintf(k$1, o$1, fmt$1);
              return (function(partial_arg$15){
              return function (param) {
                return partial_arg$15;
              }
              }(partial_arg$15));
            }
          } else if (pad.tag) {
            if (typeof prec === "number") {
              if (prec !== 0) {
                var partial_arg$16 = make_iprintf(k$1, o$1, fmt$1);
                var partial_arg$17 = (function(partial_arg$16){
                return function partial_arg$17(param) {
                  return partial_arg$16;
                }
                }(partial_arg$16));
                var partial_arg$18 = function (param) {
                  return partial_arg$17;
                };
                return (function (param) {
                    return partial_arg$18;
                  });
              } else {
                var partial_arg$19 = make_iprintf(k$1, o$1, fmt$1);
                var partial_arg$20 = (function(partial_arg$19){
                return function partial_arg$20(param) {
                  return partial_arg$19;
                }
                }(partial_arg$19));
                return (function (param) {
                    return partial_arg$20;
                  });
              }
            } else {
              var partial_arg$21 = make_iprintf(k$1, o$1, fmt$1);
              var partial_arg$22 = (function(partial_arg$21){
              return function partial_arg$22(param) {
                return partial_arg$21;
              }
              }(partial_arg$21));
              return (function (param) {
                  return partial_arg$22;
                });
            }
          } else if (typeof prec === "number") {
            if (prec !== 0) {
              var partial_arg$23 = make_iprintf(k$1, o$1, fmt$1);
              var partial_arg$24 = (function(partial_arg$23){
              return function partial_arg$24(param) {
                return partial_arg$23;
              }
              }(partial_arg$23));
              return (function (param) {
                  return partial_arg$24;
                });
            } else {
              var partial_arg$25 = make_iprintf(k$1, o$1, fmt$1);
              return (function(partial_arg$25){
              return function (param) {
                return partial_arg$25;
              }
              }(partial_arg$25));
            }
          } else {
            var partial_arg$26 = make_iprintf(k$1, o$1, fmt$1);
            return (function(partial_arg$26){
            return function (param) {
              return partial_arg$26;
            }
            }(partial_arg$26));
          }
      }
    }
    switch (exit) {
      case 1 :
          var partial_arg$27 = make_iprintf(k, o, fmt[0]);
          return (function(partial_arg$27){
          return function (param) {
            return partial_arg$27;
          }
          }(partial_arg$27));
      case 2 :
          _fmt = fmt[1];
          continue ;
      case 3 :
          var partial_arg$28 = make_iprintf(k, o, fmt[2]);
          return (function(partial_arg$28){
          return function (param) {
            return partial_arg$28;
          }
          }(partial_arg$28));
      
    }
  }}

function fn_of_custom_arity(k, o, fmt, param) {
  if (param) {
    var partial_arg = fn_of_custom_arity(k, o, fmt, param[0]);
    return (function (param) {
        return partial_arg;
      });
  } else {
    return make_iprintf(k, o, fmt);
  }
}

function output_acc(o, _acc) {
  while(true) {
    var acc = _acc;
    var exit = 0;
    if (typeof acc === "number") {
      return /* () */0;
    } else {
      switch (acc.tag | 0) {
        case /* Acc_formatting_lit */0 :
            var s = string_of_formatting_lit(acc[1]);
            output_acc(o, acc[0]);
            return pervasives.output_string(o, s);
        case /* Acc_formatting_gen */1 :
            var match = acc[1];
            var p = acc[0];
            output_acc(o, p);
            if (match.tag) {
              pervasives.output_string(o, "@[");
              _acc = match[0];
              continue ;
            } else {
              pervasives.output_string(o, "@{");
              _acc = match[0];
              continue ;
            }
        case /* Acc_string_literal */2 :
        case /* Acc_data_string */4 :
            exit = 1;
            break;
        case /* Acc_char_literal */3 :
        case /* Acc_data_char */5 :
            exit = 2;
            break;
        case /* Acc_delay */6 :
            output_acc(o, acc[0]);
            return curry._1(acc[1], o);
        case /* Acc_flush */7 :
            output_acc(o, acc[0]);
            return caml_io.caml_ml_flush(o);
        case /* Acc_invalid_arg */8 :
            output_acc(o, acc[0]);
            throw [
                  caml_builtin_exceptions.invalid_argument,
                  acc[1]
                ];
        
      }
    }
    switch (exit) {
      case 1 :
          output_acc(o, acc[0]);
          return pervasives.output_string(o, acc[1]);
      case 2 :
          output_acc(o, acc[0]);
          return caml_io.caml_ml_output_char(o, acc[1]);
      
    }
  }}

function bufput_acc(b, _acc) {
  while(true) {
    var acc = _acc;
    var exit = 0;
    if (typeof acc === "number") {
      return /* () */0;
    } else {
      switch (acc.tag | 0) {
        case /* Acc_formatting_lit */0 :
            var s = string_of_formatting_lit(acc[1]);
            bufput_acc(b, acc[0]);
            return buffer.add_string(b, s);
        case /* Acc_formatting_gen */1 :
            var match = acc[1];
            var p = acc[0];
            bufput_acc(b, p);
            if (match.tag) {
              buffer.add_string(b, "@[");
              _acc = match[0];
              continue ;
            } else {
              buffer.add_string(b, "@{");
              _acc = match[0];
              continue ;
            }
        case /* Acc_string_literal */2 :
        case /* Acc_data_string */4 :
            exit = 1;
            break;
        case /* Acc_char_literal */3 :
        case /* Acc_data_char */5 :
            exit = 2;
            break;
        case /* Acc_delay */6 :
            bufput_acc(b, acc[0]);
            return curry._1(acc[1], b);
        case /* Acc_flush */7 :
            _acc = acc[0];
            continue ;
        case /* Acc_invalid_arg */8 :
            bufput_acc(b, acc[0]);
            throw [
                  caml_builtin_exceptions.invalid_argument,
                  acc[1]
                ];
        
      }
    }
    switch (exit) {
      case 1 :
          bufput_acc(b, acc[0]);
          return buffer.add_string(b, acc[1]);
      case 2 :
          bufput_acc(b, acc[0]);
          return buffer.add_char(b, acc[1]);
      
    }
  }}

function strput_acc(b, _acc) {
  while(true) {
    var acc = _acc;
    var exit = 0;
    if (typeof acc === "number") {
      return /* () */0;
    } else {
      switch (acc.tag | 0) {
        case /* Acc_formatting_lit */0 :
            var s = string_of_formatting_lit(acc[1]);
            strput_acc(b, acc[0]);
            return buffer.add_string(b, s);
        case /* Acc_formatting_gen */1 :
            var match = acc[1];
            var p = acc[0];
            strput_acc(b, p);
            if (match.tag) {
              buffer.add_string(b, "@[");
              _acc = match[0];
              continue ;
            } else {
              buffer.add_string(b, "@{");
              _acc = match[0];
              continue ;
            }
        case /* Acc_string_literal */2 :
        case /* Acc_data_string */4 :
            exit = 1;
            break;
        case /* Acc_char_literal */3 :
        case /* Acc_data_char */5 :
            exit = 2;
            break;
        case /* Acc_delay */6 :
            strput_acc(b, acc[0]);
            return buffer.add_string(b, curry._1(acc[1], /* () */0));
        case /* Acc_flush */7 :
            _acc = acc[0];
            continue ;
        case /* Acc_invalid_arg */8 :
            strput_acc(b, acc[0]);
            throw [
                  caml_builtin_exceptions.invalid_argument,
                  acc[1]
                ];
        
      }
    }
    switch (exit) {
      case 1 :
          strput_acc(b, acc[0]);
          return buffer.add_string(b, acc[1]);
      case 2 :
          strput_acc(b, acc[0]);
          return buffer.add_char(b, acc[1]);
      
    }
  }}

function failwith_message(param) {
  var buf = buffer.create(256);
  var k = function (param, acc) {
    strput_acc(buf, acc);
    var s = buffer.contents(buf);
    throw [
          caml_builtin_exceptions.failure,
          s
        ];
  };
  return make_printf(k, /* () */0, /* End_of_acc */0, param[0]);
}

function open_box_of_string(str) {
  if (str === "") {
    return /* tuple */[
            0,
            /* Pp_box */4
          ];
  } else {
    var len = str.length;
    var invalid_box = function (param) {
      return curry._1(failwith_message(/* Format */[
                      /* String_literal */block.__(11, [
                          "invalid box description ",
                          /* Caml_string */block.__(3, [
                              /* No_padding */0,
                              /* End_of_format */0
                            ])
                        ]),
                      "invalid box description %S"
                    ]), str);
    };
    var parse_spaces = function (_i) {
      while(true) {
        var i = _i;
        if (i === len) {
          return i;
        } else {
          var match = caml_string.get(str, i);
          if (match !== 9) {
            if (match !== 32) {
              return i;
            } else {
              _i = i + 1 | 0;
              continue ;
            }
          } else {
            _i = i + 1 | 0;
            continue ;
          }
        }
      }    };
    var parse_lword = function (i, _j) {
      while(true) {
        var j = _j;
        if (j === len) {
          return j;
        } else {
          var match = caml_string.get(str, j);
          if (match > 122 || match < 97) {
            return j;
          } else {
            _j = j + 1 | 0;
            continue ;
          }
        }
      }    };
    var parse_int = function (i, _j) {
      while(true) {
        var j = _j;
        if (j === len) {
          return j;
        } else {
          var match = caml_string.get(str, j);
          if (match >= 48) {
            if (match >= 58) {
              return j;
            } else {
              _j = j + 1 | 0;
              continue ;
            }
          } else if (match !== 45) {
            return j;
          } else {
            _j = j + 1 | 0;
            continue ;
          }
        }
      }    };
    var wstart = parse_spaces(0);
    var wend = parse_lword(wstart, wstart);
    var box_name = string.sub(str, wstart, wend - wstart | 0);
    var nstart = parse_spaces(wend);
    var nend = parse_int(nstart, nstart);
    var indent;
    if (nstart === nend) {
      indent = 0;
    } else {
      try {
        indent = caml_format.caml_int_of_string(string.sub(str, nstart, nend - nstart | 0));
      }
      catch (raw_exn){
        var exn = caml_js_exceptions.internalToOCamlException(raw_exn);
        if (exn[0] === caml_builtin_exceptions.failure) {
          indent = invalid_box(/* () */0);
        } else {
          throw exn;
        }
      }
    }
    var exp_end = parse_spaces(nend);
    if (exp_end !== len) {
      invalid_box(/* () */0);
    }
    var box_type;
    switch (box_name) {
      case "" :
      case "b" :
          box_type = /* Pp_box */4;
          break;
      case "h" :
          box_type = /* Pp_hbox */0;
          break;
      case "hov" :
          box_type = /* Pp_hovbox */3;
          break;
      case "hv" :
          box_type = /* Pp_hvbox */2;
          break;
      case "v" :
          box_type = /* Pp_vbox */1;
          break;
      default:
        box_type = invalid_box(/* () */0);
    }
    return /* tuple */[
            indent,
            box_type
          ];
  }
}

function make_padding_fmt_ebb(pad, fmt) {
  if (typeof pad === "number") {
    return /* Padding_fmt_EBB */[
            /* No_padding */0,
            fmt
          ];
  } else if (pad.tag) {
    return /* Padding_fmt_EBB */[
            /* Arg_padding */block.__(1, [pad[0]]),
            fmt
          ];
  } else {
    return /* Padding_fmt_EBB */[
            /* Lit_padding */block.__(0, [
                pad[0],
                pad[1]
              ]),
            fmt
          ];
  }
}

function make_precision_fmt_ebb(prec, fmt) {
  if (typeof prec === "number") {
    if (prec !== 0) {
      return /* Precision_fmt_EBB */[
              /* Arg_precision */1,
              fmt
            ];
    } else {
      return /* Precision_fmt_EBB */[
              /* No_precision */0,
              fmt
            ];
    }
  } else {
    return /* Precision_fmt_EBB */[
            /* Lit_precision */[prec[0]],
            fmt
          ];
  }
}

function make_padprec_fmt_ebb(pad, prec, fmt) {
  var match = make_precision_fmt_ebb(prec, fmt);
  var fmt$prime = match[1];
  var prec$1 = match[0];
  if (typeof pad === "number") {
    return /* Padprec_fmt_EBB */[
            /* No_padding */0,
            prec$1,
            fmt$prime
          ];
  } else if (pad.tag) {
    return /* Padprec_fmt_EBB */[
            /* Arg_padding */block.__(1, [pad[0]]),
            prec$1,
            fmt$prime
          ];
  } else {
    return /* Padprec_fmt_EBB */[
            /* Lit_padding */block.__(0, [
                pad[0],
                pad[1]
              ]),
            prec$1,
            fmt$prime
          ];
  }
}

function fmt_ebb_of_string(legacy_behavior, str) {
  var legacy_behavior$1 = legacy_behavior !== undefined ? legacy_behavior : true;
  var invalid_format_message = function (str_ind, msg) {
    return curry._3(failwith_message(/* Format */[
                    /* String_literal */block.__(11, [
                        "invalid format ",
                        /* Caml_string */block.__(3, [
                            /* No_padding */0,
                            /* String_literal */block.__(11, [
                                ": at character number ",
                                /* Int */block.__(4, [
                                    /* Int_d */0,
                                    /* No_padding */0,
                                    /* No_precision */0,
                                    /* String_literal */block.__(11, [
                                        ", ",
                                        /* String */block.__(2, [
                                            /* No_padding */0,
                                            /* End_of_format */0
                                          ])
                                      ])
                                  ])
                              ])
                          ])
                      ]),
                    "invalid format %S: at character number %d, %s"
                  ]), str, str_ind, msg);
  };
  var invalid_format_without = function (str_ind, c, s) {
    return curry._4(failwith_message(/* Format */[
                    /* String_literal */block.__(11, [
                        "invalid format ",
                        /* Caml_string */block.__(3, [
                            /* No_padding */0,
                            /* String_literal */block.__(11, [
                                ": at character number ",
                                /* Int */block.__(4, [
                                    /* Int_d */0,
                                    /* No_padding */0,
                                    /* No_precision */0,
                                    /* String_literal */block.__(11, [
                                        ", '",
                                        /* Char */block.__(0, [/* String_literal */block.__(11, [
                                                "' without ",
                                                /* String */block.__(2, [
                                                    /* No_padding */0,
                                                    /* End_of_format */0
                                                  ])
                                              ])])
                                      ])
                                  ])
                              ])
                          ])
                      ]),
                    "invalid format %S: at character number %d, '%c' without %s"
                  ]), str, str_ind, c, s);
  };
  var expected_character = function (str_ind, expected, read) {
    return curry._4(failwith_message(/* Format */[
                    /* String_literal */block.__(11, [
                        "invalid format ",
                        /* Caml_string */block.__(3, [
                            /* No_padding */0,
                            /* String_literal */block.__(11, [
                                ": at character number ",
                                /* Int */block.__(4, [
                                    /* Int_d */0,
                                    /* No_padding */0,
                                    /* No_precision */0,
                                    /* String_literal */block.__(11, [
                                        ", ",
                                        /* String */block.__(2, [
                                            /* No_padding */0,
                                            /* String_literal */block.__(11, [
                                                " expected, read ",
                                                /* Caml_char */block.__(1, [/* End_of_format */0])
                                              ])
                                          ])
                                      ])
                                  ])
                              ])
                          ])
                      ]),
                    "invalid format %S: at character number %d, %s expected, read %C"
                  ]), str, str_ind, expected, read);
  };
  var parse_after_at = function (str_ind, end_ind) {
    if (str_ind === end_ind) {
      return /* Fmt_EBB */[/* Char_literal */block.__(12, [
                  /* "@" */64,
                  /* End_of_format */0
                ])];
    } else {
      var c = caml_string.get(str, str_ind);
      if (c >= 65) {
        if (c >= 94) {
          switch (c) {
            case 123 :
                return parse_tag(true, str_ind + 1 | 0, end_ind);
            case 124 :
                break;
            case 125 :
                var beg_ind = str_ind + 1 | 0;
                var match = parse_literal(beg_ind, beg_ind, end_ind);
                return /* Fmt_EBB */[/* Formatting_lit */block.__(17, [
                            /* Close_tag */1,
                            match[0]
                          ])];
              
          }
        } else if (c >= 91) {
          switch (c - 91 | 0) {
            case 0 :
                return parse_tag(false, str_ind + 1 | 0, end_ind);
            case 1 :
                break;
            case 2 :
                var beg_ind$1 = str_ind + 1 | 0;
                var match$1 = parse_literal(beg_ind$1, beg_ind$1, end_ind);
                return /* Fmt_EBB */[/* Formatting_lit */block.__(17, [
                            /* Close_box */0,
                            match$1[0]
                          ])];
            
          }
        }
        
      } else if (c !== 10) {
        if (c >= 32) {
          switch (c - 32 | 0) {
            case 0 :
                var beg_ind$2 = str_ind + 1 | 0;
                var match$2 = parse_literal(beg_ind$2, beg_ind$2, end_ind);
                return /* Fmt_EBB */[/* Formatting_lit */block.__(17, [
                            /* Break */block.__(0, [
                                "@ ",
                                1,
                                0
                              ]),
                            match$2[0]
                          ])];
            case 5 :
                if ((str_ind + 1 | 0) < end_ind && caml_string.get(str, str_ind + 1 | 0) === /* "%" */37) {
                  var beg_ind$3 = str_ind + 2 | 0;
                  var match$3 = parse_literal(beg_ind$3, beg_ind$3, end_ind);
                  return /* Fmt_EBB */[/* Formatting_lit */block.__(17, [
                              /* Escaped_percent */6,
                              match$3[0]
                            ])];
                } else {
                  var match$4 = parse_literal(str_ind, str_ind, end_ind);
                  return /* Fmt_EBB */[/* Char_literal */block.__(12, [
                              /* "@" */64,
                              match$4[0]
                            ])];
                }
            case 12 :
                var beg_ind$4 = str_ind + 1 | 0;
                var match$5 = parse_literal(beg_ind$4, beg_ind$4, end_ind);
                return /* Fmt_EBB */[/* Formatting_lit */block.__(17, [
                            /* Break */block.__(0, [
                                "@,",
                                0,
                                0
                              ]),
                            match$5[0]
                          ])];
            case 14 :
                var beg_ind$5 = str_ind + 1 | 0;
                var match$6 = parse_literal(beg_ind$5, beg_ind$5, end_ind);
                return /* Fmt_EBB */[/* Formatting_lit */block.__(17, [
                            /* Flush_newline */4,
                            match$6[0]
                          ])];
            case 27 :
                var str_ind$1 = str_ind + 1 | 0;
                var end_ind$1 = end_ind;
                var match$7;
                try {
                  if (str_ind$1 === end_ind$1 || caml_string.get(str, str_ind$1) !== /* "<" */60) {
                    throw caml_builtin_exceptions.not_found;
                  }
                  var str_ind_1 = parse_spaces(str_ind$1 + 1 | 0, end_ind$1);
                  var match$8 = caml_string.get(str, str_ind_1);
                  var exit = 0;
                  if (match$8 >= 48) {
                    if (match$8 >= 58) {
                      throw caml_builtin_exceptions.not_found;
                    }
                    exit = 1;
                  } else {
                    if (match$8 !== 45) {
                      throw caml_builtin_exceptions.not_found;
                    }
                    exit = 1;
                  }
                  if (exit === 1) {
                    var match$9 = parse_integer(str_ind_1, end_ind$1);
                    var width = match$9[1];
                    var str_ind_3 = parse_spaces(match$9[0], end_ind$1);
                    var match$10 = caml_string.get(str, str_ind_3);
                    var switcher = match$10 - 45 | 0;
                    if (switcher > 12 || switcher < 0) {
                      if (switcher !== 17) {
                        throw caml_builtin_exceptions.not_found;
                      }
                      var s = string.sub(str, str_ind$1 - 2 | 0, (str_ind_3 - str_ind$1 | 0) + 3 | 0);
                      match$7 = /* tuple */[
                        str_ind_3 + 1 | 0,
                        /* Break */block.__(0, [
                            s,
                            width,
                            0
                          ])
                      ];
                    } else if (switcher === 2 || switcher === 1) {
                      throw caml_builtin_exceptions.not_found;
                    } else {
                      var match$11 = parse_integer(str_ind_3, end_ind$1);
                      var str_ind_5 = parse_spaces(match$11[0], end_ind$1);
                      if (caml_string.get(str, str_ind_5) !== /* ">" */62) {
                        throw caml_builtin_exceptions.not_found;
                      }
                      var s$1 = string.sub(str, str_ind$1 - 2 | 0, (str_ind_5 - str_ind$1 | 0) + 3 | 0);
                      match$7 = /* tuple */[
                        str_ind_5 + 1 | 0,
                        /* Break */block.__(0, [
                            s$1,
                            width,
                            match$11[1]
                          ])
                      ];
                    }
                  }
                  
                }
                catch (raw_exn){
                  var exn = caml_js_exceptions.internalToOCamlException(raw_exn);
                  if (exn === caml_builtin_exceptions.not_found || exn[0] === caml_builtin_exceptions.failure) {
                    match$7 = /* tuple */[
                      str_ind$1,
                      /* Break */block.__(0, [
                          "@;",
                          1,
                          0
                        ])
                    ];
                  } else {
                    throw exn;
                  }
                }
                var next_ind = match$7[0];
                var match$12 = parse_literal(next_ind, next_ind, end_ind$1);
                return /* Fmt_EBB */[/* Formatting_lit */block.__(17, [
                            match$7[1],
                            match$12[0]
                          ])];
            case 28 :
                var str_ind$2 = str_ind + 1 | 0;
                var end_ind$2 = end_ind;
                var match$13;
                try {
                  var str_ind_1$1 = parse_spaces(str_ind$2, end_ind$2);
                  var match$14 = caml_string.get(str, str_ind_1$1);
                  var exit$1 = 0;
                  if (match$14 >= 48) {
                    if (match$14 >= 58) {
                      match$13 = undefined;
                    } else {
                      exit$1 = 1;
                    }
                  } else if (match$14 !== 45) {
                    match$13 = undefined;
                  } else {
                    exit$1 = 1;
                  }
                  if (exit$1 === 1) {
                    var match$15 = parse_integer(str_ind_1$1, end_ind$2);
                    var str_ind_3$1 = parse_spaces(match$15[0], end_ind$2);
                    if (caml_string.get(str, str_ind_3$1) !== /* ">" */62) {
                      throw caml_builtin_exceptions.not_found;
                    }
                    var s$2 = string.sub(str, str_ind$2 - 2 | 0, (str_ind_3$1 - str_ind$2 | 0) + 3 | 0);
                    match$13 = /* tuple */[
                      str_ind_3$1 + 1 | 0,
                      /* Magic_size */block.__(1, [
                          s$2,
                          match$15[1]
                        ])
                    ];
                  }
                  
                }
                catch (raw_exn$1){
                  var exn$1 = caml_js_exceptions.internalToOCamlException(raw_exn$1);
                  if (exn$1 === caml_builtin_exceptions.not_found || exn$1[0] === caml_builtin_exceptions.failure) {
                    match$13 = undefined;
                  } else {
                    throw exn$1;
                  }
                }
                if (match$13 !== undefined) {
                  var match$16 = match$13;
                  var next_ind$1 = match$16[0];
                  var match$17 = parse_literal(next_ind$1, next_ind$1, end_ind$2);
                  return /* Fmt_EBB */[/* Formatting_lit */block.__(17, [
                              match$16[1],
                              match$17[0]
                            ])];
                } else {
                  var match$18 = parse_literal(str_ind$2, str_ind$2, end_ind$2);
                  return /* Fmt_EBB */[/* Formatting_lit */block.__(17, [
                              /* Scan_indic */block.__(2, [/* "<" */60]),
                              match$18[0]
                            ])];
                }
            case 1 :
            case 2 :
            case 3 :
            case 4 :
            case 6 :
            case 7 :
            case 8 :
            case 9 :
            case 10 :
            case 11 :
            case 13 :
            case 15 :
            case 16 :
            case 17 :
            case 18 :
            case 19 :
            case 20 :
            case 21 :
            case 22 :
            case 23 :
            case 24 :
            case 25 :
            case 26 :
            case 29 :
            case 30 :
                break;
            case 31 :
                var beg_ind$6 = str_ind + 1 | 0;
                var match$19 = parse_literal(beg_ind$6, beg_ind$6, end_ind);
                return /* Fmt_EBB */[/* Formatting_lit */block.__(17, [
                            /* FFlush */2,
                            match$19[0]
                          ])];
            case 32 :
                var beg_ind$7 = str_ind + 1 | 0;
                var match$20 = parse_literal(beg_ind$7, beg_ind$7, end_ind);
                return /* Fmt_EBB */[/* Formatting_lit */block.__(17, [
                            /* Escaped_at */5,
                            match$20[0]
                          ])];
            
          }
        }
        
      } else {
        var beg_ind$8 = str_ind + 1 | 0;
        var match$21 = parse_literal(beg_ind$8, beg_ind$8, end_ind);
        return /* Fmt_EBB */[/* Formatting_lit */block.__(17, [
                    /* Force_newline */3,
                    match$21[0]
                  ])];
      }
      var beg_ind$9 = str_ind + 1 | 0;
      var match$22 = parse_literal(beg_ind$9, beg_ind$9, end_ind);
      return /* Fmt_EBB */[/* Formatting_lit */block.__(17, [
                  /* Scan_indic */block.__(2, [c]),
                  match$22[0]
                ])];
    }
  };
  var add_literal = function (lit_start, str_ind, fmt) {
    var size = str_ind - lit_start | 0;
    if (size !== 0) {
      if (size !== 1) {
        return /* Fmt_EBB */[/* String_literal */block.__(11, [
                    string.sub(str, lit_start, size),
                    fmt
                  ])];
      } else {
        return /* Fmt_EBB */[/* Char_literal */block.__(12, [
                    caml_string.get(str, lit_start),
                    fmt
                  ])];
      }
    } else {
      return /* Fmt_EBB */[fmt];
    }
  };
  var parse_format = function (pct_ind, end_ind) {
    var pct_ind$1 = pct_ind;
    var str_ind = pct_ind + 1 | 0;
    var end_ind$1 = end_ind;
    if (str_ind === end_ind$1) {
      invalid_format_message(end_ind$1, "unexpected end of format");
    }
    var match = caml_string.get(str, str_ind);
    if (match !== 95) {
      return parse_flags(pct_ind$1, str_ind, end_ind$1, false);
    } else {
      return parse_flags(pct_ind$1, str_ind + 1 | 0, end_ind$1, true);
    }
  };
  var parse_literal = function (lit_start, _str_ind, end_ind) {
    while(true) {
      var str_ind = _str_ind;
      if (str_ind === end_ind) {
        return add_literal(lit_start, str_ind, /* End_of_format */0);
      } else {
        var match = caml_string.get(str, str_ind);
        if (match !== 37) {
          if (match !== 64) {
            _str_ind = str_ind + 1 | 0;
            continue ;
          } else {
            var match$1 = parse_after_at(str_ind + 1 | 0, end_ind);
            return add_literal(lit_start, str_ind, match$1[0]);
          }
        } else {
          var match$2 = parse_format(str_ind, end_ind);
          return add_literal(lit_start, str_ind, match$2[0]);
        }
      }
    }  };
  var parse_spaces = function (_str_ind, end_ind) {
    while(true) {
      var str_ind = _str_ind;
      if (str_ind === end_ind) {
        invalid_format_message(end_ind, "unexpected end of format");
      }
      if (caml_string.get(str, str_ind) === /* " " */32) {
        _str_ind = str_ind + 1 | 0;
        continue ;
      } else {
        return str_ind;
      }
    }  };
  var parse_flags = function (pct_ind, str_ind, end_ind, ign) {
    var zero = {
      contents: false
    };
    var minus = {
      contents: false
    };
    var plus = {
      contents: false
    };
    var space = {
      contents: false
    };
    var hash = {
      contents: false
    };
    var set_flag = function (str_ind, flag) {
      if (flag.contents && !legacy_behavior$1) {
        curry._3(failwith_message(/* Format */[
                  /* String_literal */block.__(11, [
                      "invalid format ",
                      /* Caml_string */block.__(3, [
                          /* No_padding */0,
                          /* String_literal */block.__(11, [
                              ": at character number ",
                              /* Int */block.__(4, [
                                  /* Int_d */0,
                                  /* No_padding */0,
                                  /* No_precision */0,
                                  /* String_literal */block.__(11, [
                                      ", duplicate flag ",
                                      /* Caml_char */block.__(1, [/* End_of_format */0])
                                    ])
                                ])
                            ])
                        ])
                    ]),
                  "invalid format %S: at character number %d, duplicate flag %C"
                ]), str, str_ind, caml_string.get(str, str_ind));
      }
      flag.contents = true;
      return /* () */0;
    };
    var _str_ind = str_ind;
    while(true) {
      var str_ind$1 = _str_ind;
      if (str_ind$1 === end_ind) {
        invalid_format_message(end_ind, "unexpected end of format");
      }
      var match = caml_string.get(str, str_ind$1);
      switch (match) {
        case 32 :
            set_flag(str_ind$1, space);
            _str_ind = str_ind$1 + 1 | 0;
            continue ;
        case 35 :
            set_flag(str_ind$1, hash);
            _str_ind = str_ind$1 + 1 | 0;
            continue ;
        case 43 :
            set_flag(str_ind$1, plus);
            _str_ind = str_ind$1 + 1 | 0;
            continue ;
        case 45 :
            set_flag(str_ind$1, minus);
            _str_ind = str_ind$1 + 1 | 0;
            continue ;
        case 33 :
        case 34 :
        case 36 :
        case 37 :
        case 38 :
        case 39 :
        case 40 :
        case 41 :
        case 42 :
        case 44 :
        case 46 :
        case 47 :
            break;
        case 48 :
            set_flag(str_ind$1, zero);
            _str_ind = str_ind$1 + 1 | 0;
            continue ;
          
      }
      var pct_ind$1 = pct_ind;
      var str_ind$2 = str_ind$1;
      var end_ind$1 = end_ind;
      var zero$1 = zero.contents;
      var minus$1 = minus.contents;
      var plus$1 = plus.contents;
      var hash$1 = hash.contents;
      var space$1 = space.contents;
      var ign$1 = ign;
      if (str_ind$2 === end_ind$1) {
        invalid_format_message(end_ind$1, "unexpected end of format");
      }
      var padty = zero$1 ? (
          minus$1 ? (
              legacy_behavior$1 ? /* Left */0 : incompatible_flag(pct_ind$1, str_ind$2, /* "-" */45, "0")
            ) : /* Zeros */2
        ) : (
          minus$1 ? /* Left */0 : /* Right */1
        );
      var match$1 = caml_string.get(str, str_ind$2);
      if (match$1 >= 48) {
        if (match$1 < 58) {
          var match$2 = parse_positive(str_ind$2, end_ind$1, 0);
          return parse_after_padding(pct_ind$1, match$2[0], end_ind$1, minus$1, plus$1, hash$1, space$1, ign$1, /* Lit_padding */block.__(0, [
                        padty,
                        match$2[1]
                      ]));
        }
        
      } else if (match$1 === 42) {
        return parse_after_padding(pct_ind$1, str_ind$2 + 1 | 0, end_ind$1, minus$1, plus$1, hash$1, space$1, ign$1, /* Arg_padding */block.__(1, [padty]));
      }
      switch (padty) {
        case /* Left */0 :
            if (!legacy_behavior$1) {
              invalid_format_without(str_ind$2 - 1 | 0, /* "-" */45, "padding");
            }
            return parse_after_padding(pct_ind$1, str_ind$2, end_ind$1, minus$1, plus$1, hash$1, space$1, ign$1, /* No_padding */0);
        case /* Right */1 :
            return parse_after_padding(pct_ind$1, str_ind$2, end_ind$1, minus$1, plus$1, hash$1, space$1, ign$1, /* No_padding */0);
        case /* Zeros */2 :
            return parse_after_padding(pct_ind$1, str_ind$2, end_ind$1, minus$1, plus$1, hash$1, space$1, ign$1, /* Lit_padding */block.__(0, [
                          /* Right */1,
                          0
                        ]));
        
      }
    }  };
  var search_subformat_end = function (_str_ind, end_ind, c) {
    while(true) {
      var str_ind = _str_ind;
      if (str_ind === end_ind) {
        curry._3(failwith_message(/* Format */[
                  /* String_literal */block.__(11, [
                      "invalid format ",
                      /* Caml_string */block.__(3, [
                          /* No_padding */0,
                          /* String_literal */block.__(11, [
                              ": unclosed sub-format, expected \"",
                              /* Char_literal */block.__(12, [
                                  /* "%" */37,
                                  /* Char */block.__(0, [/* String_literal */block.__(11, [
                                          "\" at character number ",
                                          /* Int */block.__(4, [
                                              /* Int_d */0,
                                              /* No_padding */0,
                                              /* No_precision */0,
                                              /* End_of_format */0
                                            ])
                                        ])])
                                ])
                            ])
                        ])
                    ]),
                  "invalid format %S: unclosed sub-format, expected \"%%%c\" at character number %d"
                ]), str, c, end_ind);
      }
      var match = caml_string.get(str, str_ind);
      if (match !== 37) {
        _str_ind = str_ind + 1 | 0;
        continue ;
      } else {
        if ((str_ind + 1 | 0) === end_ind) {
          invalid_format_message(end_ind, "unexpected end of format");
        }
        if (caml_string.get(str, str_ind + 1 | 0) === c) {
          return str_ind;
        } else {
          var match$1 = caml_string.get(str, str_ind + 1 | 0);
          if (match$1 >= 95) {
            if (match$1 >= 123) {
              if (match$1 < 126) {
                switch (match$1 - 123 | 0) {
                  case 0 :
                      var sub_end = search_subformat_end(str_ind + 2 | 0, end_ind, /* "}" */125);
                      _str_ind = sub_end + 2 | 0;
                      continue ;
                  case 1 :
                      break;
                  case 2 :
                      return expected_character(str_ind + 1 | 0, "character ')'", /* "}" */125);
                  
                }
              }
              
            } else if (match$1 < 96) {
              if ((str_ind + 2 | 0) === end_ind) {
                invalid_format_message(end_ind, "unexpected end of format");
              }
              var match$2 = caml_string.get(str, str_ind + 2 | 0);
              if (match$2 !== 40) {
                if (match$2 !== 123) {
                  _str_ind = str_ind + 3 | 0;
                  continue ;
                } else {
                  var sub_end$1 = search_subformat_end(str_ind + 3 | 0, end_ind, /* "}" */125);
                  _str_ind = sub_end$1 + 2 | 0;
                  continue ;
                }
              } else {
                var sub_end$2 = search_subformat_end(str_ind + 3 | 0, end_ind, /* ")" */41);
                _str_ind = sub_end$2 + 2 | 0;
                continue ;
              }
            }
            
          } else if (match$1 !== 40) {
            if (match$1 === 41) {
              return expected_character(str_ind + 1 | 0, "character '}'", /* ")" */41);
            }
            
          } else {
            var sub_end$3 = search_subformat_end(str_ind + 2 | 0, end_ind, /* ")" */41);
            _str_ind = sub_end$3 + 2 | 0;
            continue ;
          }
          _str_ind = str_ind + 2 | 0;
          continue ;
        }
      }
    }  };
  var parse_positive = function (_str_ind, end_ind, _acc) {
    while(true) {
      var acc = _acc;
      var str_ind = _str_ind;
      if (str_ind === end_ind) {
        invalid_format_message(end_ind, "unexpected end of format");
      }
      var c = caml_string.get(str, str_ind);
      if (c > 57 || c < 48) {
        return /* tuple */[
                str_ind,
                acc
              ];
      } else {
        var new_acc = caml_int32.imul(acc, 10) + (c - /* "0" */48 | 0) | 0;
        _acc = new_acc;
        _str_ind = str_ind + 1 | 0;
        continue ;
      }
    }  };
  var check_open_box = function (fmt) {
    if (typeof fmt === "number" || !(fmt.tag === /* String_literal */11 && typeof fmt[1] === "number")) {
      return /* () */0;
    } else {
      try {
        open_box_of_string(fmt[0]);
        return /* () */0;
      }
      catch (raw_exn){
        var exn = caml_js_exceptions.internalToOCamlException(raw_exn);
        if (exn[0] === caml_builtin_exceptions.failure) {
          return /* () */0;
        } else {
          throw exn;
        }
      }
    }
  };
  var parse_conversion = function (pct_ind, str_ind, end_ind, plus, hash, space, ign, pad, prec, padprec, symb) {
    var plus_used = false;
    var hash_used = false;
    var space_used = false;
    var ign_used = {
      contents: false
    };
    var pad_used = {
      contents: false
    };
    var prec_used = {
      contents: false
    };
    var get_int_pad = function (param) {
      pad_used.contents = true;
      prec_used.contents = true;
      if (typeof prec === "number" && prec === 0) {
        return pad;
      }
      if (typeof pad === "number") {
        return /* No_padding */0;
      } else if (pad.tag) {
        if (pad[0] >= 2) {
          if (legacy_behavior$1) {
            return /* Arg_padding */block.__(1, [/* Right */1]);
          } else {
            return incompatible_flag(pct_ind, str_ind, /* "0" */48, "precision");
          }
        } else {
          return pad;
        }
      } else if (pad[0] >= 2) {
        if (legacy_behavior$1) {
          return /* Lit_padding */block.__(0, [
                    /* Right */1,
                    pad[1]
                  ]);
        } else {
          return incompatible_flag(pct_ind, str_ind, /* "0" */48, "precision");
        }
      } else {
        return pad;
      }
    };
    var check_no_0 = function (symb, pad) {
      if (typeof pad === "number") {
        return pad;
      } else if (pad.tag) {
        if (pad[0] >= 2) {
          if (legacy_behavior$1) {
            return /* Arg_padding */block.__(1, [/* Right */1]);
          } else {
            return incompatible_flag(pct_ind, str_ind, symb, "0");
          }
        } else {
          return pad;
        }
      } else if (pad[0] >= 2) {
        if (legacy_behavior$1) {
          return /* Lit_padding */block.__(0, [
                    /* Right */1,
                    pad[1]
                  ]);
        } else {
          return incompatible_flag(pct_ind, str_ind, symb, "0");
        }
      } else {
        return pad;
      }
    };
    var opt_of_pad = function (c, pad) {
      if (typeof pad === "number") {
        return ;
      } else if (pad.tag) {
        return incompatible_flag(pct_ind, str_ind, c, "'*'");
      } else {
        switch (pad[0]) {
          case /* Left */0 :
              if (legacy_behavior$1) {
                return pad[1];
              } else {
                return incompatible_flag(pct_ind, str_ind, c, "'-'");
              }
          case /* Right */1 :
              return pad[1];
          case /* Zeros */2 :
              if (legacy_behavior$1) {
                return pad[1];
              } else {
                return incompatible_flag(pct_ind, str_ind, c, "'0'");
              }
          
        }
      }
    };
    var get_prec_opt = function (param) {
      prec_used.contents = true;
      if (typeof prec === "number") {
        if (prec !== 0) {
          return incompatible_flag(pct_ind, str_ind, /* "_" */95, "'*'");
        } else {
          return ;
        }
      } else {
        return prec[0];
      }
    };
    var fmt_result;
    var exit = 0;
    var exit$1 = 0;
    var exit$2 = 0;
    if (symb >= 124) {
      exit$1 = 6;
    } else {
      switch (symb) {
        case 33 :
            var match = parse_literal(str_ind, str_ind, end_ind);
            fmt_result = /* Fmt_EBB */[/* Flush */block.__(10, [match[0]])];
            break;
        case 40 :
            var sub_end = search_subformat_end(str_ind, end_ind, /* ")" */41);
            var beg_ind = sub_end + 2 | 0;
            var match$1 = parse_literal(beg_ind, beg_ind, end_ind);
            var fmt_rest = match$1[0];
            var match$2 = parse_literal(str_ind, str_ind, sub_end);
            var sub_fmtty = fmtty_of_fmt(match$2[0]);
            if (ign_used.contents = true, ign) {
              var ignored_000 = opt_of_pad(/* "_" */95, (pad_used.contents = true, pad));
              var ignored = /* Ignored_format_subst */block.__(9, [
                  ignored_000,
                  sub_fmtty
                ]);
              fmt_result = /* Fmt_EBB */[/* Ignored_param */block.__(23, [
                    ignored,
                    fmt_rest
                  ])];
            } else {
              fmt_result = /* Fmt_EBB */[/* Format_subst */block.__(14, [
                    opt_of_pad(/* "(" */40, (pad_used.contents = true, pad)),
                    sub_fmtty,
                    fmt_rest
                  ])];
            }
            break;
        case 44 :
            fmt_result = parse_literal(str_ind, str_ind, end_ind);
            break;
        case 37 :
        case 64 :
            exit$1 = 4;
            break;
        case 67 :
            var match$3 = parse_literal(str_ind, str_ind, end_ind);
            var fmt_rest$1 = match$3[0];
            fmt_result = (ign_used.contents = true, ign) ? /* Fmt_EBB */[/* Ignored_param */block.__(23, [
                    /* Ignored_caml_char */1,
                    fmt_rest$1
                  ])] : /* Fmt_EBB */[/* Caml_char */block.__(1, [fmt_rest$1])];
            break;
        case 78 :
            var match$4 = parse_literal(str_ind, str_ind, end_ind);
            var fmt_rest$2 = match$4[0];
            if (ign_used.contents = true, ign) {
              var ignored$1 = /* Ignored_scan_get_counter */block.__(11, [/* Token_counter */2]);
              fmt_result = /* Fmt_EBB */[/* Ignored_param */block.__(23, [
                    ignored$1,
                    fmt_rest$2
                  ])];
            } else {
              fmt_result = /* Fmt_EBB */[/* Scan_get_counter */block.__(21, [
                    /* Token_counter */2,
                    fmt_rest$2
                  ])];
            }
            break;
        case 83 :
            var pad$1 = check_no_0(symb, (pad_used.contents = true, padprec));
            var match$5 = parse_literal(str_ind, str_ind, end_ind);
            var fmt_rest$3 = match$5[0];
            if (ign_used.contents = true, ign) {
              var ignored$2 = /* Ignored_caml_string */block.__(1, [opt_of_pad(/* "_" */95, (pad_used.contents = true, padprec))]);
              fmt_result = /* Fmt_EBB */[/* Ignored_param */block.__(23, [
                    ignored$2,
                    fmt_rest$3
                  ])];
            } else {
              var match$6 = make_padding_fmt_ebb(pad$1, fmt_rest$3);
              fmt_result = /* Fmt_EBB */[/* Caml_string */block.__(3, [
                    match$6[0],
                    match$6[1]
                  ])];
            }
            break;
        case 91 :
            var match$7 = parse_char_set(str_ind, end_ind);
            var char_set = match$7[1];
            var next_ind = match$7[0];
            var match$8 = parse_literal(next_ind, next_ind, end_ind);
            var fmt_rest$4 = match$8[0];
            if (ign_used.contents = true, ign) {
              var ignored_000$1 = opt_of_pad(/* "_" */95, (pad_used.contents = true, pad));
              var ignored$3 = /* Ignored_scan_char_set */block.__(10, [
                  ignored_000$1,
                  char_set
                ]);
              fmt_result = /* Fmt_EBB */[/* Ignored_param */block.__(23, [
                    ignored$3,
                    fmt_rest$4
                  ])];
            } else {
              fmt_result = /* Fmt_EBB */[/* Scan_char_set */block.__(20, [
                    opt_of_pad(/* "[" */91, (pad_used.contents = true, pad)),
                    char_set,
                    fmt_rest$4
                  ])];
            }
            break;
        case 32 :
        case 35 :
        case 43 :
        case 45 :
        case 95 :
            exit$1 = 5;
            break;
        case 97 :
            var match$9 = parse_literal(str_ind, str_ind, end_ind);
            fmt_result = /* Fmt_EBB */[/* Alpha */block.__(15, [match$9[0]])];
            break;
        case 66 :
        case 98 :
            exit$1 = 3;
            break;
        case 99 :
            var char_format = function (fmt_rest) {
              if (ign_used.contents = true, ign) {
                return /* Fmt_EBB */[/* Ignored_param */block.__(23, [
                            /* Ignored_char */0,
                            fmt_rest
                          ])];
              } else {
                return /* Fmt_EBB */[/* Char */block.__(0, [fmt_rest])];
              }
            };
            var scan_format = function (fmt_rest) {
              if (ign_used.contents = true, ign) {
                return /* Fmt_EBB */[/* Ignored_param */block.__(23, [
                            /* Ignored_scan_next_char */3,
                            fmt_rest
                          ])];
              } else {
                return /* Fmt_EBB */[/* Scan_next_char */block.__(22, [fmt_rest])];
              }
            };
            var match$10 = parse_literal(str_ind, str_ind, end_ind);
            var fmt_rest$5 = match$10[0];
            var match$11 = opt_of_pad(/* "c" */99, (pad_used.contents = true, pad));
            fmt_result = match$11 !== undefined ? (
                match$11 !== 0 ? (
                    legacy_behavior$1 ? char_format(fmt_rest$5) : invalid_format_message(str_ind, "non-zero widths are unsupported for %c conversions")
                  ) : scan_format(fmt_rest$5)
              ) : char_format(fmt_rest$5);
            break;
        case 69 :
        case 70 :
        case 71 :
        case 72 :
        case 101 :
        case 102 :
        case 103 :
        case 104 :
            exit$1 = 2;
            break;
        case 76 :
        case 108 :
        case 110 :
            exit$2 = 8;
            break;
        case 114 :
            var match$12 = parse_literal(str_ind, str_ind, end_ind);
            var fmt_rest$6 = match$12[0];
            fmt_result = (ign_used.contents = true, ign) ? /* Fmt_EBB */[/* Ignored_param */block.__(23, [
                    /* Ignored_reader */2,
                    fmt_rest$6
                  ])] : /* Fmt_EBB */[/* Reader */block.__(19, [fmt_rest$6])];
            break;
        case 115 :
            var pad$2 = check_no_0(symb, (pad_used.contents = true, padprec));
            var match$13 = parse_literal(str_ind, str_ind, end_ind);
            var fmt_rest$7 = match$13[0];
            if (ign_used.contents = true, ign) {
              var ignored$4 = /* Ignored_string */block.__(0, [opt_of_pad(/* "_" */95, (pad_used.contents = true, padprec))]);
              fmt_result = /* Fmt_EBB */[/* Ignored_param */block.__(23, [
                    ignored$4,
                    fmt_rest$7
                  ])];
            } else {
              var match$14 = make_padding_fmt_ebb(pad$2, fmt_rest$7);
              fmt_result = /* Fmt_EBB */[/* String */block.__(2, [
                    match$14[0],
                    match$14[1]
                  ])];
            }
            break;
        case 116 :
            var match$15 = parse_literal(str_ind, str_ind, end_ind);
            fmt_result = /* Fmt_EBB */[/* Theta */block.__(16, [match$15[0]])];
            break;
        case 88 :
        case 100 :
        case 105 :
        case 111 :
        case 117 :
        case 120 :
            exit$2 = 7;
            break;
        case 0 :
        case 1 :
        case 2 :
        case 3 :
        case 4 :
        case 5 :
        case 6 :
        case 7 :
        case 8 :
        case 9 :
        case 10 :
        case 11 :
        case 12 :
        case 13 :
        case 14 :
        case 15 :
        case 16 :
        case 17 :
        case 18 :
        case 19 :
        case 20 :
        case 21 :
        case 22 :
        case 23 :
        case 24 :
        case 25 :
        case 26 :
        case 27 :
        case 28 :
        case 29 :
        case 30 :
        case 31 :
        case 34 :
        case 36 :
        case 38 :
        case 39 :
        case 41 :
        case 42 :
        case 46 :
        case 47 :
        case 48 :
        case 49 :
        case 50 :
        case 51 :
        case 52 :
        case 53 :
        case 54 :
        case 55 :
        case 56 :
        case 57 :
        case 58 :
        case 59 :
        case 60 :
        case 61 :
        case 62 :
        case 63 :
        case 65 :
        case 68 :
        case 73 :
        case 74 :
        case 75 :
        case 77 :
        case 79 :
        case 80 :
        case 81 :
        case 82 :
        case 84 :
        case 85 :
        case 86 :
        case 87 :
        case 89 :
        case 90 :
        case 92 :
        case 93 :
        case 94 :
        case 96 :
        case 106 :
        case 107 :
        case 109 :
        case 112 :
        case 113 :
        case 118 :
        case 119 :
        case 121 :
        case 122 :
            exit$1 = 6;
            break;
        case 123 :
            var sub_end$1 = search_subformat_end(str_ind, end_ind, /* "}" */125);
            var match$16 = parse_literal(str_ind, str_ind, sub_end$1);
            var beg_ind$1 = sub_end$1 + 2 | 0;
            var match$17 = parse_literal(beg_ind$1, beg_ind$1, end_ind);
            var fmt_rest$8 = match$17[0];
            var sub_fmtty$1 = fmtty_of_fmt(match$16[0]);
            if (ign_used.contents = true, ign) {
              var ignored_000$2 = opt_of_pad(/* "_" */95, (pad_used.contents = true, pad));
              var ignored$5 = /* Ignored_format_arg */block.__(8, [
                  ignored_000$2,
                  sub_fmtty$1
                ]);
              fmt_result = /* Fmt_EBB */[/* Ignored_param */block.__(23, [
                    ignored$5,
                    fmt_rest$8
                  ])];
            } else {
              fmt_result = /* Fmt_EBB */[/* Format_arg */block.__(13, [
                    opt_of_pad(/* "{" */123, (pad_used.contents = true, pad)),
                    sub_fmtty$1,
                    fmt_rest$8
                  ])];
            }
            break;
        
      }
    }
    switch (exit$2) {
      case 7 :
          plus_used = true;
          hash_used = true;
          space_used = true;
          var iconv = compute_int_conv(pct_ind, str_ind, plus, hash, space, symb);
          var match$18 = parse_literal(str_ind, str_ind, end_ind);
          var fmt_rest$9 = match$18[0];
          if (ign_used.contents = true, ign) {
            var ignored_001 = opt_of_pad(/* "_" */95, (pad_used.contents = true, pad));
            var ignored$6 = /* Ignored_int */block.__(2, [
                iconv,
                ignored_001
              ]);
            fmt_result = /* Fmt_EBB */[/* Ignored_param */block.__(23, [
                  ignored$6,
                  fmt_rest$9
                ])];
          } else {
            var match$19 = make_padprec_fmt_ebb(get_int_pad(), (prec_used.contents = true, prec), fmt_rest$9);
            fmt_result = /* Fmt_EBB */[/* Int */block.__(4, [
                  iconv,
                  match$19[0],
                  match$19[1],
                  match$19[2]
                ])];
          }
          break;
      case 8 :
          if (str_ind === end_ind || !is_int_base(caml_string.get(str, str_ind))) {
            var match$20 = parse_literal(str_ind, str_ind, end_ind);
            var fmt_rest$10 = match$20[0];
            var counter = counter_of_char(symb);
            if (ign_used.contents = true, ign) {
              var ignored$7 = /* Ignored_scan_get_counter */block.__(11, [counter]);
              fmt_result = /* Fmt_EBB */[/* Ignored_param */block.__(23, [
                    ignored$7,
                    fmt_rest$10
                  ])];
            } else {
              fmt_result = /* Fmt_EBB */[/* Scan_get_counter */block.__(21, [
                    counter,
                    fmt_rest$10
                  ])];
            }
          } else {
            exit$1 = 6;
          }
          break;
      
    }
    switch (exit$1) {
      case 2 :
          plus_used = true;
          space_used = true;
          var fconv = compute_float_conv(pct_ind, str_ind, plus, space, symb);
          var match$21 = parse_literal(str_ind, str_ind, end_ind);
          var fmt_rest$11 = match$21[0];
          if (ign_used.contents = true, ign) {
            var ignored_000$3 = opt_of_pad(/* "_" */95, (pad_used.contents = true, pad));
            var ignored_001$1 = get_prec_opt();
            var ignored$8 = /* Ignored_float */block.__(6, [
                ignored_000$3,
                ignored_001$1
              ]);
            fmt_result = /* Fmt_EBB */[/* Ignored_param */block.__(23, [
                  ignored$8,
                  fmt_rest$11
                ])];
          } else {
            var match$22 = make_padprec_fmt_ebb((pad_used.contents = true, pad), (prec_used.contents = true, prec), fmt_rest$11);
            fmt_result = /* Fmt_EBB */[/* Float */block.__(8, [
                  fconv,
                  match$22[0],
                  match$22[1],
                  match$22[2]
                ])];
          }
          break;
      case 3 :
          var pad$3 = check_no_0(symb, (pad_used.contents = true, padprec));
          var match$23 = parse_literal(str_ind, str_ind, end_ind);
          var fmt_rest$12 = match$23[0];
          if (ign_used.contents = true, ign) {
            var ignored$9 = /* Ignored_bool */block.__(7, [opt_of_pad(/* "_" */95, (pad_used.contents = true, padprec))]);
            fmt_result = /* Fmt_EBB */[/* Ignored_param */block.__(23, [
                  ignored$9,
                  fmt_rest$12
                ])];
          } else {
            var match$24 = make_padding_fmt_ebb(pad$3, fmt_rest$12);
            fmt_result = /* Fmt_EBB */[/* Bool */block.__(9, [
                  match$24[0],
                  match$24[1]
                ])];
          }
          break;
      case 4 :
          var match$25 = parse_literal(str_ind, str_ind, end_ind);
          fmt_result = /* Fmt_EBB */[/* Char_literal */block.__(12, [
                symb,
                match$25[0]
              ])];
          break;
      case 5 :
          fmt_result = curry._3(failwith_message(/* Format */[
                    /* String_literal */block.__(11, [
                        "invalid format ",
                        /* Caml_string */block.__(3, [
                            /* No_padding */0,
                            /* String_literal */block.__(11, [
                                ": at character number ",
                                /* Int */block.__(4, [
                                    /* Int_d */0,
                                    /* No_padding */0,
                                    /* No_precision */0,
                                    /* String_literal */block.__(11, [
                                        ", flag ",
                                        /* Caml_char */block.__(1, [/* String_literal */block.__(11, [
                                                " is only allowed after the '",
                                                /* Char_literal */block.__(12, [
                                                    /* "%" */37,
                                                    /* String_literal */block.__(11, [
                                                        "', before padding and precision",
                                                        /* End_of_format */0
                                                      ])
                                                  ])
                                              ])])
                                      ])
                                  ])
                              ])
                          ])
                      ]),
                    "invalid format %S: at character number %d, flag %C is only allowed after the '%%', before padding and precision"
                  ]), str, pct_ind, symb);
          break;
      case 6 :
          if (symb >= 108) {
            if (symb >= 111) {
              exit = 1;
            } else {
              switch (symb - 108 | 0) {
                case 0 :
                    plus_used = true;
                    hash_used = true;
                    space_used = true;
                    var iconv$1 = compute_int_conv(pct_ind, str_ind + 1 | 0, plus, hash, space, caml_string.get(str, str_ind));
                    var beg_ind$2 = str_ind + 1 | 0;
                    var match$26 = parse_literal(beg_ind$2, beg_ind$2, end_ind);
                    var fmt_rest$13 = match$26[0];
                    if (ign_used.contents = true, ign) {
                      var ignored_001$2 = opt_of_pad(/* "_" */95, (pad_used.contents = true, pad));
                      var ignored$10 = /* Ignored_int32 */block.__(3, [
                          iconv$1,
                          ignored_001$2
                        ]);
                      fmt_result = /* Fmt_EBB */[/* Ignored_param */block.__(23, [
                            ignored$10,
                            fmt_rest$13
                          ])];
                    } else {
                      var match$27 = make_padprec_fmt_ebb(get_int_pad(), (prec_used.contents = true, prec), fmt_rest$13);
                      fmt_result = /* Fmt_EBB */[/* Int32 */block.__(5, [
                            iconv$1,
                            match$27[0],
                            match$27[1],
                            match$27[2]
                          ])];
                    }
                    break;
                case 1 :
                    exit = 1;
                    break;
                case 2 :
                    plus_used = true;
                    hash_used = true;
                    space_used = true;
                    var iconv$2 = compute_int_conv(pct_ind, str_ind + 1 | 0, plus, hash, space, caml_string.get(str, str_ind));
                    var beg_ind$3 = str_ind + 1 | 0;
                    var match$28 = parse_literal(beg_ind$3, beg_ind$3, end_ind);
                    var fmt_rest$14 = match$28[0];
                    if (ign_used.contents = true, ign) {
                      var ignored_001$3 = opt_of_pad(/* "_" */95, (pad_used.contents = true, pad));
                      var ignored$11 = /* Ignored_nativeint */block.__(4, [
                          iconv$2,
                          ignored_001$3
                        ]);
                      fmt_result = /* Fmt_EBB */[/* Ignored_param */block.__(23, [
                            ignored$11,
                            fmt_rest$14
                          ])];
                    } else {
                      var match$29 = make_padprec_fmt_ebb(get_int_pad(), (prec_used.contents = true, prec), fmt_rest$14);
                      fmt_result = /* Fmt_EBB */[/* Nativeint */block.__(6, [
                            iconv$2,
                            match$29[0],
                            match$29[1],
                            match$29[2]
                          ])];
                    }
                    break;
                
              }
            }
          } else if (symb !== 76) {
            exit = 1;
          } else {
            plus_used = true;
            hash_used = true;
            space_used = true;
            var iconv$3 = compute_int_conv(pct_ind, str_ind + 1 | 0, plus, hash, space, caml_string.get(str, str_ind));
            var beg_ind$4 = str_ind + 1 | 0;
            var match$30 = parse_literal(beg_ind$4, beg_ind$4, end_ind);
            var fmt_rest$15 = match$30[0];
            if (ign_used.contents = true, ign) {
              var ignored_001$4 = opt_of_pad(/* "_" */95, (pad_used.contents = true, pad));
              var ignored$12 = /* Ignored_int64 */block.__(5, [
                  iconv$3,
                  ignored_001$4
                ]);
              fmt_result = /* Fmt_EBB */[/* Ignored_param */block.__(23, [
                    ignored$12,
                    fmt_rest$15
                  ])];
            } else {
              var match$31 = make_padprec_fmt_ebb(get_int_pad(), (prec_used.contents = true, prec), fmt_rest$15);
              fmt_result = /* Fmt_EBB */[/* Int64 */block.__(7, [
                    iconv$3,
                    match$31[0],
                    match$31[1],
                    match$31[2]
                  ])];
            }
          }
          break;
      
    }
    if (exit === 1) {
      fmt_result = curry._3(failwith_message(/* Format */[
                /* String_literal */block.__(11, [
                    "invalid format ",
                    /* Caml_string */block.__(3, [
                        /* No_padding */0,
                        /* String_literal */block.__(11, [
                            ": at character number ",
                            /* Int */block.__(4, [
                                /* Int_d */0,
                                /* No_padding */0,
                                /* No_precision */0,
                                /* String_literal */block.__(11, [
                                    ", invalid conversion \"",
                                    /* Char_literal */block.__(12, [
                                        /* "%" */37,
                                        /* Char */block.__(0, [/* Char_literal */block.__(12, [
                                                /* "\"" */34,
                                                /* End_of_format */0
                                              ])])
                                      ])
                                  ])
                              ])
                          ])
                      ])
                  ]),
                "invalid format %S: at character number %d, invalid conversion \"%%%c\""
              ]), str, str_ind - 1 | 0, symb);
    }
    if (!legacy_behavior$1) {
      if (!plus_used && plus) {
        incompatible_flag(pct_ind, str_ind, symb, "'+'");
      }
      if (!hash_used && hash) {
        incompatible_flag(pct_ind, str_ind, symb, "'#'");
      }
      if (!space_used && space) {
        incompatible_flag(pct_ind, str_ind, symb, "' '");
      }
      if (!pad_used.contents && caml_obj.caml_notequal(/* Padding_EBB */[pad], /* Padding_EBB */[/* No_padding */0])) {
        incompatible_flag(pct_ind, str_ind, symb, "`padding'");
      }
      if (!prec_used.contents && caml_obj.caml_notequal(/* Precision_EBB */[prec], /* Precision_EBB */[/* No_precision */0])) {
        incompatible_flag(pct_ind, str_ind, ign ? /* "_" */95 : symb, "`precision'");
      }
      if (ign && plus) {
        incompatible_flag(pct_ind, str_ind, /* "_" */95, "'+'");
      }
      
    }
    if (!ign_used.contents && ign) {
      var exit$3 = 0;
      if (symb >= 38) {
        if (symb !== 44) {
          if (symb !== 64 || !legacy_behavior$1) {
            exit$3 = 1;
          }
          
        } else if (!legacy_behavior$1) {
          exit$3 = 1;
        }
        
      } else if (symb !== 33) {
        if (!(symb >= 37 && legacy_behavior$1)) {
          exit$3 = 1;
        }
        
      } else if (!legacy_behavior$1) {
        exit$3 = 1;
      }
      if (exit$3 === 1) {
        incompatible_flag(pct_ind, str_ind, symb, "'_'");
      }
      
    }
    return fmt_result;
  };
  var parse_integer = function (str_ind, end_ind) {
    if (str_ind === end_ind) {
      invalid_format_message(end_ind, "unexpected end of format");
    }
    var match = caml_string.get(str, str_ind);
    if (match >= 48) {
      if (match >= 58) {
        throw [
              caml_builtin_exceptions.assert_failure,
              /* tuple */[
                "camlinternalFormat.ml",
                2814,
                11
              ]
            ];
      }
      return parse_positive(str_ind, end_ind, 0);
    } else {
      if (match !== 45) {
        throw [
              caml_builtin_exceptions.assert_failure,
              /* tuple */[
                "camlinternalFormat.ml",
                2814,
                11
              ]
            ];
      }
      if ((str_ind + 1 | 0) === end_ind) {
        invalid_format_message(end_ind, "unexpected end of format");
      }
      var c = caml_string.get(str, str_ind + 1 | 0);
      if (c > 57 || c < 48) {
        return expected_character(str_ind + 1 | 0, "digit", c);
      } else {
        var match$1 = parse_positive(str_ind + 1 | 0, end_ind, 0);
        return /* tuple */[
                match$1[0],
                -match$1[1] | 0
              ];
      }
    }
  };
  var incompatible_flag = function (pct_ind, str_ind, symb, option) {
    var subfmt = string.sub(str, pct_ind, str_ind - pct_ind | 0);
    return curry._5(failwith_message(/* Format */[
                    /* String_literal */block.__(11, [
                        "invalid format ",
                        /* Caml_string */block.__(3, [
                            /* No_padding */0,
                            /* String_literal */block.__(11, [
                                ": at character number ",
                                /* Int */block.__(4, [
                                    /* Int_d */0,
                                    /* No_padding */0,
                                    /* No_precision */0,
                                    /* String_literal */block.__(11, [
                                        ", ",
                                        /* String */block.__(2, [
                                            /* No_padding */0,
                                            /* String_literal */block.__(11, [
                                                " is incompatible with '",
                                                /* Char */block.__(0, [/* String_literal */block.__(11, [
                                                        "' in sub-format ",
                                                        /* Caml_string */block.__(3, [
                                                            /* No_padding */0,
                                                            /* End_of_format */0
                                                          ])
                                                      ])])
                                              ])
                                          ])
                                      ])
                                  ])
                              ])
                          ])
                      ]),
                    "invalid format %S: at character number %d, %s is incompatible with '%c' in sub-format %S"
                  ]), str, pct_ind, option, symb, subfmt);
  };
  var parse_after_padding = function (pct_ind, str_ind, end_ind, minus, plus, hash, space, ign, pad) {
    if (str_ind === end_ind) {
      invalid_format_message(end_ind, "unexpected end of format");
    }
    var symb = caml_string.get(str, str_ind);
    if (symb !== 46) {
      return parse_conversion(pct_ind, str_ind + 1 | 0, end_ind, plus, hash, space, ign, pad, /* No_precision */0, pad, symb);
    } else {
      var pct_ind$1 = pct_ind;
      var str_ind$1 = str_ind + 1 | 0;
      var end_ind$1 = end_ind;
      var minus$1 = minus;
      var plus$1 = plus;
      var hash$1 = hash;
      var space$1 = space;
      var ign$1 = ign;
      var pad$1 = pad;
      if (str_ind$1 === end_ind$1) {
        invalid_format_message(end_ind$1, "unexpected end of format");
      }
      var parse_literal = function (minus, str_ind) {
        var match = parse_positive(str_ind, end_ind$1, 0);
        return parse_after_precision(pct_ind$1, match[0], end_ind$1, minus, plus$1, hash$1, space$1, ign$1, pad$1, /* Lit_precision */[match[1]]);
      };
      var symb$1 = caml_string.get(str, str_ind$1);
      var exit = 0;
      if (symb$1 >= 48) {
        if (symb$1 < 58) {
          return parse_literal(minus$1, str_ind$1);
        }
        
      } else if (symb$1 >= 42) {
        switch (symb$1 - 42 | 0) {
          case 0 :
              return parse_after_precision(pct_ind$1, str_ind$1 + 1 | 0, end_ind$1, minus$1, plus$1, hash$1, space$1, ign$1, pad$1, /* Arg_precision */1);
          case 1 :
          case 3 :
              exit = 2;
              break;
          
        }
      }
      if (exit === 2 && legacy_behavior$1) {
        return parse_literal(minus$1 || symb$1 === /* "-" */45, str_ind$1 + 1 | 0);
      }
      if (legacy_behavior$1) {
        return parse_after_precision(pct_ind$1, str_ind$1, end_ind$1, minus$1, plus$1, hash$1, space$1, ign$1, pad$1, /* Lit_precision */[0]);
      } else {
        return invalid_format_without(str_ind$1 - 1 | 0, /* "." */46, "precision");
      }
    }
  };
  var is_int_base = function (symb) {
    switch (symb) {
      case 89 :
      case 90 :
      case 91 :
      case 92 :
      case 93 :
      case 94 :
      case 95 :
      case 96 :
      case 97 :
      case 98 :
      case 99 :
      case 101 :
      case 102 :
      case 103 :
      case 104 :
      case 106 :
      case 107 :
      case 108 :
      case 109 :
      case 110 :
      case 112 :
      case 113 :
      case 114 :
      case 115 :
      case 116 :
      case 118 :
      case 119 :
          return false;
      case 88 :
      case 100 :
      case 105 :
      case 111 :
      case 117 :
      case 120 :
          return true;
      default:
        return false;
    }
  };
  var counter_of_char = function (symb) {
    if (symb >= 108) {
      if (symb < 111) {
        switch (symb - 108 | 0) {
          case 0 :
              return /* Line_counter */0;
          case 1 :
              break;
          case 2 :
              return /* Char_counter */1;
          
        }
      }
      
    } else if (symb === 76) {
      return /* Token_counter */2;
    }
    throw [
          caml_builtin_exceptions.assert_failure,
          /* tuple */[
            "camlinternalFormat.ml",
            2876,
            34
          ]
        ];
  };
  var parse_char_set = function (str_ind, end_ind) {
    if (str_ind === end_ind) {
      invalid_format_message(end_ind, "unexpected end of format");
    }
    var char_set = bytes.make(32, /* "\000" */0);
    var add_range = function (c, c$prime) {
      for(var i = c; i <= c$prime; ++i){
        add_in_char_set(char_set, pervasives.char_of_int(i));
      }
      return /* () */0;
    };
    var fail_single_percent = function (str_ind) {
      return curry._2(failwith_message(/* Format */[
                      /* String_literal */block.__(11, [
                          "invalid format ",
                          /* Caml_string */block.__(3, [
                              /* No_padding */0,
                              /* String_literal */block.__(11, [
                                  ": '",
                                  /* Char_literal */block.__(12, [
                                      /* "%" */37,
                                      /* String_literal */block.__(11, [
                                          "' alone is not accepted in character sets, use ",
                                          /* Char_literal */block.__(12, [
                                              /* "%" */37,
                                              /* Char_literal */block.__(12, [
                                                  /* "%" */37,
                                                  /* String_literal */block.__(11, [
                                                      " instead at position ",
                                                      /* Int */block.__(4, [
                                                          /* Int_d */0,
                                                          /* No_padding */0,
                                                          /* No_precision */0,
                                                          /* Char_literal */block.__(12, [
                                                              /* "." */46,
                                                              /* End_of_format */0
                                                            ])
                                                        ])
                                                    ])
                                                ])
                                            ])
                                        ])
                                    ])
                                ])
                            ])
                        ]),
                      "invalid format %S: '%%' alone is not accepted in character sets, use %%%% instead at position %d."
                    ]), str, str_ind);
    };
    var parse_char_set_content = function (_str_ind, end_ind) {
      while(true) {
        var str_ind = _str_ind;
        if (str_ind === end_ind) {
          invalid_format_message(end_ind, "unexpected end of format");
        }
        var c = caml_string.get(str, str_ind);
        if (c !== 45) {
          if (c !== 93) {
            return parse_char_set_after_char(str_ind + 1 | 0, end_ind, c);
          } else {
            return str_ind + 1 | 0;
          }
        } else {
          add_in_char_set(char_set, /* "-" */45);
          _str_ind = str_ind + 1 | 0;
          continue ;
        }
      }    };
    var parse_char_set_after_char = function (_str_ind, end_ind, _c) {
      while(true) {
        var c = _c;
        var str_ind = _str_ind;
        if (str_ind === end_ind) {
          invalid_format_message(end_ind, "unexpected end of format");
        }
        var c$prime = caml_string.get(str, str_ind);
        var exit = 0;
        if (c$prime >= 46) {
          if (c$prime !== 64) {
            if (c$prime === 93) {
              add_in_char_set(char_set, c);
              return str_ind + 1 | 0;
            }
            
          } else {
            exit = 2;
          }
        } else if (c$prime !== 37) {
          if (c$prime >= 45) {
            var str_ind$1 = str_ind + 1 | 0;
            var end_ind$1 = end_ind;
            var c$1 = c;
            if (str_ind$1 === end_ind$1) {
              invalid_format_message(end_ind$1, "unexpected end of format");
            }
            var c$prime$1 = caml_string.get(str, str_ind$1);
            if (c$prime$1 !== 37) {
              if (c$prime$1 !== 93) {
                add_range(c$1, c$prime$1);
                return parse_char_set_content(str_ind$1 + 1 | 0, end_ind$1);
              } else {
                add_in_char_set(char_set, c$1);
                add_in_char_set(char_set, /* "-" */45);
                return str_ind$1 + 1 | 0;
              }
            } else {
              if ((str_ind$1 + 1 | 0) === end_ind$1) {
                invalid_format_message(end_ind$1, "unexpected end of format");
              }
              var c$prime$2 = caml_string.get(str, str_ind$1 + 1 | 0);
              if (c$prime$2 !== 37 && c$prime$2 !== 64) {
                return fail_single_percent(str_ind$1);
              }
              add_range(c$1, c$prime$2);
              return parse_char_set_content(str_ind$1 + 2 | 0, end_ind$1);
            }
          }
          
        } else {
          exit = 2;
        }
        if (exit === 2 && c === /* "%" */37) {
          add_in_char_set(char_set, c$prime);
          return parse_char_set_content(str_ind + 1 | 0, end_ind);
        }
        if (c === /* "%" */37) {
          fail_single_percent(str_ind);
        }
        add_in_char_set(char_set, c);
        _c = c$prime;
        _str_ind = str_ind + 1 | 0;
        continue ;
      }    };
    var parse_char_set_start = function (str_ind, end_ind) {
      if (str_ind === end_ind) {
        invalid_format_message(end_ind, "unexpected end of format");
      }
      var c = caml_string.get(str, str_ind);
      return parse_char_set_after_char(str_ind + 1 | 0, end_ind, c);
    };
    if (str_ind === end_ind) {
      invalid_format_message(end_ind, "unexpected end of format");
    }
    var match = caml_string.get(str, str_ind);
    var match$1 = match !== 94 ? /* tuple */[
        str_ind,
        false
      ] : /* tuple */[
        str_ind + 1 | 0,
        true
      ];
    var next_ind = parse_char_set_start(match$1[0], end_ind);
    var char_set$1 = bytes.to_string(char_set);
    return /* tuple */[
            next_ind,
            match$1[1] ? rev_char_set(char_set$1) : char_set$1
          ];
  };
  var compute_int_conv = function (pct_ind, str_ind, _plus, _hash, _space, symb) {
    while(true) {
      var space = _space;
      var hash = _hash;
      var plus = _plus;
      var exit = 0;
      if (plus) {
        if (hash) {
          exit = 2;
        } else if (!space) {
          if (symb !== 100) {
            if (symb === 105) {
              return /* Int_pi */4;
            }
            
          } else {
            return /* Int_pd */1;
          }
        }
        
      } else if (hash) {
        if (space) {
          exit = 2;
        } else if (symb !== 88) {
          if (symb !== 111) {
            if (symb !== 120) {
              exit = 2;
            } else {
              return /* Int_Cx */7;
            }
          } else {
            return /* Int_Co */11;
          }
        } else {
          return /* Int_CX */9;
        }
      } else if (space) {
        if (symb !== 100) {
          if (symb === 105) {
            return /* Int_si */5;
          }
          
        } else {
          return /* Int_sd */2;
        }
      } else {
        switch (symb) {
          case 88 :
              return /* Int_X */8;
          case 100 :
              return /* Int_d */0;
          case 105 :
              return /* Int_i */3;
          case 111 :
              return /* Int_o */10;
          case 117 :
              return /* Int_u */12;
          case 89 :
          case 90 :
          case 91 :
          case 92 :
          case 93 :
          case 94 :
          case 95 :
          case 96 :
          case 97 :
          case 98 :
          case 99 :
          case 101 :
          case 102 :
          case 103 :
          case 104 :
          case 106 :
          case 107 :
          case 108 :
          case 109 :
          case 110 :
          case 112 :
          case 113 :
          case 114 :
          case 115 :
          case 116 :
          case 118 :
          case 119 :
              break;
          case 120 :
              return /* Int_x */6;
            
        }
      }
      if (exit === 2) {
        var exit$1 = 0;
        switch (symb) {
          case 88 :
              if (legacy_behavior$1) {
                return /* Int_CX */9;
              }
              break;
          case 111 :
              if (legacy_behavior$1) {
                return /* Int_Co */11;
              }
              break;
          case 100 :
          case 105 :
          case 117 :
              exit$1 = 3;
              break;
          case 89 :
          case 90 :
          case 91 :
          case 92 :
          case 93 :
          case 94 :
          case 95 :
          case 96 :
          case 97 :
          case 98 :
          case 99 :
          case 101 :
          case 102 :
          case 103 :
          case 104 :
          case 106 :
          case 107 :
          case 108 :
          case 109 :
          case 110 :
          case 112 :
          case 113 :
          case 114 :
          case 115 :
          case 116 :
          case 118 :
          case 119 :
              break;
          case 120 :
              if (legacy_behavior$1) {
                return /* Int_Cx */7;
              }
              break;
            
        }
        if (exit$1 === 3) {
          if (legacy_behavior$1) {
            _hash = false;
            continue ;
          } else {
            return incompatible_flag(pct_ind, str_ind, symb, "'#'");
          }
        }
        
      }
      if (plus) {
        if (space) {
          if (legacy_behavior$1) {
            _space = false;
            continue ;
          } else {
            return incompatible_flag(pct_ind, str_ind, /* " " */32, "'+'");
          }
        } else if (legacy_behavior$1) {
          _plus = false;
          continue ;
        } else {
          return incompatible_flag(pct_ind, str_ind, symb, "'+'");
        }
      } else if (space) {
        if (legacy_behavior$1) {
          _space = false;
          continue ;
        } else {
          return incompatible_flag(pct_ind, str_ind, symb, "' '");
        }
      } else {
        throw [
              caml_builtin_exceptions.assert_failure,
              /* tuple */[
                "camlinternalFormat.ml",
                2909,
                28
              ]
            ];
      }
    }  };
  var compute_float_conv = function (pct_ind, str_ind, _plus, _space, symb) {
    while(true) {
      var space = _space;
      var plus = _plus;
      if (plus) {
        if (space) {
          if (legacy_behavior$1) {
            _space = false;
            continue ;
          } else {
            return incompatible_flag(pct_ind, str_ind, /* " " */32, "'+'");
          }
        } else {
          if (symb >= 73) {
            switch (symb) {
              case 101 :
                  return /* Float_pe */4;
              case 102 :
                  return /* Float_pf */1;
              case 103 :
                  return /* Float_pg */10;
              case 104 :
                  return /* Float_ph */17;
                
            }
          } else if (symb >= 69) {
            switch (symb - 69 | 0) {
              case 0 :
                  return /* Float_pE */7;
              case 1 :
                  break;
              case 2 :
                  return /* Float_pG */13;
              case 3 :
                  return /* Float_pH */20;
              
            }
          }
          if (legacy_behavior$1) {
            _plus = false;
            continue ;
          } else {
            return incompatible_flag(pct_ind, str_ind, symb, "'+'");
          }
        }
      } else if (space) {
        if (symb >= 73) {
          switch (symb) {
            case 101 :
                return /* Float_se */5;
            case 102 :
                return /* Float_sf */2;
            case 103 :
                return /* Float_sg */11;
            case 104 :
                return /* Float_sh */18;
              
          }
        } else if (symb >= 69) {
          switch (symb - 69 | 0) {
            case 0 :
                return /* Float_sE */8;
            case 1 :
                break;
            case 2 :
                return /* Float_sG */14;
            case 3 :
                return /* Float_sH */21;
            
          }
        }
        if (legacy_behavior$1) {
          _space = false;
          continue ;
        } else {
          return incompatible_flag(pct_ind, str_ind, symb, "' '");
        }
      } else if (symb >= 73) {
        switch (symb) {
          case 101 :
              return /* Float_e */3;
          case 102 :
              return /* Float_f */0;
          case 103 :
              return /* Float_g */9;
          case 104 :
              return /* Float_h */16;
          default:
            throw [
                  caml_builtin_exceptions.assert_failure,
                  /* tuple */[
                    "camlinternalFormat.ml",
                    2943,
                    25
                  ]
                ];
        }
      } else if (symb >= 69) {
        switch (symb - 69 | 0) {
          case 0 :
              return /* Float_E */6;
          case 1 :
              return /* Float_F */15;
          case 2 :
              return /* Float_G */12;
          case 3 :
              return /* Float_H */19;
          
        }
      } else {
        throw [
              caml_builtin_exceptions.assert_failure,
              /* tuple */[
                "camlinternalFormat.ml",
                2943,
                25
              ]
            ];
      }
    }  };
  var parse_after_precision = function (pct_ind, str_ind, end_ind, minus, plus, hash, space, ign, pad, prec) {
    if (str_ind === end_ind) {
      invalid_format_message(end_ind, "unexpected end of format");
    }
    var parse_conv = function (padprec) {
      return parse_conversion(pct_ind, str_ind + 1 | 0, end_ind, plus, hash, space, ign, pad, prec, padprec, caml_string.get(str, str_ind));
    };
    if (typeof pad === "number") {
      if (typeof prec === "number" && prec === 0) {
        return parse_conv(/* No_padding */0);
      }
      if (minus) {
        if (typeof prec === "number") {
          return parse_conv(/* Arg_padding */block.__(1, [/* Left */0]));
        } else {
          return parse_conv(/* Lit_padding */block.__(0, [
                        /* Left */0,
                        prec[0]
                      ]));
        }
      } else if (typeof prec === "number") {
        return parse_conv(/* Arg_padding */block.__(1, [/* Right */1]));
      } else {
        return parse_conv(/* Lit_padding */block.__(0, [
                      /* Right */1,
                      prec[0]
                    ]));
      }
    } else {
      return parse_conv(pad);
    }
  };
  var parse_tag = function (is_open_tag, str_ind, end_ind) {
    try {
      if (str_ind === end_ind) {
        throw caml_builtin_exceptions.not_found;
      }
      var match = caml_string.get(str, str_ind);
      if (match !== 60) {
        throw caml_builtin_exceptions.not_found;
      }
      var ind = string.index_from(str, str_ind + 1 | 0, /* ">" */62);
      if (ind >= end_ind) {
        throw caml_builtin_exceptions.not_found;
      }
      var sub_str = string.sub(str, str_ind, (ind - str_ind | 0) + 1 | 0);
      var beg_ind = ind + 1 | 0;
      var match$1 = parse_literal(beg_ind, beg_ind, end_ind);
      var match$2 = parse_literal(str_ind, str_ind, ind + 1 | 0);
      var sub_fmt = match$2[0];
      var sub_format = /* Format */[
        sub_fmt,
        sub_str
      ];
      var formatting = is_open_tag ? /* Open_tag */block.__(0, [sub_format]) : (check_open_box(sub_fmt), /* Open_box */block.__(1, [sub_format]));
      return /* Fmt_EBB */[/* Formatting_gen */block.__(18, [
                  formatting,
                  match$1[0]
                ])];
    }
    catch (exn){
      if (exn === caml_builtin_exceptions.not_found) {
        var match$3 = parse_literal(str_ind, str_ind, end_ind);
        var sub_format$1 = /* Format */[
          /* End_of_format */0,
          ""
        ];
        var formatting$1 = is_open_tag ? /* Open_tag */block.__(0, [sub_format$1]) : /* Open_box */block.__(1, [sub_format$1]);
        return /* Fmt_EBB */[/* Formatting_gen */block.__(18, [
                    formatting$1,
                    match$3[0]
                  ])];
      } else {
        throw exn;
      }
    }
  };
  return parse_literal(0, 0, str.length);
}

function format_of_string_fmtty(str, fmtty) {
  var match = fmt_ebb_of_string(undefined, str);
  try {
    return /* Format */[
            type_format(match[0], fmtty),
            str
          ];
  }
  catch (exn){
    if (exn === Type_mismatch) {
      return curry._2(failwith_message(/* Format */[
                      /* String_literal */block.__(11, [
                          "bad input: format type mismatch between ",
                          /* Caml_string */block.__(3, [
                              /* No_padding */0,
                              /* String_literal */block.__(11, [
                                  " and ",
                                  /* Caml_string */block.__(3, [
                                      /* No_padding */0,
                                      /* End_of_format */0
                                    ])
                                ])
                            ])
                        ]),
                      "bad input: format type mismatch between %S and %S"
                    ]), str, string_of_fmtty(fmtty));
    } else {
      throw exn;
    }
  }
}

function format_of_string_format(str, param) {
  var match = fmt_ebb_of_string(undefined, str);
  try {
    return /* Format */[
            type_format(match[0], fmtty_of_fmt(param[0])),
            str
          ];
  }
  catch (exn){
    if (exn === Type_mismatch) {
      return curry._2(failwith_message(/* Format */[
                      /* String_literal */block.__(11, [
                          "bad input: format type mismatch between ",
                          /* Caml_string */block.__(3, [
                              /* No_padding */0,
                              /* String_literal */block.__(11, [
                                  " and ",
                                  /* Caml_string */block.__(3, [
                                      /* No_padding */0,
                                      /* End_of_format */0
                                    ])
                                ])
                            ])
                        ]),
                      "bad input: format type mismatch between %S and %S"
                    ]), str, param[1]);
    } else {
      throw exn;
    }
  }
}

var is_in_char_set_1 = is_in_char_set;
var rev_char_set_1 = rev_char_set;
var create_char_set_1 = create_char_set;
var add_in_char_set_1 = add_in_char_set;
var freeze_char_set_1 = freeze_char_set;
var param_format_of_ignored_format_1 = param_format_of_ignored_format;
var make_printf_1 = make_printf;
var make_iprintf_1 = make_iprintf;
var output_acc_1 = output_acc;
var bufput_acc_1 = bufput_acc;
var strput_acc_1 = strput_acc;
var type_format_1 = type_format;
var fmt_ebb_of_string_1 = fmt_ebb_of_string;
var format_of_string_fmtty_1 = format_of_string_fmtty;
var format_of_string_format_1 = format_of_string_format;
var char_of_iconv_1 = char_of_iconv;
var string_of_formatting_lit_1 = string_of_formatting_lit;
var string_of_formatting_gen_1 = string_of_formatting_gen;
var string_of_fmtty_1 = string_of_fmtty;
var string_of_fmt_1 = string_of_fmt;
var open_box_of_string_1 = open_box_of_string;
var symm_1 = symm;
var trans_1 = trans;
var recast_1 = recast;
/* No side effect */

var camlinternalFormat = {
	is_in_char_set: is_in_char_set_1,
	rev_char_set: rev_char_set_1,
	create_char_set: create_char_set_1,
	add_in_char_set: add_in_char_set_1,
	freeze_char_set: freeze_char_set_1,
	param_format_of_ignored_format: param_format_of_ignored_format_1,
	make_printf: make_printf_1,
	make_iprintf: make_iprintf_1,
	output_acc: output_acc_1,
	bufput_acc: bufput_acc_1,
	strput_acc: strput_acc_1,
	type_format: type_format_1,
	fmt_ebb_of_string: fmt_ebb_of_string_1,
	format_of_string_fmtty: format_of_string_fmtty_1,
	format_of_string_format: format_of_string_format_1,
	char_of_iconv: char_of_iconv_1,
	string_of_formatting_lit: string_of_formatting_lit_1,
	string_of_formatting_gen: string_of_formatting_gen_1,
	string_of_fmtty: string_of_fmtty_1,
	string_of_fmt: string_of_fmt_1,
	open_box_of_string: open_box_of_string_1,
	symm: symm_1,
	trans: trans_1,
	recast: recast_1
};

function kfprintf(k, o, param) {
  return camlinternalFormat.make_printf((function (o, acc) {
                camlinternalFormat.output_acc(o, acc);
                return curry._1(k, o);
              }), o, /* End_of_acc */0, param[0]);
}

function kbprintf(k, b, param) {
  return camlinternalFormat.make_printf((function (b, acc) {
                camlinternalFormat.bufput_acc(b, acc);
                return curry._1(k, b);
              }), b, /* End_of_acc */0, param[0]);
}

function ikfprintf(k, oc, param) {
  return camlinternalFormat.make_iprintf(k, oc, param[0]);
}

function fprintf(oc, fmt) {
  return kfprintf((function (prim) {
                return /* () */0;
              }), oc, fmt);
}

function bprintf(b, fmt) {
  return kbprintf((function (prim) {
                return /* () */0;
              }), b, fmt);
}

function ifprintf(oc, fmt) {
  return ikfprintf((function (prim) {
                return /* () */0;
              }), oc, fmt);
}

function printf(fmt) {
  return fprintf(pervasives.stdout, fmt);
}

function eprintf(fmt) {
  return fprintf(pervasives.stderr, fmt);
}

function ksprintf(k, param) {
  var k$prime = function (param, acc) {
    var buf = buffer.create(64);
    camlinternalFormat.strput_acc(buf, acc);
    return curry._1(k, buffer.contents(buf));
  };
  return camlinternalFormat.make_printf(k$prime, /* () */0, /* End_of_acc */0, param[0]);
}

function sprintf(fmt) {
  return ksprintf((function (s) {
                return s;
              }), fmt);
}

var kprintf = ksprintf;

var fprintf_1 = fprintf;
var printf_2 = printf;
var eprintf_1 = eprintf;
var sprintf_1 = sprintf;
var bprintf_1 = bprintf;
var ifprintf_1 = ifprintf;
var kfprintf_1 = kfprintf;
var ikfprintf_1 = ikfprintf;
var ksprintf_1 = ksprintf;
var kbprintf_1 = kbprintf;
var kprintf_1 = kprintf;
/* No side effect */

var printf_1 = {
	fprintf: fprintf_1,
	printf: printf_2,
	eprintf: eprintf_1,
	sprintf: sprintf_1,
	bprintf: bprintf_1,
	ifprintf: ifprintf_1,
	kfprintf: kfprintf_1,
	ikfprintf: ikfprintf_1,
	ksprintf: ksprintf_1,
	kbprintf: kbprintf_1,
	kprintf: kprintf_1
};

function succ(n) {
  return n + 1 | 0;
}

function pred(n) {
  return n - 1 | 0;
}

function abs$1(n) {
  if (n >= 0) {
    return n;
  } else {
    return -n | 0;
  }
}

function lognot(n) {
  return n ^ -1;
}

function to_string$1(n) {
  return caml_format.caml_int32_format("%d", n);
}

function of_string_opt(s) {
  try {
    return caml_format.caml_int32_of_string(s);
  }
  catch (raw_exn){
    var exn = caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] === caml_builtin_exceptions.failure) {
      return ;
    } else {
      throw exn;
    }
  }
}

var compare$4 = caml_primitive.caml_int32_compare;

function equal$3(x, y) {
  return x === y;
}

var zero$1 = 0;

var one$1 = 1;

var minus_one = -1;

var max_int$2 = 2147483647;

var min_int$2 = -2147483648;

var zero_1$1 = zero$1;
var one_1$1 = one$1;
var minus_one_1 = minus_one;
var succ_1 = succ;
var pred_1 = pred;
var abs_1$1 = abs$1;
var max_int_1$2 = max_int$2;
var min_int_1$2 = min_int$2;
var lognot_1 = lognot;
var of_string_opt_1 = of_string_opt;
var to_string_1$1 = to_string$1;
var compare_1$4 = compare$4;
var equal_1$3 = equal$3;
/* No side effect */

var int32 = {
	zero: zero_1$1,
	one: one_1$1,
	minus_one: minus_one_1,
	succ: succ_1,
	pred: pred_1,
	abs: abs_1$1,
	max_int: max_int_1$2,
	min_int: min_int_1$2,
	lognot: lognot_1,
	of_string_opt: of_string_opt_1,
	to_string: to_string_1$1,
	compare: compare_1$4,
	equal: equal_1$3
};

function succ$1(n) {
  return caml_int64.add(n, /* int64 */{
              hi: 0,
              lo: 1
            });
}

function pred$1(n) {
  return caml_int64.sub(n, /* int64 */{
              hi: 0,
              lo: 1
            });
}

function abs$2(n) {
  if (caml_int64.ge(n, /* int64 */{
          hi: 0,
          lo: 0
        })) {
    return n;
  } else {
    return caml_int64.neg(n);
  }
}

function lognot$1(n) {
  return caml_int64.xor(n, /* int64 */{
              hi: -1,
              lo: 4294967295
            });
}

function to_string$2(n) {
  return caml_format.caml_int64_format("%d", n);
}

function of_string_opt$1(s) {
  try {
    return caml_format.caml_int64_of_string(s);
  }
  catch (raw_exn){
    var exn = caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] === caml_builtin_exceptions.failure) {
      return ;
    } else {
      throw exn;
    }
  }
}

var compare$5 = caml_int64.compare;

function equal$4(x, y) {
  return caml_int64.compare(x, y) === 0;
}

var zero$2 = /* int64 */{
  hi: 0,
  lo: 0
};

var one$2 = /* int64 */{
  hi: 0,
  lo: 1
};

var minus_one$1 = /* int64 */{
  hi: -1,
  lo: 4294967295
};

var max_int$3 = /* int64 */{
  hi: 2147483647,
  lo: 4294967295
};

var min_int$3 = /* int64 */{
  hi: -2147483648,
  lo: 0
};

var zero_1$2 = zero$2;
var one_1$2 = one$2;
var minus_one_1$1 = minus_one$1;
var succ_1$1 = succ$1;
var pred_1$1 = pred$1;
var abs_1$2 = abs$2;
var max_int_1$3 = max_int$3;
var min_int_1$3 = min_int$3;
var lognot_1$1 = lognot$1;
var of_string_opt_1$1 = of_string_opt$1;
var to_string_1$2 = to_string$2;
var compare_1$5 = compare$5;
var equal_1$4 = equal$4;
/* No side effect */

var int64 = {
	zero: zero_1$2,
	one: one_1$2,
	minus_one: minus_one_1$1,
	succ: succ_1$1,
	pred: pred_1$1,
	abs: abs_1$2,
	max_int: max_int_1$3,
	min_int: min_int_1$3,
	lognot: lognot_1$1,
	of_string_opt: of_string_opt_1$1,
	to_string: to_string_1$2,
	compare: compare_1$5,
	equal: equal_1$4
};

function cmn(q, a, b, x, s, t) {
  var a$1 = ((a + q | 0) + x | 0) + t | 0;
  return ((a$1 << s) | (a$1 >>> (32 - s | 0)) | 0) + b | 0;
}

function f(a, b, c, d, x, s, t) {
  return cmn(b & c | (b ^ -1) & d, a, b, x, s, t);
}

function g(a, b, c, d, x, s, t) {
  return cmn(b & d | c & (d ^ -1), a, b, x, s, t);
}

function h(a, b, c, d, x, s, t) {
  return cmn(b ^ c ^ d, a, b, x, s, t);
}

function i(a, b, c, d, x, s, t) {
  return cmn(c ^ (b | d ^ -1), a, b, x, s, t);
}

function cycle(x, k) {
  var a = x[0];
  var b = x[1];
  var c = x[2];
  var d = x[3];
  a = f(a, b, c, d, k[0], 7, -680876936);
  d = f(d, a, b, c, k[1], 12, -389564586);
  c = f(c, d, a, b, k[2], 17, 606105819);
  b = f(b, c, d, a, k[3], 22, -1044525330);
  a = f(a, b, c, d, k[4], 7, -176418897);
  d = f(d, a, b, c, k[5], 12, 1200080426);
  c = f(c, d, a, b, k[6], 17, -1473231341);
  b = f(b, c, d, a, k[7], 22, -45705983);
  a = f(a, b, c, d, k[8], 7, 1770035416);
  d = f(d, a, b, c, k[9], 12, -1958414417);
  c = f(c, d, a, b, k[10], 17, -42063);
  b = f(b, c, d, a, k[11], 22, -1990404162);
  a = f(a, b, c, d, k[12], 7, 1804603682);
  d = f(d, a, b, c, k[13], 12, -40341101);
  c = f(c, d, a, b, k[14], 17, -1502002290);
  b = f(b, c, d, a, k[15], 22, 1236535329);
  a = g(a, b, c, d, k[1], 5, -165796510);
  d = g(d, a, b, c, k[6], 9, -1069501632);
  c = g(c, d, a, b, k[11], 14, 643717713);
  b = g(b, c, d, a, k[0], 20, -373897302);
  a = g(a, b, c, d, k[5], 5, -701558691);
  d = g(d, a, b, c, k[10], 9, 38016083);
  c = g(c, d, a, b, k[15], 14, -660478335);
  b = g(b, c, d, a, k[4], 20, -405537848);
  a = g(a, b, c, d, k[9], 5, 568446438);
  d = g(d, a, b, c, k[14], 9, -1019803690);
  c = g(c, d, a, b, k[3], 14, -187363961);
  b = g(b, c, d, a, k[8], 20, 1163531501);
  a = g(a, b, c, d, k[13], 5, -1444681467);
  d = g(d, a, b, c, k[2], 9, -51403784);
  c = g(c, d, a, b, k[7], 14, 1735328473);
  b = g(b, c, d, a, k[12], 20, -1926607734);
  a = h(a, b, c, d, k[5], 4, -378558);
  d = h(d, a, b, c, k[8], 11, -2022574463);
  c = h(c, d, a, b, k[11], 16, 1839030562);
  b = h(b, c, d, a, k[14], 23, -35309556);
  a = h(a, b, c, d, k[1], 4, -1530992060);
  d = h(d, a, b, c, k[4], 11, 1272893353);
  c = h(c, d, a, b, k[7], 16, -155497632);
  b = h(b, c, d, a, k[10], 23, -1094730640);
  a = h(a, b, c, d, k[13], 4, 681279174);
  d = h(d, a, b, c, k[0], 11, -358537222);
  c = h(c, d, a, b, k[3], 16, -722521979);
  b = h(b, c, d, a, k[6], 23, 76029189);
  a = h(a, b, c, d, k[9], 4, -640364487);
  d = h(d, a, b, c, k[12], 11, -421815835);
  c = h(c, d, a, b, k[15], 16, 530742520);
  b = h(b, c, d, a, k[2], 23, -995338651);
  a = i(a, b, c, d, k[0], 6, -198630844);
  d = i(d, a, b, c, k[7], 10, 1126891415);
  c = i(c, d, a, b, k[14], 15, -1416354905);
  b = i(b, c, d, a, k[5], 21, -57434055);
  a = i(a, b, c, d, k[12], 6, 1700485571);
  d = i(d, a, b, c, k[3], 10, -1894986606);
  c = i(c, d, a, b, k[10], 15, -1051523);
  b = i(b, c, d, a, k[1], 21, -2054922799);
  a = i(a, b, c, d, k[8], 6, 1873313359);
  d = i(d, a, b, c, k[15], 10, -30611744);
  c = i(c, d, a, b, k[6], 15, -1560198380);
  b = i(b, c, d, a, k[13], 21, 1309151649);
  a = i(a, b, c, d, k[4], 6, -145523070);
  d = i(d, a, b, c, k[11], 10, -1120210379);
  c = i(c, d, a, b, k[2], 15, 718787259);
  b = i(b, c, d, a, k[9], 21, -343485551);
  x[0] = a + x[0] | 0;
  x[1] = b + x[1] | 0;
  x[2] = c + x[2] | 0;
  x[3] = d + x[3] | 0;
  return /* () */0;
}

var state = /* array */[
  1732584193,
  -271733879,
  -1732584194,
  271733878
];

var md5blk = /* array */[
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
];

function caml_md5_string(s, start, len) {
  var s$1 = s.slice(start, len);
  var n = s$1.length;
  state[0] = 1732584193;
  state[1] = -271733879;
  state[2] = -1732584194;
  state[3] = 271733878;
  for(var i = 0; i <= 15; ++i){
    md5blk[i] = 0;
  }
  var i_end = n / 64 | 0;
  for(var i$1 = 1; i$1 <= i_end; ++i$1){
    for(var j = 0; j <= 15; ++j){
      var k = ((i$1 << 6) - 64 | 0) + (j << 2) | 0;
      md5blk[j] = ((s$1.charCodeAt(k) + (s$1.charCodeAt(k + 1 | 0) << 8) | 0) + (s$1.charCodeAt(k + 2 | 0) << 16) | 0) + (s$1.charCodeAt(k + 3 | 0) << 24) | 0;
    }
    cycle(state, md5blk);
  }
  var s_tail = s$1.slice((i_end << 6));
  for(var kk = 0; kk <= 15; ++kk){
    md5blk[kk] = 0;
  }
  var i_end$1 = s_tail.length - 1 | 0;
  for(var i$2 = 0; i$2 <= i_end$1; ++i$2){
    md5blk[i$2 / 4 | 0] = md5blk[i$2 / 4 | 0] | (s_tail.charCodeAt(i$2) << (i$2 % 4 << 3));
  }
  var i$3 = i_end$1 + 1 | 0;
  md5blk[i$3 / 4 | 0] = md5blk[i$3 / 4 | 0] | (128 << (i$3 % 4 << 3));
  if (i$3 > 55) {
    cycle(state, md5blk);
    for(var i$4 = 0; i$4 <= 15; ++i$4){
      md5blk[i$4] = 0;
    }
  }
  md5blk[14] = (n << 3);
  cycle(state, md5blk);
  return String.fromCharCode(state[0] & 255, (state[0] >> 8) & 255, (state[0] >> 16) & 255, (state[0] >> 24) & 255, state[1] & 255, (state[1] >> 8) & 255, (state[1] >> 16) & 255, (state[1] >> 24) & 255, state[2] & 255, (state[2] >> 8) & 255, (state[2] >> 16) & 255, (state[2] >> 24) & 255, state[3] & 255, (state[3] >> 8) & 255, (state[3] >> 16) & 255, (state[3] >> 24) & 255);
}

var caml_md5_string_1 = caml_md5_string;
/* No side effect */

var caml_md5 = {
	caml_md5_string: caml_md5_string_1
};

function string$1(str) {
  return caml_md5.caml_md5_string(str, 0, str.length);
}

function bytes$1(b) {
  return string$1(caml_bytes.bytes_to_string(b));
}

function substring(str, ofs, len) {
  if (ofs < 0 || len < 0 || ofs > (str.length - len | 0)) {
    throw [
          caml_builtin_exceptions.invalid_argument,
          "Digest.substring"
        ];
  }
  return caml_md5.caml_md5_string(str, ofs, len);
}

function subbytes(b, ofs, len) {
  return substring(caml_bytes.bytes_to_string(b), ofs, len);
}

function file(filename) {
  var ic = pervasives.open_in_bin(filename);
  var d;
  try {
    d = caml_external_polyfill.resolve("caml_md5_chan")(ic, -1);
  }
  catch (e){
    caml_external_polyfill.resolve("caml_ml_close_channel")(ic);
    throw e;
  }
  caml_external_polyfill.resolve("caml_ml_close_channel")(ic);
  return d;
}

var output$1 = pervasives.output_string;

function input$1(chan) {
  return pervasives.really_input_string(chan, 16);
}

function char_hex(n) {
  return n + (
          n < 10 ? /* "0" */48 : 87
        ) | 0;
}

function to_hex$1(d) {
  if (d.length !== 16) {
    throw [
          caml_builtin_exceptions.invalid_argument,
          "Digest.to_hex"
        ];
  }
  var result = caml_bytes.caml_create_bytes(32);
  for(var i = 0; i <= 15; ++i){
    var x = caml_string.get(d, i);
    result[(i << 1)] = char_hex((x >>> 4));
    result[(i << 1) + 1 | 0] = char_hex(x & 15);
  }
  return caml_bytes.bytes_to_string(result);
}

function from_hex(s) {
  if (s.length !== 32) {
    throw [
          caml_builtin_exceptions.invalid_argument,
          "Digest.from_hex"
        ];
  }
  var digit = function (c) {
    if (c >= 65) {
      if (c >= 97) {
        if (c >= 103) {
          throw [
                caml_builtin_exceptions.invalid_argument,
                "Digest.from_hex"
              ];
        }
        return (c - /* "a" */97 | 0) + 10 | 0;
      } else {
        if (c >= 71) {
          throw [
                caml_builtin_exceptions.invalid_argument,
                "Digest.from_hex"
              ];
        }
        return (c - /* "A" */65 | 0) + 10 | 0;
      }
    } else {
      if (c > 57 || c < 48) {
        throw [
              caml_builtin_exceptions.invalid_argument,
              "Digest.from_hex"
            ];
      }
      return c - /* "0" */48 | 0;
    }
  };
  var $$byte = function (i) {
    return (digit(caml_string.get(s, i)) << 4) + digit(caml_string.get(s, i + 1 | 0)) | 0;
  };
  var result = caml_bytes.caml_create_bytes(16);
  for(var i = 0; i <= 15; ++i){
    result[i] = char_1.chr($$byte((i << 1)));
  }
  return caml_bytes.bytes_to_string(result);
}

var compare$6 = string.compare;

var equal$5 = string.equal;

var compare_1$6 = compare$6;
var equal_1$5 = equal$5;
var string_1 = string$1;
var bytes_1 = bytes$1;
var substring_1 = substring;
var subbytes_1 = subbytes;
var file_1 = file;
var output_1$1 = output$1;
var input_1$1 = input$1;
var to_hex_1$1 = to_hex$1;
var from_hex_1 = from_hex;
/* No side effect */

var digest = {
	compare: compare_1$6,
	equal: equal_1$5,
	string: string_1,
	bytes: bytes_1,
	substring: substring_1,
	subbytes: subbytes_1,
	file: file_1,
	output: output_1$1,
	input: input_1$1,
	to_hex: to_hex_1$1,
	from_hex: from_hex_1
};

function assign(st1, st2) {
  array.blit(st2.st, 0, st1.st, 0, 55);
  st1.idx = st2.idx;
  return /* () */0;
}

function full_init(s, seed) {
  var combine = function (accu, x) {
    return digest.string(accu + String(x));
  };
  var extract = function (d) {
    return ((caml_string.get(d, 0) + (caml_string.get(d, 1) << 8) | 0) + (caml_string.get(d, 2) << 16) | 0) + (caml_string.get(d, 3) << 24) | 0;
  };
  var seed$1 = seed.length === 0 ? /* array */[0] : seed;
  var l = seed$1.length;
  for(var i = 0; i <= 54; ++i){
    caml_array.caml_array_set(s.st, i, i);
  }
  var accu = "x";
  for(var i$1 = 0 ,i_finish = 54 + (
      55 > l ? 55 : l
    ) | 0; i$1 <= i_finish; ++i$1){
    var j = i$1 % 55;
    var k = i$1 % l;
    accu = combine(accu, caml_array.caml_array_get(seed$1, k));
    caml_array.caml_array_set(s.st, j, (caml_array.caml_array_get(s.st, j) ^ extract(accu)) & 1073741823);
  }
  s.idx = 0;
  return /* () */0;
}

function make$2(seed) {
  var result = {
    st: caml_array.caml_make_vect(55, 0),
    idx: 0
  };
  full_init(result, seed);
  return result;
}

function make_self_init(param) {
  return make$2(caml_sys.caml_sys_random_seed(/* () */0));
}

function copy$3(s) {
  var result = {
    st: caml_array.caml_make_vect(55, 0),
    idx: 0
  };
  assign(result, s);
  return result;
}

function bits(s) {
  s.idx = (s.idx + 1 | 0) % 55;
  var curval = caml_array.caml_array_get(s.st, s.idx);
  var newval = caml_array.caml_array_get(s.st, (s.idx + 24 | 0) % 55) + (curval ^ (curval >>> 25) & 31) | 0;
  var newval30 = newval & 1073741823;
  caml_array.caml_array_set(s.st, s.idx, newval30);
  return newval30;
}

function $$int(s, bound) {
  if (bound > 1073741823 || bound <= 0) {
    throw [
          caml_builtin_exceptions.invalid_argument,
          "Random.int"
        ];
  }
  var s$1 = s;
  var n = bound;
  while(true) {
    var r = bits(s$1);
    var v = r % n;
    if ((r - v | 0) > ((1073741823 - n | 0) + 1 | 0)) {
      continue ;
    } else {
      return v;
    }
  }}

function int32$1(s, bound) {
  if (bound <= 0) {
    throw [
          caml_builtin_exceptions.invalid_argument,
          "Random.int32"
        ];
  }
  var s$1 = s;
  var n = bound;
  while(true) {
    var b1 = bits(s$1);
    var b2 = ((bits(s$1) & 1) << 30);
    var r = b1 | b2;
    var v = r % n;
    if ((r - v | 0) > ((int32.max_int - n | 0) + 1 | 0)) {
      continue ;
    } else {
      return v;
    }
  }}

function int64$1(s, bound) {
  if (caml_int64.le(bound, /* int64 */{
          hi: 0,
          lo: 0
        })) {
    throw [
          caml_builtin_exceptions.invalid_argument,
          "Random.int64"
        ];
  }
  var s$1 = s;
  var n = bound;
  while(true) {
    var b1 = caml_int64.of_int32(bits(s$1));
    var b2 = caml_int64.lsl_(caml_int64.of_int32(bits(s$1)), 30);
    var b3 = caml_int64.lsl_(caml_int64.of_int32(bits(s$1) & 7), 60);
    var r = caml_int64.or_(b1, caml_int64.or_(b2, b3));
    var v = caml_int64.mod_(r, n);
    if (caml_int64.gt(caml_int64.sub(r, v), caml_int64.add(caml_int64.sub(int64.max_int, n), /* int64 */{
                hi: 0,
                lo: 1
              }))) {
      continue ;
    } else {
      return v;
    }
  }}

var nativeint =  (function (s, bound) {
      return caml_int64.to_int32(int64$1(s, caml_int64.of_int32(bound)));
    });

function rawfloat(s) {
  var r1 = bits(s);
  var r2 = bits(s);
  return (r1 / 1073741824.0 + r2) / 1073741824.0;
}

function $$float(s, bound) {
  return rawfloat(s) * bound;
}

function bool(s) {
  return (bits(s) & 1) === 0;
}

var $$default = {
  st: /* array */[
    987910699,
    495797812,
    364182224,
    414272206,
    318284740,
    990407751,
    383018966,
    270373319,
    840823159,
    24560019,
    536292337,
    512266505,
    189156120,
    730249596,
    143776328,
    51606627,
    140166561,
    366354223,
    1003410265,
    700563762,
    981890670,
    913149062,
    526082594,
    1021425055,
    784300257,
    667753350,
    630144451,
    949649812,
    48546892,
    415514493,
    258888527,
    511570777,
    89983870,
    283659902,
    308386020,
    242688715,
    482270760,
    865188196,
    1027664170,
    207196989,
    193777847,
    619708188,
    671350186,
    149669678,
    257044018,
    87658204,
    558145612,
    183450813,
    28133145,
    901332182,
    710253903,
    510646120,
    652377910,
    409934019,
    801085050
  ],
  idx: 0
};

function bits$1(param) {
  return bits($$default);
}

function $$int$1(bound) {
  return $$int($$default, bound);
}

function int32$1$1(bound) {
  return int32$1($$default, bound);
}

function nativeint$1(bound) {
  return curry._2(nativeint, $$default, bound);
}

function int64$1$1(bound) {
  return int64$1($$default, bound);
}

function $$float$1(scale) {
  return rawfloat($$default) * scale;
}

function bool$1(param) {
  return bool($$default);
}

function full_init$1(seed) {
  return full_init($$default, seed);
}

function init$3(seed) {
  return full_init($$default, /* array */[seed]);
}

function self_init(param) {
  return full_init$1(caml_sys.caml_sys_random_seed(/* () */0));
}

function get_state(param) {
  return copy$3($$default);
}

function set_state(s) {
  return assign($$default, s);
}

var State = {
  make: make$2,
  make_self_init: make_self_init,
  copy: copy$3,
  bits: bits,
  $$int: $$int,
  int32: int32$1,
  nativeint: nativeint,
  int64: int64$1,
  $$float: $$float,
  bool: bool
};

var init_1$3 = init$3;
var full_init_1 = full_init$1;
var self_init_1 = self_init;
var bits_1 = bits$1;
var $$int_1 = $$int$1;
var int32_1 = int32$1$1;
var nativeint_1 = nativeint$1;
var int64_1 = int64$1$1;
var $$float_1 = $$float$1;
var bool_1 = bool$1;
var State_1 = State;
var get_state_1 = get_state;
var set_state_1 = set_state;
/* No side effect */

var random = {
	init: init_1$3,
	full_init: full_init_1,
	self_init: self_init_1,
	bits: bits_1,
	$$int: $$int_1,
	int32: int32_1,
	nativeint: nativeint_1,
	int64: int64_1,
	$$float: $$float_1,
	bool: bool_1,
	State: State_1,
	get_state: get_state_1,
	set_state: set_state_1
};

function to_buffer(buff, ofs, len, v, flags) {
  if (ofs < 0 || len < 0 || ofs > (buff.length - len | 0)) {
    throw [
          caml_builtin_exceptions.invalid_argument,
          "Marshal.to_buffer: substring out of bounds"
        ];
  }
  return caml_external_polyfill.resolve("caml_output_value_to_buffer")(buff, ofs, len, v, flags);
}

function data_size(buff, ofs) {
  if (ofs < 0 || ofs > (buff.length - 20 | 0)) {
    throw [
          caml_builtin_exceptions.invalid_argument,
          "Marshal.data_size"
        ];
  }
  return caml_external_polyfill.resolve("caml_marshal_data_size")(buff, ofs);
}

function total_size(buff, ofs) {
  return 20 + data_size(buff, ofs) | 0;
}

function from_bytes(buff, ofs) {
  if (ofs < 0 || ofs > (buff.length - 20 | 0)) {
    throw [
          caml_builtin_exceptions.invalid_argument,
          "Marshal.from_bytes"
        ];
  }
  var len = caml_external_polyfill.resolve("caml_marshal_data_size")(buff, ofs);
  if (ofs > (buff.length - (20 + len | 0) | 0)) {
    throw [
          caml_builtin_exceptions.invalid_argument,
          "Marshal.from_bytes"
        ];
  }
  return caml_external_polyfill.resolve("caml_input_value_from_string")(buff, ofs);
}

function from_string(buff, ofs) {
  return from_bytes(caml_bytes.bytes_of_string(buff), ofs);
}

function to_channel(prim, prim$1, prim$2) {
  return caml_external_polyfill.resolve("caml_output_value")(prim, prim$1, prim$2);
}

function from_channel(prim) {
  return caml_external_polyfill.resolve("caml_input_value")(prim);
}

var header_size = 20;

var to_channel_1 = to_channel;
var to_buffer_1 = to_buffer;
var from_channel_1 = from_channel;
var from_bytes_1 = from_bytes;
var from_string_1 = from_string;
var header_size_1 = header_size;
var data_size_1 = data_size;
var total_size_1 = total_size;
/* No side effect */

var marshal = {
	to_channel: to_channel_1,
	to_buffer: to_buffer_1,
	from_channel: from_channel_1,
	from_bytes: from_bytes_1,
	from_string: from_string_1,
	header_size: header_size_1,
	data_size: data_size_1,
	total_size: total_size_1
};

function is_block(a) {
  return typeof a !== "number";
}

var double_field = caml_array.caml_array_get;

var set_double_field = caml_array.caml_array_set;

function marshal$1(obj) {
  return caml_external_polyfill.resolve("caml_output_value_to_string")(obj, /* [] */0);
}

function unmarshal(str, pos) {
  return /* tuple */[
          marshal.from_bytes(str, pos),
          pos + marshal.total_size(str, pos) | 0
        ];
}

function extension_constructor(x) {
  var slot = typeof x !== "number" && (x.tag | 0) !== 248 && x.length >= 1 ? x[0] : x;
  var name;
  if (typeof slot !== "number" && slot.tag === 248) {
    name = slot[0];
  } else {
    throw [
          caml_builtin_exceptions.invalid_argument,
          "Obj.extension_constructor"
        ];
  }
  if (name.tag === 252) {
    return slot;
  } else {
    throw [
          caml_builtin_exceptions.invalid_argument,
          "Obj.extension_constructor"
        ];
  }
}

function extension_name(slot) {
  return slot[0];
}

function extension_id(slot) {
  return slot[1];
}

function length$1(x) {
  return x.length - 2 | 0;
}

var first_non_constant_constructor_tag = 0;

var last_non_constant_constructor_tag = 245;

var lazy_tag = 246;

var closure_tag = 247;

var object_tag = 248;

var infix_tag = 249;

var forward_tag = 250;

var no_scan_tag = 251;

var abstract_tag = 251;

var string_tag = 252;

var double_tag = 253;

var double_array_tag = 254;

var custom_tag = 255;

var final_tag = 255;

var int_tag = 1000;

var out_of_heap_tag = 1001;

var unaligned_tag = 1002;

function Ephemeron_create(prim) {
  return caml_external_polyfill.resolve("caml_ephe_create")(prim);
}

function Ephemeron_get_key(prim, prim$1) {
  return caml_external_polyfill.resolve("caml_ephe_get_key")(prim, prim$1);
}

function Ephemeron_get_key_copy(prim, prim$1) {
  return caml_external_polyfill.resolve("caml_ephe_get_key_copy")(prim, prim$1);
}

function Ephemeron_set_key(prim, prim$1, prim$2) {
  return caml_external_polyfill.resolve("caml_ephe_set_key")(prim, prim$1, prim$2);
}

function Ephemeron_unset_key(prim, prim$1) {
  return caml_external_polyfill.resolve("caml_ephe_unset_key")(prim, prim$1);
}

function Ephemeron_check_key(prim, prim$1) {
  return caml_external_polyfill.resolve("caml_ephe_check_key")(prim, prim$1);
}

function Ephemeron_blit_key(prim, prim$1, prim$2, prim$3, prim$4) {
  return caml_external_polyfill.resolve("caml_ephe_blit_key")(prim, prim$1, prim$2, prim$3, prim$4);
}

function Ephemeron_get_data(prim) {
  return caml_external_polyfill.resolve("caml_ephe_get_data")(prim);
}

function Ephemeron_get_data_copy(prim) {
  return caml_external_polyfill.resolve("caml_ephe_get_data_copy")(prim);
}

function Ephemeron_set_data(prim, prim$1) {
  return caml_external_polyfill.resolve("caml_ephe_set_data")(prim, prim$1);
}

function Ephemeron_unset_data(prim) {
  return caml_external_polyfill.resolve("caml_ephe_unset_data")(prim);
}

function Ephemeron_check_data(prim) {
  return caml_external_polyfill.resolve("caml_ephe_check_data")(prim);
}

function Ephemeron_blit_data(prim, prim$1) {
  return caml_external_polyfill.resolve("caml_ephe_blit_data")(prim, prim$1);
}

var Ephemeron = {
  create: Ephemeron_create,
  length: length$1,
  get_key: Ephemeron_get_key,
  get_key_copy: Ephemeron_get_key_copy,
  set_key: Ephemeron_set_key,
  unset_key: Ephemeron_unset_key,
  check_key: Ephemeron_check_key,
  blit_key: Ephemeron_blit_key,
  get_data: Ephemeron_get_data,
  get_data_copy: Ephemeron_get_data_copy,
  set_data: Ephemeron_set_data,
  unset_data: Ephemeron_unset_data,
  check_data: Ephemeron_check_data,
  blit_data: Ephemeron_blit_data
};

var is_block_1 = is_block;
var double_field_1 = double_field;
var set_double_field_1 = set_double_field;
var first_non_constant_constructor_tag_1 = first_non_constant_constructor_tag;
var last_non_constant_constructor_tag_1 = last_non_constant_constructor_tag;
var lazy_tag_1 = lazy_tag;
var closure_tag_1 = closure_tag;
var object_tag_1 = object_tag;
var infix_tag_1 = infix_tag;
var forward_tag_1 = forward_tag;
var no_scan_tag_1 = no_scan_tag;
var abstract_tag_1 = abstract_tag;
var string_tag_1 = string_tag;
var double_tag_1 = double_tag;
var double_array_tag_1 = double_array_tag;
var custom_tag_1 = custom_tag;
var final_tag_1 = final_tag;
var int_tag_1 = int_tag;
var out_of_heap_tag_1 = out_of_heap_tag;
var unaligned_tag_1 = unaligned_tag;
var extension_constructor_1 = extension_constructor;
var extension_name_1 = extension_name;
var extension_id_1 = extension_id;
var marshal_1 = marshal$1;
var unmarshal_1 = unmarshal;
var Ephemeron_1 = Ephemeron;
/* No side effect */

var obj = {
	is_block: is_block_1,
	double_field: double_field_1,
	set_double_field: set_double_field_1,
	first_non_constant_constructor_tag: first_non_constant_constructor_tag_1,
	last_non_constant_constructor_tag: last_non_constant_constructor_tag_1,
	lazy_tag: lazy_tag_1,
	closure_tag: closure_tag_1,
	object_tag: object_tag_1,
	infix_tag: infix_tag_1,
	forward_tag: forward_tag_1,
	no_scan_tag: no_scan_tag_1,
	abstract_tag: abstract_tag_1,
	string_tag: string_tag_1,
	double_tag: double_tag_1,
	double_array_tag: double_array_tag_1,
	custom_tag: custom_tag_1,
	final_tag: final_tag_1,
	int_tag: int_tag_1,
	out_of_heap_tag: out_of_heap_tag_1,
	unaligned_tag: unaligned_tag_1,
	extension_constructor: extension_constructor_1,
	extension_name: extension_name_1,
	extension_id: extension_id_1,
	marshal: marshal_1,
	unmarshal: unmarshal_1,
	Ephemeron: Ephemeron_1
};

var Undefined = caml_exceptions.create("CamlinternalLazy.Undefined");

function raise_undefined(param) {
  throw Undefined;
}

function force_lazy_block(blk) {
  var closure = blk[0];
  blk[0] = raise_undefined;
  try {
    var result = curry._1(closure, /* () */0);
    blk[0] = result;
    caml_obj.caml_obj_set_tag(blk, obj.forward_tag);
    return result;
  }
  catch (e){
    blk[0] = (function (param) {
        throw e;
      });
    throw e;
  }
}

function force_val_lazy_block(blk) {
  var closure = blk[0];
  blk[0] = raise_undefined;
  var result = curry._1(closure, /* () */0);
  blk[0] = result;
  caml_obj.caml_obj_set_tag(blk, obj.forward_tag);
  return result;
}

function force(lzv) {
  var t = lzv.tag | 0;
  if (t === obj.forward_tag) {
    return lzv[0];
  } else if (t !== obj.lazy_tag) {
    return lzv;
  } else {
    return force_lazy_block(lzv);
  }
}

function force_val(lzv) {
  var t = lzv.tag | 0;
  if (t === obj.forward_tag) {
    return lzv[0];
  } else if (t !== obj.lazy_tag) {
    return lzv;
  } else {
    return force_val_lazy_block(lzv);
  }
}

var Undefined_1 = Undefined;
var force_lazy_block_1 = force_lazy_block;
var force_val_lazy_block_1 = force_val_lazy_block;
var force_1 = force;
var force_val_1 = force_val;
/* No side effect */

var camlinternalLazy = {
	Undefined: Undefined_1,
	force_lazy_block: force_lazy_block_1,
	force_val_lazy_block: force_val_lazy_block_1,
	force: force_1,
	force_val: force_val_1
};

var current_dir_name = ".";

function is_dir_sep(s, i) {
  return caml_string.get(s, i) === /* "/" */47;
}

function is_relative(n) {
  if (n.length < 1) {
    return true;
  } else {
    return caml_string.get(n, 0) !== /* "/" */47;
  }
}

function is_implicit(n) {
  if (is_relative(n) && (n.length < 2 || string.sub(n, 0, 2) !== "./")) {
    if (n.length < 3) {
      return true;
    } else {
      return string.sub(n, 0, 3) !== "../";
    }
  } else {
    return false;
  }
}

function check_suffix(name, suff) {
  if (name.length >= suff.length) {
    return string.sub(name, name.length - suff.length | 0, suff.length) === suff;
  } else {
    return false;
  }
}

var temp_dir_name;

try {
  temp_dir_name = caml_sys.caml_sys_getenv("TMPDIR");
}
catch (exn){
  if (exn === caml_builtin_exceptions.not_found) {
    temp_dir_name = "/tmp";
  } else {
    throw exn;
  }
}

function quote(param) {
  var quotequote = "'\\''";
  var s = param;
  var l = s.length;
  var b = buffer.create(l + 20 | 0);
  buffer.add_char(b, /* "'" */39);
  for(var i = 0 ,i_finish = l - 1 | 0; i <= i_finish; ++i){
    if (caml_string.get(s, i) === /* "'" */39) {
      buffer.add_string(b, quotequote);
    } else {
      buffer.add_char(b, caml_string.get(s, i));
    }
  }
  buffer.add_char(b, /* "'" */39);
  return buffer.contents(b);
}

function basename(param) {
  var is_dir_sep$1 = is_dir_sep;
  var current_dir_name$1 = current_dir_name;
  var name = param;
  if (name === "") {
    return current_dir_name$1;
  } else {
    var _n = name.length - 1 | 0;
    while(true) {
      var n = _n;
      if (n < 0) {
        return string.sub(name, 0, 1);
      } else if (curry._2(is_dir_sep$1, name, n)) {
        _n = n - 1 | 0;
        continue ;
      } else {
        var _n$1 = n;
        var p = n + 1 | 0;
        while(true) {
          var n$1 = _n$1;
          if (n$1 < 0) {
            return string.sub(name, 0, p);
          } else if (curry._2(is_dir_sep$1, name, n$1)) {
            return string.sub(name, n$1 + 1 | 0, (p - n$1 | 0) - 1 | 0);
          } else {
            _n$1 = n$1 - 1 | 0;
            continue ;
          }
        }      }
    }  }
}

function dirname(param) {
  var is_dir_sep$1 = is_dir_sep;
  var current_dir_name$1 = current_dir_name;
  var name = param;
  if (name === "") {
    return current_dir_name$1;
  } else {
    var _n = name.length - 1 | 0;
    while(true) {
      var n = _n;
      if (n < 0) {
        return string.sub(name, 0, 1);
      } else if (curry._2(is_dir_sep$1, name, n)) {
        _n = n - 1 | 0;
        continue ;
      } else {
        var _n$1 = n;
        while(true) {
          var n$1 = _n$1;
          if (n$1 < 0) {
            return current_dir_name$1;
          } else if (curry._2(is_dir_sep$1, name, n$1)) {
            var _n$2 = n$1;
            while(true) {
              var n$2 = _n$2;
              if (n$2 < 0) {
                return string.sub(name, 0, 1);
              } else if (curry._2(is_dir_sep$1, name, n$2)) {
                _n$2 = n$2 - 1 | 0;
                continue ;
              } else {
                return string.sub(name, 0, n$2 + 1 | 0);
              }
            }          } else {
            _n$1 = n$1 - 1 | 0;
            continue ;
          }
        }      }
    }  }
}

var temp_dir_name$1 = temp_dir_name;

var is_dir_sep$1 = is_dir_sep;

var dir_sep = "/";

function concat$3(dirname, filename) {
  var l = dirname.length;
  if (l === 0 || curry._2(is_dir_sep$1, dirname, l - 1 | 0)) {
    return dirname + filename;
  } else {
    return dirname + (dir_sep + filename);
  }
}

function chop_suffix(name, suff) {
  var n = name.length - suff.length | 0;
  if (n < 0) {
    throw [
          caml_builtin_exceptions.invalid_argument,
          "Filename.chop_suffix"
        ];
  }
  return string.sub(name, 0, n);
}

function extension_len(name) {
  var _i = name.length - 1 | 0;
  while(true) {
    var i = _i;
    if (i < 0 || curry._2(is_dir_sep$1, name, i)) {
      return 0;
    } else if (caml_string.get(name, i) === /* "." */46) {
      var i0 = i;
      var _i$1 = i - 1 | 0;
      while(true) {
        var i$1 = _i$1;
        if (i$1 < 0 || curry._2(is_dir_sep$1, name, i$1)) {
          return 0;
        } else if (caml_string.get(name, i$1) === /* "." */46) {
          _i$1 = i$1 - 1 | 0;
          continue ;
        } else {
          return name.length - i0 | 0;
        }
      }    } else {
      _i = i - 1 | 0;
      continue ;
    }
  }}

function extension(name) {
  var l = extension_len(name);
  if (l === 0) {
    return "";
  } else {
    return string.sub(name, name.length - l | 0, l);
  }
}

function chop_extension(name) {
  var l = extension_len(name);
  if (l === 0) {
    throw [
          caml_builtin_exceptions.invalid_argument,
          "Filename.chop_extension"
        ];
  }
  return string.sub(name, 0, name.length - l | 0);
}

function remove_extension(name) {
  var l = extension_len(name);
  if (l === 0) {
    return name;
  } else {
    return string.sub(name, 0, name.length - l | 0);
  }
}

var prng = caml_obj.caml_lazy_make((function (param) {
        return random.State.make_self_init(/* () */0);
      }));

function temp_file_name(temp_dir, prefix, suffix) {
  var rnd = random.State.bits(camlinternalLazy.force(prng)) & 16777215;
  return concat$3(temp_dir, curry._3(printf_1.sprintf(/* Format */[
                      /* String */block.__(2, [
                          /* No_padding */0,
                          /* Int */block.__(4, [
                              /* Int_x */6,
                              /* Lit_padding */block.__(0, [
                                  /* Zeros */2,
                                  6
                                ]),
                              /* No_precision */0,
                              /* String */block.__(2, [
                                  /* No_padding */0,
                                  /* End_of_format */0
                                ])
                            ])
                        ]),
                      "%s%06x%s"
                    ]), prefix, rnd, suffix));
}

var current_temp_dir_name = {
  contents: temp_dir_name$1
};

function set_temp_dir_name(s) {
  current_temp_dir_name.contents = s;
  return /* () */0;
}

function get_temp_dir_name(param) {
  return current_temp_dir_name.contents;
}

function temp_file($staropt$star, prefix, suffix) {
  var temp_dir = $staropt$star !== undefined ? $staropt$star : current_temp_dir_name.contents;
  var _counter = 0;
  while(true) {
    var counter = _counter;
    var name = temp_file_name(temp_dir, prefix, suffix);
    try {
      caml_external_polyfill.resolve("caml_sys_close")(caml_external_polyfill.resolve("caml_sys_open")(name, /* :: */[
                /* Open_wronly */1,
                /* :: */[
                  /* Open_creat */3,
                  /* :: */[
                    /* Open_excl */5,
                    /* [] */0
                  ]
                ]
              ], 384));
      return name;
    }
    catch (raw_e){
      var e = caml_js_exceptions.internalToOCamlException(raw_e);
      if (e[0] === caml_builtin_exceptions.sys_error) {
        if (counter >= 1000) {
          throw e;
        }
        _counter = counter + 1 | 0;
        continue ;
      } else {
        throw e;
      }
    }
  }}

function open_temp_file($staropt$star, $staropt$star$1, $staropt$star$2, prefix, suffix) {
  var mode = $staropt$star !== undefined ? $staropt$star : /* :: */[
      /* Open_text */7,
      /* [] */0
    ];
  var perms = $staropt$star$1 !== undefined ? $staropt$star$1 : 384;
  var temp_dir = $staropt$star$2 !== undefined ? $staropt$star$2 : current_temp_dir_name.contents;
  var _counter = 0;
  while(true) {
    var counter = _counter;
    var name = temp_file_name(temp_dir, prefix, suffix);
    try {
      return /* tuple */[
              name,
              pervasives.open_out_gen(/* :: */[
                    /* Open_wronly */1,
                    /* :: */[
                      /* Open_creat */3,
                      /* :: */[
                        /* Open_excl */5,
                        mode
                      ]
                    ]
                  ], perms, name)
            ];
    }
    catch (raw_e){
      var e = caml_js_exceptions.internalToOCamlException(raw_e);
      if (e[0] === caml_builtin_exceptions.sys_error) {
        if (counter >= 1000) {
          throw e;
        }
        _counter = counter + 1 | 0;
        continue ;
      } else {
        throw e;
      }
    }
  }}

var current_dir_name$1 = current_dir_name;

var parent_dir_name = "..";

var is_relative$1 = is_relative;

var is_implicit$1 = is_implicit;

var check_suffix$1 = check_suffix;

var basename$1 = basename;

var dirname$1 = dirname;

var quote$1 = quote;

var current_dir_name_1 = current_dir_name$1;
var parent_dir_name_1 = parent_dir_name;
var dir_sep_1 = dir_sep;
var concat_1$3 = concat$3;
var is_relative_1 = is_relative$1;
var is_implicit_1 = is_implicit$1;
var check_suffix_1 = check_suffix$1;
var chop_suffix_1 = chop_suffix;
var extension_1 = extension;
var remove_extension_1 = remove_extension;
var chop_extension_1 = chop_extension;
var basename_1 = basename$1;
var dirname_1 = dirname$1;
var temp_file_1 = temp_file;
var open_temp_file_1 = open_temp_file;
var get_temp_dir_name_1 = get_temp_dir_name;
var set_temp_dir_name_1 = set_temp_dir_name;
var temp_dir_name_1 = temp_dir_name$1;
var quote_1 = quote$1;
/* No side effect */

var filename = {
	current_dir_name: current_dir_name_1,
	parent_dir_name: parent_dir_name_1,
	dir_sep: dir_sep_1,
	concat: concat_1$3,
	is_relative: is_relative_1,
	is_implicit: is_implicit_1,
	check_suffix: check_suffix_1,
	chop_suffix: chop_suffix_1,
	extension: extension_1,
	remove_extension: remove_extension_1,
	chop_extension: chop_extension_1,
	basename: basename_1,
	dirname: dirname_1,
	temp_file: temp_file_1,
	open_temp_file: open_temp_file_1,
	get_temp_dir_name: get_temp_dir_name_1,
	set_temp_dir_name: set_temp_dir_name_1,
	temp_dir_name: temp_dir_name_1,
	quote: quote_1
};

function forEachU(opt, f) {
  if (opt !== undefined) {
    return f(caml_option.valFromOption(opt));
  } else {
    return /* () */0;
  }
}

function forEach(opt, f) {
  return forEachU(opt, curry.__1(f));
}

function getExn(param) {
  if (param !== undefined) {
    return caml_option.valFromOption(param);
  } else {
    throw new Error("getExn");
  }
}

function mapWithDefaultU(opt, $$default, f) {
  if (opt !== undefined) {
    return f(caml_option.valFromOption(opt));
  } else {
    return $$default;
  }
}

function mapWithDefault(opt, $$default, f) {
  return mapWithDefaultU(opt, $$default, curry.__1(f));
}

function mapU(opt, f) {
  if (opt !== undefined) {
    return caml_option.some(f(caml_option.valFromOption(opt)));
  }
  
}

function map$3(opt, f) {
  return mapU(opt, curry.__1(f));
}

function flatMapU(opt, f) {
  if (opt !== undefined) {
    return f(caml_option.valFromOption(opt));
  }
  
}

function flatMap(opt, f) {
  return flatMapU(opt, curry.__1(f));
}

function getWithDefault(opt, $$default) {
  if (opt !== undefined) {
    return caml_option.valFromOption(opt);
  } else {
    return $$default;
  }
}

function isSome(param) {
  return param !== undefined;
}

function isNone(x) {
  return x === undefined;
}

function eqU(a, b, f) {
  if (a !== undefined) {
    if (b !== undefined) {
      return f(caml_option.valFromOption(a), caml_option.valFromOption(b));
    } else {
      return false;
    }
  } else {
    return b === undefined;
  }
}

function eq$1(a, b, f) {
  return eqU(a, b, curry.__2(f));
}

function cmpU(a, b, f) {
  if (a !== undefined) {
    if (b !== undefined) {
      return f(caml_option.valFromOption(a), caml_option.valFromOption(b));
    } else {
      return 1;
    }
  } else if (b !== undefined) {
    return -1;
  } else {
    return 0;
  }
}

function cmp(a, b, f) {
  return cmpU(a, b, curry.__2(f));
}

var forEachU_1 = forEachU;
var forEach_1 = forEach;
var getExn_1 = getExn;
var mapWithDefaultU_1 = mapWithDefaultU;
var mapWithDefault_1 = mapWithDefault;
var mapU_1 = mapU;
var map_1$3 = map$3;
var flatMapU_1 = flatMapU;
var flatMap_1 = flatMap;
var getWithDefault_1 = getWithDefault;
var isSome_1 = isSome;
var isNone_1 = isNone;
var eqU_1 = eqU;
var eq_1$1 = eq$1;
var cmpU_1 = cmpU;
var cmp_1 = cmp;
/* No side effect */

var belt_Option = {
	forEachU: forEachU_1,
	forEach: forEach_1,
	getExn: getExn_1,
	mapWithDefaultU: mapWithDefaultU_1,
	mapWithDefault: mapWithDefault_1,
	mapU: mapU_1,
	map: map_1$3,
	flatMapU: flatMapU_1,
	flatMap: flatMap_1,
	getWithDefault: getWithDefault_1,
	isSome: isSome_1,
	isNone: isNone_1,
	eqU: eqU_1,
	eq: eq_1$1,
	cmpU: cmpU_1,
	cmp: cmp_1
};

function getExn$1(param) {
  if (param.tag) {
    throw new Error("getExn");
  } else {
    return param[0];
  }
}

function mapWithDefaultU$1(opt, $$default, f) {
  if (opt.tag) {
    return $$default;
  } else {
    return f(opt[0]);
  }
}

function mapWithDefault$1(opt, $$default, f) {
  return mapWithDefaultU$1(opt, $$default, curry.__1(f));
}

function mapU$1(opt, f) {
  if (opt.tag) {
    return /* Error */block.__(1, [opt[0]]);
  } else {
    return /* Ok */block.__(0, [f(opt[0])]);
  }
}

function map$4(opt, f) {
  return mapU$1(opt, curry.__1(f));
}

function flatMapU$1(opt, f) {
  if (opt.tag) {
    return /* Error */block.__(1, [opt[0]]);
  } else {
    return f(opt[0]);
  }
}

function flatMap$1(opt, f) {
  return flatMapU$1(opt, curry.__1(f));
}

function getWithDefault$1(opt, $$default) {
  if (opt.tag) {
    return $$default;
  } else {
    return opt[0];
  }
}

function isOk(param) {
  if (param.tag) {
    return false;
  } else {
    return true;
  }
}

function isError(param) {
  if (param.tag) {
    return true;
  } else {
    return false;
  }
}

function eqU$1(a, b, f) {
  if (a.tag) {
    if (b.tag) {
      return true;
    } else {
      return false;
    }
  } else if (b.tag) {
    return false;
  } else {
    return f(a[0], b[0]);
  }
}

function eq$2(a, b, f) {
  return eqU$1(a, b, curry.__2(f));
}

function cmpU$1(a, b, f) {
  if (a.tag) {
    if (b.tag) {
      return 0;
    } else {
      return -1;
    }
  } else if (b.tag) {
    return 1;
  } else {
    return f(a[0], b[0]);
  }
}

function cmp$1(a, b, f) {
  return cmpU$1(a, b, curry.__2(f));
}

var getExn_1$1 = getExn$1;
var mapWithDefaultU_1$1 = mapWithDefaultU$1;
var mapWithDefault_1$1 = mapWithDefault$1;
var mapU_1$1 = mapU$1;
var map_1$4 = map$4;
var flatMapU_1$1 = flatMapU$1;
var flatMap_1$1 = flatMap$1;
var getWithDefault_1$1 = getWithDefault$1;
var isOk_1 = isOk;
var isError_1 = isError;
var eqU_1$1 = eqU$1;
var eq_1$2 = eq$2;
var cmpU_1$1 = cmpU$1;
var cmp_1$1 = cmp$1;
/* No side effect */

var belt_Result = {
	getExn: getExn_1$1,
	mapWithDefaultU: mapWithDefaultU_1$1,
	mapWithDefault: mapWithDefault_1$1,
	mapU: mapU_1$1,
	map: map_1$4,
	flatMapU: flatMapU_1$1,
	flatMap: flatMap_1$1,
	getWithDefault: getWithDefault_1$1,
	isOk: isOk_1,
	isError: isError_1,
	eqU: eqU_1$1,
	eq: eq_1$2,
	cmpU: cmpU_1$1,
	cmp: cmp_1$1
};

function setupChromeDebugger (unit){
 
 // I don't know how to directly refer to the classes that chrome's built-in
 // formatters use. adding "class": "foo" doesn't seem to work
 // tree-outline
 var olStyle = {"style": "list-style-type: none; padding-left: 12px; margin: 0"};
 // object-properties-section-separator
 var colonStyle = {"style": "flex-shrink: 0; padding-right: 5px"};
 

 var showObject = function (value) {
   if (value == undefined) {
     return value + ''
   } else {
     return ["object", {"object": value}]
   }
 };
 

var listToArray = function (data){
 var result = [];
 var cur = data;
 var index = 0;
 while(typeof cur !== "number"){
   result.push([
     "li",
     {},
     ["span", {"style": "color: rgb(227, 110, 236)"}, index],
     ["span", colonStyle, ":"],
     showObject(cur[0])
   ]);
   cur = cur[1];
   index++;
 }
 return result
};

var variantCustomFormatter = function (data,recordVariant){
 if(recordVariant === "::"){
   return [
     "ol",
     olStyle,
     ... listToArray(data)
   ]
 } else {
    let spacedData = [];
    data.forEach(cur => {
      spacedData.push(["span", {"style": "margin-right: 12px"}, showObject(cur)]);
    });
     return ["ol", olStyle, ...spacedData]
 }

};

var variantPreview = function (x, recordVariant){
 if(recordVariant === "::") {
   // show the length, just like for array
   var length = listToArray(x).length;
   return ['span', {}, `list(${length})`]
 }
 return ['span', {}, `${recordVariant}()`]
};
var isOCamlExceptionOrExtensionHead = function(x){
 return Array.isArray(x) && x.tag === 248 && typeof x[0] === "string"
};
var isOCamlExceptionOrExtension = function(x){
 return Array.isArray(x) &&
       x[0] !== undefined &&
       isOCamlExceptionOrExtensionHead(x[0])
};
var formatter = {
 header: function (x) {
     var recordVariant;
     var recordPolyVar;
     if ((recordVariant =  x[Symbol.for('BsVariant')]) !== undefined){
         return variantPreview(x, recordVariant)
     } else if (isOCamlExceptionOrExtension(x)){
       return ['div',{}, `${x[0][0]}()`]     
     } else if ((recordPolyVar = x[Symbol.for('BsPolyVar')] ) !== undefined){
       return ['div', {}, `\`${recordPolyVar}#${x[0]}`]
     }
     return null
 },
 hasBody: function (x) {
     var recordVariant;
     var recordPolyVar;
     if ((recordVariant = x[Symbol.for('BsVariant')] ) !== undefined){
         return recordVariant
     } else if(isOCamlExceptionOrExtension(x)){
       return true
     } else if( (recordPolyVar = x[Symbol.for('BsPolyVar')]) !== undefined){
       return true
     }
     return false
 },
 body: function (x) {
     var recordVariant;
     var recordPolyVar;
     if ((recordVariant = x[Symbol.for('BsVariant')]) !== undefined) {
             return variantCustomFormatter(x,recordVariant)
     }
     else if ((recordPolyVar = x [Symbol.for('BsPolyVar')]) !== undefined){
       return showObject(x[1])
     }
     else if(isOCamlExceptionOrExtension(x)){
       return ["ol", olStyle, ... x.slice(1).map(cur => showObject(cur))]
     }

 }

};
if (typeof window === "undefined"){
 commonjsGlobal.devtoolsFormatters = [formatter];
} else {
 window.devtoolsFormatters = [formatter];
}
return 0

}
var setup = {
  contents: false
};

function setupOnce(param) {
  if (setup.contents) {
    return 0;
  } else {
    setup.contents = true;
    return setupChromeDebugger();
  }
}

function variant(meta, tag, xs) {
  setupOnce();
  xs.tag = tag;
  return Object.defineProperty(xs, Symbol.for("BsVariant"), {
              value: meta
            });
}

function simpleVariant(meta, xs) {
  setupOnce();
  return Object.defineProperty(xs, Symbol.for("BsVariant"), {
              value: meta
            });
}

function polyVar(meta, xs) {
  setupOnce();
  return Object.defineProperty(xs, Symbol.for("BsPolyVar"), {
              value: meta
            });
}

var __$1 = block.__;

var ___1$1 = __$1;
var variant_1 = variant;
var simpleVariant_1 = simpleVariant;
var polyVar_1 = polyVar;
/* No side effect */

var caml_chrome_debugger = {
	__: ___1$1,
	variant: variant_1,
	simpleVariant: simpleVariant_1,
	polyVar: polyVar_1
};

function $less$less(f, g, x) {
  return curry._1(f, curry._1(g, x));
}

var Caml = {
  List: /* alias */0,
  $$String: /* alias */0
};

var Path = {
  $slash: nodePath.join
};

function kebab(str) {
  var charStrings = str.split("");
  var k = array.map((function (c) {
              var c$1 = caml_string.get(c, 0);
              if (c$1 === /* " " */32 || c$1 === /* "_" */95) {
                return string.make(1, /* "-" */45);
              } else if (char_1.uppercase_ascii(c$1) !== char_1.lowercase_ascii(c$1) && char_1.uppercase_ascii(c$1) === c$1) {
                return "-" + string.make(1, char_1.lowercase_ascii(c$1));
              } else {
                return string.make(1, c$1);
              }
            }), charStrings).join("").replace((/\-\-+/g), "-");
  if (k.split("")[0] === "-") {
    return string.sub(k, 1, k.length - 1 | 0);
  } else {
    return k;
  }
}

function removeScope(kebab) {
  return kebab.replace((/[^\/]*\//g), "");
}

function upperCamelCasify(kebab) {
  var parts = kebab.split("-");
  var k = array.map(string.capitalize_ascii, parts).join("");
  if (caml_string.get(k, 0) === /* "-" */45) {
    return string.sub(k, 1, k.length - 1 | 0);
  } else {
    return k;
  }
}

function renderAsciiTree(dir, name, namespace, $$require, isLast) {
  if (isLast) {
    return curry._3(printf_1.sprintf(/* Format */caml_chrome_debugger.simpleVariant("Format", [
                      /* String_literal */caml_chrome_debugger.variant("String_literal", 11, [
                          "\xe2\x94\x82\\n\xe2\x94\x94\xe2\x94\x80 ",
                          /* String */caml_chrome_debugger.variant("String", 2, [
                              /* No_padding */0,
                              /* String_literal */caml_chrome_debugger.variant("String_literal", 11, [
                                  "\\n   ",
                                  /* String */caml_chrome_debugger.variant("String", 2, [
                                      /* No_padding */0,
                                      /* String_literal */caml_chrome_debugger.variant("String_literal", 11, [
                                          "\\n   ",
                                          /* String */caml_chrome_debugger.variant("String", 2, [
                                              /* No_padding */0,
                                              /* String_literal */caml_chrome_debugger.variant("String_literal", 11, [
                                                  "\\n",
                                                  /* End_of_format */0
                                                ])
                                            ])
                                        ])
                                    ])
                                ])
                            ])
                        ]),
                      "\xe2\x94\x82\\n\xe2\x94\x94\xe2\x94\x80 %s\\n   %s\\n   %s\\n"
                    ])), dir, name, namespace);
  } else {
    var match = $$require === "";
    return curry._3(printf_1.sprintf(/* Format */caml_chrome_debugger.simpleVariant("Format", [
                      /* String_literal */caml_chrome_debugger.variant("String_literal", 11, [
                          "\xe2\x94\x82\\n\xe2\x94\x9c\xe2\x94\x80 ",
                          /* String */caml_chrome_debugger.variant("String", 2, [
                              /* No_padding */0,
                              /* String_literal */caml_chrome_debugger.variant("String_literal", 11, [
                                  "\\n\xe2\x94\x82  ",
                                  /* String */caml_chrome_debugger.variant("String", 2, [
                                      /* No_padding */0,
                                      /* String_literal */caml_chrome_debugger.variant("String_literal", 11, [
                                          "\\n\xe2\x94\x82  ",
                                          /* String */caml_chrome_debugger.variant("String", 2, [
                                              /* No_padding */0,
                                              /* String_literal */caml_chrome_debugger.variant("String_literal", 11, [
                                                  "\\n",
                                                  /* End_of_format */0
                                                ])
                                            ])
                                        ])
                                    ])
                                ])
                            ])
                        ]),
                      "\xe2\x94\x82\\n\xe2\x94\x9c\xe2\x94\x80 %s\\n\xe2\x94\x82  %s\\n\xe2\x94\x82  %s\\n"
                    ])), dir, name, namespace) + (
            match ? "" : (
                isLast ? "   " : "\xe2\x94\x82  "
              ) + $$require
          );
  }
}

function $$return(x) {
  return /* Ok */caml_chrome_debugger.variant("Ok", 0, [x]);
}

function fail(x) {
  return /* Error */caml_chrome_debugger.variant("Error", 1, [x]);
}

var Result = {
  $great$great$eq: belt_Result.flatMap,
  $great$great$pipe: belt_Result.map,
  $$return: $$return,
  fail: fail
};

function $$return$1(x) {
  return caml_option.some(x);
}

var $$Option = {
  $great$great$eq: belt_Option.flatMap,
  $great$great$pipe: belt_Option.map,
  $$return: $$return$1
};

function $great$great$eq(rp, f) {
  return rp.then((function (param) {
                if (param.tag) {
                  return Promise.resolve(/* Error */caml_chrome_debugger.variant("Error", 1, [param[0]]));
                } else {
                  return curry._1(f, param[0]);
                }
              }));
}

function $great$great$pipe(rp, f) {
  return rp.then((function (param) {
                if (param.tag) {
                  return Promise.resolve(/* Error */caml_chrome_debugger.variant("Error", 1, [param[0]]));
                } else {
                  return Promise.resolve(/* Ok */caml_chrome_debugger.variant("Ok", 0, [curry._1(f, param[0])]));
                }
              }));
}

function ok(x) {
  return Promise.resolve(/* Ok */caml_chrome_debugger.variant("Ok", 0, [x]));
}

function fail$1(x) {
  return Promise.resolve(/* Error */caml_chrome_debugger.variant("Error", 1, [x]));
}

var ResultPromise = {
  $great$great$eq: $great$great$eq,
  $great$great$pipe: $great$great$pipe,
  ok: ok,
  fail: fail$1
};

var spf = printf_1.sprintf;

var parent = filename.dirname;

var $less$less_1 = $less$less;
var Caml_1 = Caml;
var Path_1 = Path;
var spf_1 = spf;
var parent_1 = parent;
var kebab_1 = kebab;
var removeScope_1 = removeScope;
var upperCamelCasify_1 = upperCamelCasify;
var renderAsciiTree_1 = renderAsciiTree;
var Result_1 = Result;
var $$Option_1 = $$Option;
var ResultPromise_1 = ResultPromise;
/* No side effect */

var Utils_bs = {
	$less$less: $less$less_1,
	Caml: Caml_1,
	Path: Path_1,
	spf: spf_1,
	parent: parent_1,
	kebab: kebab_1,
	removeScope: removeScope_1,
	upperCamelCasify: upperCamelCasify_1,
	renderAsciiTree: renderAsciiTree_1,
	Result: Result_1,
	$$Option: $$Option_1,
	ResultPromise: ResultPromise_1
};

function get$2(dict, k) {
  if ((k in dict)) {
    return caml_option.some(dict[k]);
  }
  
}

function unsafeDeleteKey (dict,key){
     delete dict[key];
     return 0
  }
function entries(dict) {
  var keys = Object.keys(dict);
  var l = keys.length;
  var values = new Array(l);
  for(var i = 0 ,i_finish = l - 1 | 0; i <= i_finish; ++i){
    var key = keys[i];
    values[i] = /* tuple */[
      key,
      dict[key]
    ];
  }
  return values;
}

function values(dict) {
  var keys = Object.keys(dict);
  var l = keys.length;
  var values$1 = new Array(l);
  for(var i = 0 ,i_finish = l - 1 | 0; i <= i_finish; ++i){
    values$1[i] = dict[keys[i]];
  }
  return values$1;
}

function fromList(entries) {
  var dict = { };
  var _param = entries;
  while(true) {
    var param = _param;
    if (param) {
      var match = param[0];
      dict[match[0]] = match[1];
      _param = param[1];
      continue ;
    } else {
      return dict;
    }
  }}

function fromArray(entries) {
  var dict = { };
  var l = entries.length;
  for(var i = 0 ,i_finish = l - 1 | 0; i <= i_finish; ++i){
    var match = entries[i];
    dict[match[0]] = match[1];
  }
  return dict;
}

function map$5(f, source) {
  var target = { };
  var keys = Object.keys(source);
  var l = keys.length;
  for(var i = 0 ,i_finish = l - 1 | 0; i <= i_finish; ++i){
    var key = keys[i];
    target[key] = f(source[key]);
  }
  return target;
}

var get_1$2 = get$2;
var unsafeDeleteKey_1 = unsafeDeleteKey;
var entries_1 = entries;
var values_1 = values;
var fromList_1 = fromList;
var fromArray_1 = fromArray;
var map_1$5 = map$5;
/* No side effect */

var js_dict = {
	get: get_1$2,
	unsafeDeleteKey: unsafeDeleteKey_1,
	entries: entries_1,
	values: values_1,
	fromList: fromList_1,
	fromArray: fromArray_1,
	map: map_1$5
};

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


var isWindows = process.platform === 'win32';


// JavaScript implementation of realpath, ported from node pre-v6

var DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);

function rethrow() {
  // Only enable in debug mode. A backtrace uses ~1000 bytes of heap space and
  // is fairly slow to generate.
  var callback;
  if (DEBUG) {
    var backtrace = new Error;
    callback = debugCallback;
  } else
    callback = missingCallback;

  return callback;

  function debugCallback(err) {
    if (err) {
      backtrace.message = err.message;
      err = backtrace;
      missingCallback(err);
    }
  }

  function missingCallback(err) {
    if (err) {
      if (process.throwDeprecation)
        throw err;  // Forgot a callback but don't know where? Use NODE_DEBUG=fs
      else if (!process.noDeprecation) {
        var msg = 'fs: missing callback ' + (err.stack || err.message);
        if (process.traceDeprecation)
          console.trace(msg);
        else
          console.error(msg);
      }
    }
  }
}

function maybeCallback(cb) {
  return typeof cb === 'function' ? cb : rethrow();
}

var normalize = path$1.normalize;

// Regexp that finds the next partion of a (partial) path
// result is [base_with_slash, base], e.g. ['somedir/', 'somedir']
if (isWindows) {
  var nextPartRe = /(.*?)(?:[\/\\]+|$)/g;
} else {
  var nextPartRe = /(.*?)(?:[\/]+|$)/g;
}

// Regex to find the device root, including trailing slash. E.g. 'c:\\'.
if (isWindows) {
  var splitRootRe = /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/;
} else {
  var splitRootRe = /^[\/]*/;
}

var realpathSync = function realpathSync(p, cache) {
  // make p is absolute
  p = path$1.resolve(p);

  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
    return cache[p];
  }

  var original = p,
      seenLinks = {},
      knownHard = {};

  // current character position in p
  var pos;
  // the partial path so far, including a trailing slash if any
  var current;
  // the partial path without a trailing slash (except when pointing at a root)
  var base;
  // the partial path scanned in the previous round, with slash
  var previous;

  start();

  function start() {
    // Skip over roots
    var m = splitRootRe.exec(p);
    pos = m[0].length;
    current = m[0];
    base = m[0];
    previous = '';

    // On windows, check that the root exists. On unix there is no need.
    if (isWindows && !knownHard[base]) {
      fs.lstatSync(base);
      knownHard[base] = true;
    }
  }

  // walk down the path, swapping out linked pathparts for their real
  // values
  // NB: p.length changes.
  while (pos < p.length) {
    // find the next part
    nextPartRe.lastIndex = pos;
    var result = nextPartRe.exec(p);
    previous = current;
    current += result[0];
    base = previous + result[1];
    pos = nextPartRe.lastIndex;

    // continue if not a symlink
    if (knownHard[base] || (cache && cache[base] === base)) {
      continue;
    }

    var resolvedLink;
    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
      // some known symbolic link.  no need to stat again.
      resolvedLink = cache[base];
    } else {
      var stat = fs.lstatSync(base);
      if (!stat.isSymbolicLink()) {
        knownHard[base] = true;
        if (cache) cache[base] = base;
        continue;
      }

      // read the link if it wasn't read before
      // dev/ino always return 0 on windows, so skip the check.
      var linkTarget = null;
      if (!isWindows) {
        var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);
        if (seenLinks.hasOwnProperty(id)) {
          linkTarget = seenLinks[id];
        }
      }
      if (linkTarget === null) {
        fs.statSync(base);
        linkTarget = fs.readlinkSync(base);
      }
      resolvedLink = path$1.resolve(previous, linkTarget);
      // track this, if given a cache.
      if (cache) cache[base] = resolvedLink;
      if (!isWindows) seenLinks[id] = linkTarget;
    }

    // resolve the link, then start over
    p = path$1.resolve(resolvedLink, p.slice(pos));
    start();
  }

  if (cache) cache[original] = p;

  return p;
};


var realpath = function realpath(p, cache, cb) {
  if (typeof cb !== 'function') {
    cb = maybeCallback(cache);
    cache = null;
  }

  // make p is absolute
  p = path$1.resolve(p);

  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
    return process.nextTick(cb.bind(null, null, cache[p]));
  }

  var original = p,
      seenLinks = {},
      knownHard = {};

  // current character position in p
  var pos;
  // the partial path so far, including a trailing slash if any
  var current;
  // the partial path without a trailing slash (except when pointing at a root)
  var base;
  // the partial path scanned in the previous round, with slash
  var previous;

  start();

  function start() {
    // Skip over roots
    var m = splitRootRe.exec(p);
    pos = m[0].length;
    current = m[0];
    base = m[0];
    previous = '';

    // On windows, check that the root exists. On unix there is no need.
    if (isWindows && !knownHard[base]) {
      fs.lstat(base, function(err) {
        if (err) return cb(err);
        knownHard[base] = true;
        LOOP();
      });
    } else {
      process.nextTick(LOOP);
    }
  }

  // walk down the path, swapping out linked pathparts for their real
  // values
  function LOOP() {
    // stop if scanned past end of path
    if (pos >= p.length) {
      if (cache) cache[original] = p;
      return cb(null, p);
    }

    // find the next part
    nextPartRe.lastIndex = pos;
    var result = nextPartRe.exec(p);
    previous = current;
    current += result[0];
    base = previous + result[1];
    pos = nextPartRe.lastIndex;

    // continue if not a symlink
    if (knownHard[base] || (cache && cache[base] === base)) {
      return process.nextTick(LOOP);
    }

    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
      // known symbolic link.  no need to stat again.
      return gotResolvedLink(cache[base]);
    }

    return fs.lstat(base, gotStat);
  }

  function gotStat(err, stat) {
    if (err) return cb(err);

    // if not a symlink, skip to the next path part
    if (!stat.isSymbolicLink()) {
      knownHard[base] = true;
      if (cache) cache[base] = base;
      return process.nextTick(LOOP);
    }

    // stat & read the link if not read before
    // call gotTarget as soon as the link target is known
    // dev/ino always return 0 on windows, so skip the check.
    if (!isWindows) {
      var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);
      if (seenLinks.hasOwnProperty(id)) {
        return gotTarget(null, seenLinks[id], base);
      }
    }
    fs.stat(base, function(err) {
      if (err) return cb(err);

      fs.readlink(base, function(err, target) {
        if (!isWindows) seenLinks[id] = target;
        gotTarget(err, target);
      });
    });
  }

  function gotTarget(err, target, base) {
    if (err) return cb(err);

    var resolvedLink = path$1.resolve(previous, target);
    if (cache) cache[base] = resolvedLink;
    gotResolvedLink(resolvedLink);
  }

  function gotResolvedLink(resolvedLink) {
    // resolve the link, then start over
    p = path$1.resolve(resolvedLink, p.slice(pos));
    start();
  }
};

var old = {
	realpathSync: realpathSync,
	realpath: realpath
};

var fs_realpath = realpath$1;
realpath$1.realpath = realpath$1;
realpath$1.sync = realpathSync$1;
realpath$1.realpathSync = realpathSync$1;
realpath$1.monkeypatch = monkeypatch;
realpath$1.unmonkeypatch = unmonkeypatch;


var origRealpath = fs.realpath;
var origRealpathSync = fs.realpathSync;

var version = process.version;
var ok$1 = /^v[0-5]\./.test(version);


function newError (er) {
  return er && er.syscall === 'realpath' && (
    er.code === 'ELOOP' ||
    er.code === 'ENOMEM' ||
    er.code === 'ENAMETOOLONG'
  )
}

function realpath$1 (p, cache, cb) {
  if (ok$1) {
    return origRealpath(p, cache, cb)
  }

  if (typeof cache === 'function') {
    cb = cache;
    cache = null;
  }
  origRealpath(p, cache, function (er, result) {
    if (newError(er)) {
      old.realpath(p, cache, cb);
    } else {
      cb(er, result);
    }
  });
}

function realpathSync$1 (p, cache) {
  if (ok$1) {
    return origRealpathSync(p, cache)
  }

  try {
    return origRealpathSync(p, cache)
  } catch (er) {
    if (newError(er)) {
      return old.realpathSync(p, cache)
    } else {
      throw er
    }
  }
}

function monkeypatch () {
  fs.realpath = realpath$1;
  fs.realpathSync = realpathSync$1;
}

function unmonkeypatch () {
  fs.realpath = origRealpath;
  fs.realpathSync = origRealpathSync;
}

var concatMap = function (xs, fn) {
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        var x = fn(xs[i], i);
        if (isArray(x)) res.push.apply(res, x);
        else res.push(x);
    }
    return res;
};

var isArray = Array.isArray || function (xs) {
    return Object.prototype.toString.call(xs) === '[object Array]';
};

var balancedMatch = balanced;
function balanced(a, b, str) {
  if (a instanceof RegExp) a = maybeMatch(a, str);
  if (b instanceof RegExp) b = maybeMatch(b, str);

  var r = range(a, b, str);

  return r && {
    start: r[0],
    end: r[1],
    pre: str.slice(0, r[0]),
    body: str.slice(r[0] + a.length, r[1]),
    post: str.slice(r[1] + b.length)
  };
}

function maybeMatch(reg, str) {
  var m = str.match(reg);
  return m ? m[0] : null;
}

balanced.range = range;
function range(a, b, str) {
  var begs, beg, left, right, result;
  var ai = str.indexOf(a);
  var bi = str.indexOf(b, ai + 1);
  var i = ai;

  if (ai >= 0 && bi > 0) {
    begs = [];
    left = str.length;

    while (i >= 0 && !result) {
      if (i == ai) {
        begs.push(i);
        ai = str.indexOf(a, i + 1);
      } else if (begs.length == 1) {
        result = [ begs.pop(), bi ];
      } else {
        beg = begs.pop();
        if (beg < left) {
          left = beg;
          right = bi;
        }

        bi = str.indexOf(b, i + 1);
      }

      i = ai < bi && ai >= 0 ? ai : bi;
    }

    if (begs.length) {
      result = [ left, right ];
    }
  }

  return result;
}

var braceExpansion = expandTop;

var escSlash = '\0SLASH'+Math.random()+'\0';
var escOpen = '\0OPEN'+Math.random()+'\0';
var escClose = '\0CLOSE'+Math.random()+'\0';
var escComma = '\0COMMA'+Math.random()+'\0';
var escPeriod = '\0PERIOD'+Math.random()+'\0';

function numeric(str) {
  return parseInt(str, 10) == str
    ? parseInt(str, 10)
    : str.charCodeAt(0);
}

function escapeBraces(str) {
  return str.split('\\\\').join(escSlash)
            .split('\\{').join(escOpen)
            .split('\\}').join(escClose)
            .split('\\,').join(escComma)
            .split('\\.').join(escPeriod);
}

function unescapeBraces(str) {
  return str.split(escSlash).join('\\')
            .split(escOpen).join('{')
            .split(escClose).join('}')
            .split(escComma).join(',')
            .split(escPeriod).join('.');
}


// Basically just str.split(","), but handling cases
// where we have nested braced sections, which should be
// treated as individual members, like {a,{b,c},d}
function parseCommaParts(str) {
  if (!str)
    return [''];

  var parts = [];
  var m = balancedMatch('{', '}', str);

  if (!m)
    return str.split(',');

  var pre = m.pre;
  var body = m.body;
  var post = m.post;
  var p = pre.split(',');

  p[p.length-1] += '{' + body + '}';
  var postParts = parseCommaParts(post);
  if (post.length) {
    p[p.length-1] += postParts.shift();
    p.push.apply(p, postParts);
  }

  parts.push.apply(parts, p);

  return parts;
}

function expandTop(str) {
  if (!str)
    return [];

  // I don't know why Bash 4.3 does this, but it does.
  // Anything starting with {} will have the first two bytes preserved
  // but *only* at the top level, so {},a}b will not expand to anything,
  // but a{},b}c will be expanded to [a}c,abc].
  // One could argue that this is a bug in Bash, but since the goal of
  // this module is to match Bash's rules, we escape a leading {}
  if (str.substr(0, 2) === '{}') {
    str = '\\{\\}' + str.substr(2);
  }

  return expand(escapeBraces(str), true).map(unescapeBraces);
}

function embrace(str) {
  return '{' + str + '}';
}
function isPadded(el) {
  return /^-?0\d/.test(el);
}

function lte(i, y) {
  return i <= y;
}
function gte(i, y) {
  return i >= y;
}

function expand(str, isTop) {
  var expansions = [];

  var m = balancedMatch('{', '}', str);
  if (!m || /\$$/.test(m.pre)) return [str];

  var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
  var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
  var isSequence = isNumericSequence || isAlphaSequence;
  var isOptions = m.body.indexOf(',') >= 0;
  if (!isSequence && !isOptions) {
    // {a},b}
    if (m.post.match(/,.*\}/)) {
      str = m.pre + '{' + m.body + escClose + m.post;
      return expand(str);
    }
    return [str];
  }

  var n;
  if (isSequence) {
    n = m.body.split(/\.\./);
  } else {
    n = parseCommaParts(m.body);
    if (n.length === 1) {
      // x{{a,b}}y ==> x{a}y x{b}y
      n = expand(n[0], false).map(embrace);
      if (n.length === 1) {
        var post = m.post.length
          ? expand(m.post, false)
          : [''];
        return post.map(function(p) {
          return m.pre + n[0] + p;
        });
      }
    }
  }

  // at this point, n is the parts, and we know it's not a comma set
  // with a single entry.

  // no need to expand pre, since it is guaranteed to be free of brace-sets
  var pre = m.pre;
  var post = m.post.length
    ? expand(m.post, false)
    : [''];

  var N;

  if (isSequence) {
    var x = numeric(n[0]);
    var y = numeric(n[1]);
    var width = Math.max(n[0].length, n[1].length);
    var incr = n.length == 3
      ? Math.abs(numeric(n[2]))
      : 1;
    var test = lte;
    var reverse = y < x;
    if (reverse) {
      incr *= -1;
      test = gte;
    }
    var pad = n.some(isPadded);

    N = [];

    for (var i = x; test(i, y); i += incr) {
      var c;
      if (isAlphaSequence) {
        c = String.fromCharCode(i);
        if (c === '\\')
          c = '';
      } else {
        c = String(i);
        if (pad) {
          var need = width - c.length;
          if (need > 0) {
            var z = new Array(need + 1).join('0');
            if (i < 0)
              c = '-' + z + c.slice(1);
            else
              c = z + c;
          }
        }
      }
      N.push(c);
    }
  } else {
    N = concatMap(n, function(el) { return expand(el, false) });
  }

  for (var j = 0; j < N.length; j++) {
    for (var k = 0; k < post.length; k++) {
      var expansion = pre + N[j] + post[k];
      if (!isTop || isSequence || expansion)
        expansions.push(expansion);
    }
  }

  return expansions;
}

var minimatch_1 = minimatch;
minimatch.Minimatch = Minimatch;

var path = { sep: '/' };
try {
  path = path$1;
} catch (er) {}

var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {};


var plTypes = {
  '!': { open: '(?:(?!(?:', close: '))[^/]*?)'},
  '?': { open: '(?:', close: ')?' },
  '+': { open: '(?:', close: ')+' },
  '*': { open: '(?:', close: ')*' },
  '@': { open: '(?:', close: ')' }
};

// any single thing other than /
// don't need to escape / when using new RegExp()
var qmark = '[^/]';

// * => any number of characters
var star = qmark + '*?';

// ** when dots are allowed.  Anything goes, except .. and .
// not (^ or / followed by one or two dots followed by $ or /),
// followed by anything, any number of times.
var twoStarDot = '(?:(?!(?:\\\/|^)(?:\\.{1,2})($|\\\/)).)*?';

// not a ^ or / followed by a dot,
// followed by anything, any number of times.
var twoStarNoDot = '(?:(?!(?:\\\/|^)\\.).)*?';

// characters that need to be escaped in RegExp.
var reSpecials = charSet('().*{}+?[]^$\\!');

// "abc" -> { a:true, b:true, c:true }
function charSet (s) {
  return s.split('').reduce(function (set, c) {
    set[c] = true;
    return set
  }, {})
}

// normalizes slashes.
var slashSplit = /\/+/;

minimatch.filter = filter;
function filter (pattern, options) {
  options = options || {};
  return function (p, i, list) {
    return minimatch(p, pattern, options)
  }
}

function ext (a, b) {
  a = a || {};
  b = b || {};
  var t = {};
  Object.keys(b).forEach(function (k) {
    t[k] = b[k];
  });
  Object.keys(a).forEach(function (k) {
    t[k] = a[k];
  });
  return t
}

minimatch.defaults = function (def) {
  if (!def || !Object.keys(def).length) return minimatch

  var orig = minimatch;

  var m = function minimatch (p, pattern, options) {
    return orig.minimatch(p, pattern, ext(def, options))
  };

  m.Minimatch = function Minimatch (pattern, options) {
    return new orig.Minimatch(pattern, ext(def, options))
  };

  return m
};

Minimatch.defaults = function (def) {
  if (!def || !Object.keys(def).length) return Minimatch
  return minimatch.defaults(def).Minimatch
};

function minimatch (p, pattern, options) {
  if (typeof pattern !== 'string') {
    throw new TypeError('glob pattern string required')
  }

  if (!options) options = {};

  // shortcut: comments match nothing.
  if (!options.nocomment && pattern.charAt(0) === '#') {
    return false
  }

  // "" only matches ""
  if (pattern.trim() === '') return p === ''

  return new Minimatch(pattern, options).match(p)
}

function Minimatch (pattern, options) {
  if (!(this instanceof Minimatch)) {
    return new Minimatch(pattern, options)
  }

  if (typeof pattern !== 'string') {
    throw new TypeError('glob pattern string required')
  }

  if (!options) options = {};
  pattern = pattern.trim();

  // windows support: need to use /, not \
  if (path.sep !== '/') {
    pattern = pattern.split(path.sep).join('/');
  }

  this.options = options;
  this.set = [];
  this.pattern = pattern;
  this.regexp = null;
  this.negate = false;
  this.comment = false;
  this.empty = false;

  // make the set of regexps etc.
  this.make();
}

Minimatch.prototype.debug = function () {};

Minimatch.prototype.make = make$3;
function make$3 () {
  // don't do it more than once.
  if (this._made) return

  var pattern = this.pattern;
  var options = this.options;

  // empty patterns and comments match nothing.
  if (!options.nocomment && pattern.charAt(0) === '#') {
    this.comment = true;
    return
  }
  if (!pattern) {
    this.empty = true;
    return
  }

  // step 1: figure out negation, etc.
  this.parseNegate();

  // step 2: expand braces
  var set = this.globSet = this.braceExpand();

  if (options.debug) this.debug = console.error;

  this.debug(this.pattern, set);

  // step 3: now we have a set, so turn each one into a series of path-portion
  // matching patterns.
  // These will be regexps, except in the case of "**", which is
  // set to the GLOBSTAR object for globstar behavior,
  // and will not contain any / characters
  set = this.globParts = set.map(function (s) {
    return s.split(slashSplit)
  });

  this.debug(this.pattern, set);

  // glob --> regexps
  set = set.map(function (s, si, set) {
    return s.map(this.parse, this)
  }, this);

  this.debug(this.pattern, set);

  // filter out everything that didn't compile properly.
  set = set.filter(function (s) {
    return s.indexOf(false) === -1
  });

  this.debug(this.pattern, set);

  this.set = set;
}

Minimatch.prototype.parseNegate = parseNegate;
function parseNegate () {
  var pattern = this.pattern;
  var negate = false;
  var options = this.options;
  var negateOffset = 0;

  if (options.nonegate) return

  for (var i = 0, l = pattern.length
    ; i < l && pattern.charAt(i) === '!'
    ; i++) {
    negate = !negate;
    negateOffset++;
  }

  if (negateOffset) this.pattern = pattern.substr(negateOffset);
  this.negate = negate;
}

// Brace expansion:
// a{b,c}d -> abd acd
// a{b,}c -> abc ac
// a{0..3}d -> a0d a1d a2d a3d
// a{b,c{d,e}f}g -> abg acdfg acefg
// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
//
// Invalid sets are not expanded.
// a{2..}b -> a{2..}b
// a{b}c -> a{b}c
minimatch.braceExpand = function (pattern, options) {
  return braceExpand(pattern, options)
};

Minimatch.prototype.braceExpand = braceExpand;

function braceExpand (pattern, options) {
  if (!options) {
    if (this instanceof Minimatch) {
      options = this.options;
    } else {
      options = {};
    }
  }

  pattern = typeof pattern === 'undefined'
    ? this.pattern : pattern;

  if (typeof pattern === 'undefined') {
    throw new TypeError('undefined pattern')
  }

  if (options.nobrace ||
    !pattern.match(/\{.*\}/)) {
    // shortcut. no need to expand.
    return [pattern]
  }

  return braceExpansion(pattern)
}

// parse a component of the expanded set.
// At this point, no pattern may contain "/" in it
// so we're going to return a 2d array, where each entry is the full
// pattern, split on '/', and then turned into a regular expression.
// A regexp is made at the end which joins each array with an
// escaped /, and another full one which joins each regexp with |.
//
// Following the lead of Bash 4.1, note that "**" only has special meaning
// when it is the *only* thing in a path portion.  Otherwise, any series
// of * is equivalent to a single *.  Globstar behavior is enabled by
// default, and can be disabled by setting options.noglobstar.
Minimatch.prototype.parse = parse;
var SUBPARSE = {};
function parse (pattern, isSub) {
  if (pattern.length > 1024 * 64) {
    throw new TypeError('pattern is too long')
  }

  var options = this.options;

  // shortcuts
  if (!options.noglobstar && pattern === '**') return GLOBSTAR
  if (pattern === '') return ''

  var re = '';
  var hasMagic = !!options.nocase;
  var escaping = false;
  // ? => one single character
  var patternListStack = [];
  var negativeLists = [];
  var stateChar;
  var inClass = false;
  var reClassStart = -1;
  var classStart = -1;
  // . and .. never match anything that doesn't start with .,
  // even when options.dot is set.
  var patternStart = pattern.charAt(0) === '.' ? '' // anything
  // not (start or / followed by . or .. followed by / or end)
  : options.dot ? '(?!(?:^|\\\/)\\.{1,2}(?:$|\\\/))'
  : '(?!\\.)';
  var self = this;

  function clearStateChar () {
    if (stateChar) {
      // we had some state-tracking character
      // that wasn't consumed by this pass.
      switch (stateChar) {
        case '*':
          re += star;
          hasMagic = true;
        break
        case '?':
          re += qmark;
          hasMagic = true;
        break
        default:
          re += '\\' + stateChar;
        break
      }
      self.debug('clearStateChar %j %j', stateChar, re);
      stateChar = false;
    }
  }

  for (var i = 0, len = pattern.length, c
    ; (i < len) && (c = pattern.charAt(i))
    ; i++) {
    this.debug('%s\t%s %s %j', pattern, i, re, c);

    // skip over any that are escaped.
    if (escaping && reSpecials[c]) {
      re += '\\' + c;
      escaping = false;
      continue
    }

    switch (c) {
      case '/':
        // completely not allowed, even escaped.
        // Should already be path-split by now.
        return false

      case '\\':
        clearStateChar();
        escaping = true;
      continue

      // the various stateChar values
      // for the "extglob" stuff.
      case '?':
      case '*':
      case '+':
      case '@':
      case '!':
        this.debug('%s\t%s %s %j <-- stateChar', pattern, i, re, c);

        // all of those are literals inside a class, except that
        // the glob [!a] means [^a] in regexp
        if (inClass) {
          this.debug('  in class');
          if (c === '!' && i === classStart + 1) c = '^';
          re += c;
          continue
        }

        // if we already have a stateChar, then it means
        // that there was something like ** or +? in there.
        // Handle the stateChar, then proceed with this one.
        self.debug('call clearStateChar %j', stateChar);
        clearStateChar();
        stateChar = c;
        // if extglob is disabled, then +(asdf|foo) isn't a thing.
        // just clear the statechar *now*, rather than even diving into
        // the patternList stuff.
        if (options.noext) clearStateChar();
      continue

      case '(':
        if (inClass) {
          re += '(';
          continue
        }

        if (!stateChar) {
          re += '\\(';
          continue
        }

        patternListStack.push({
          type: stateChar,
          start: i - 1,
          reStart: re.length,
          open: plTypes[stateChar].open,
          close: plTypes[stateChar].close
        });
        // negation is (?:(?!js)[^/]*)
        re += stateChar === '!' ? '(?:(?!(?:' : '(?:';
        this.debug('plType %j %j', stateChar, re);
        stateChar = false;
      continue

      case ')':
        if (inClass || !patternListStack.length) {
          re += '\\)';
          continue
        }

        clearStateChar();
        hasMagic = true;
        var pl = patternListStack.pop();
        // negation is (?:(?!js)[^/]*)
        // The others are (?:<pattern>)<type>
        re += pl.close;
        if (pl.type === '!') {
          negativeLists.push(pl);
        }
        pl.reEnd = re.length;
      continue

      case '|':
        if (inClass || !patternListStack.length || escaping) {
          re += '\\|';
          escaping = false;
          continue
        }

        clearStateChar();
        re += '|';
      continue

      // these are mostly the same in regexp and glob
      case '[':
        // swallow any state-tracking char before the [
        clearStateChar();

        if (inClass) {
          re += '\\' + c;
          continue
        }

        inClass = true;
        classStart = i;
        reClassStart = re.length;
        re += c;
      continue

      case ']':
        //  a right bracket shall lose its special
        //  meaning and represent itself in
        //  a bracket expression if it occurs
        //  first in the list.  -- POSIX.2 2.8.3.2
        if (i === classStart + 1 || !inClass) {
          re += '\\' + c;
          escaping = false;
          continue
        }

        // handle the case where we left a class open.
        // "[z-a]" is valid, equivalent to "\[z-a\]"
        if (inClass) {
          // split where the last [ was, make sure we don't have
          // an invalid re. if so, re-walk the contents of the
          // would-be class to re-translate any characters that
          // were passed through as-is
          // TODO: It would probably be faster to determine this
          // without a try/catch and a new RegExp, but it's tricky
          // to do safely.  For now, this is safe and works.
          var cs = pattern.substring(classStart + 1, i);
          try {
            RegExp('[' + cs + ']');
          } catch (er) {
            // not a valid class!
            var sp = this.parse(cs, SUBPARSE);
            re = re.substr(0, reClassStart) + '\\[' + sp[0] + '\\]';
            hasMagic = hasMagic || sp[1];
            inClass = false;
            continue
          }
        }

        // finish up the class.
        hasMagic = true;
        inClass = false;
        re += c;
      continue

      default:
        // swallow any state char that wasn't consumed
        clearStateChar();

        if (escaping) {
          // no need
          escaping = false;
        } else if (reSpecials[c]
          && !(c === '^' && inClass)) {
          re += '\\';
        }

        re += c;

    } // switch
  } // for

  // handle the case where we left a class open.
  // "[abc" is valid, equivalent to "\[abc"
  if (inClass) {
    // split where the last [ was, and escape it
    // this is a huge pita.  We now have to re-walk
    // the contents of the would-be class to re-translate
    // any characters that were passed through as-is
    cs = pattern.substr(classStart + 1);
    sp = this.parse(cs, SUBPARSE);
    re = re.substr(0, reClassStart) + '\\[' + sp[0];
    hasMagic = hasMagic || sp[1];
  }

  // handle the case where we had a +( thing at the *end*
  // of the pattern.
  // each pattern list stack adds 3 chars, and we need to go through
  // and escape any | chars that were passed through as-is for the regexp.
  // Go through and escape them, taking care not to double-escape any
  // | chars that were already escaped.
  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
    var tail = re.slice(pl.reStart + pl.open.length);
    this.debug('setting tail', re, pl);
    // maybe some even number of \, then maybe 1 \, followed by a |
    tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function (_, $1, $2) {
      if (!$2) {
        // the | isn't already escaped, so escape it.
        $2 = '\\';
      }

      // need to escape all those slashes *again*, without escaping the
      // one that we need for escaping the | character.  As it works out,
      // escaping an even number of slashes can be done by simply repeating
      // it exactly after itself.  That's why this trick works.
      //
      // I am sorry that you have to see this.
      return $1 + $1 + $2 + '|'
    });

    this.debug('tail=%j\n   %s', tail, tail, pl, re);
    var t = pl.type === '*' ? star
      : pl.type === '?' ? qmark
      : '\\' + pl.type;

    hasMagic = true;
    re = re.slice(0, pl.reStart) + t + '\\(' + tail;
  }

  // handle trailing things that only matter at the very end.
  clearStateChar();
  if (escaping) {
    // trailing \\
    re += '\\\\';
  }

  // only need to apply the nodot start if the re starts with
  // something that could conceivably capture a dot
  var addPatternStart = false;
  switch (re.charAt(0)) {
    case '.':
    case '[':
    case '(': addPatternStart = true;
  }

  // Hack to work around lack of negative lookbehind in JS
  // A pattern like: *.!(x).!(y|z) needs to ensure that a name
  // like 'a.xyz.yz' doesn't match.  So, the first negative
  // lookahead, has to look ALL the way ahead, to the end of
  // the pattern.
  for (var n = negativeLists.length - 1; n > -1; n--) {
    var nl = negativeLists[n];

    var nlBefore = re.slice(0, nl.reStart);
    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);
    var nlAfter = re.slice(nl.reEnd);

    nlLast += nlAfter;

    // Handle nested stuff like *(*.js|!(*.json)), where open parens
    // mean that we should *not* include the ) in the bit that is considered
    // "after" the negated section.
    var openParensBefore = nlBefore.split('(').length - 1;
    var cleanAfter = nlAfter;
    for (i = 0; i < openParensBefore; i++) {
      cleanAfter = cleanAfter.replace(/\)[+*?]?/, '');
    }
    nlAfter = cleanAfter;

    var dollar = '';
    if (nlAfter === '' && isSub !== SUBPARSE) {
      dollar = '$';
    }
    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
    re = newRe;
  }

  // if the re is not "" at this point, then we need to make sure
  // it doesn't match against an empty path part.
  // Otherwise a/* will match a/, which it should not.
  if (re !== '' && hasMagic) {
    re = '(?=.)' + re;
  }

  if (addPatternStart) {
    re = patternStart + re;
  }

  // parsing just a piece of a larger pattern.
  if (isSub === SUBPARSE) {
    return [re, hasMagic]
  }

  // skip the regexp for non-magical patterns
  // unescape anything in it, though, so that it'll be
  // an exact match against a file etc.
  if (!hasMagic) {
    return globUnescape(pattern)
  }

  var flags = options.nocase ? 'i' : '';
  try {
    var regExp = new RegExp('^' + re + '$', flags);
  } catch (er) {
    // If it was an invalid regular expression, then it can't match
    // anything.  This trick looks for a character after the end of
    // the string, which is of course impossible, except in multi-line
    // mode, but it's not a /m regex.
    return new RegExp('$.')
  }

  regExp._glob = pattern;
  regExp._src = re;

  return regExp
}

minimatch.makeRe = function (pattern, options) {
  return new Minimatch(pattern, options || {}).makeRe()
};

Minimatch.prototype.makeRe = makeRe;
function makeRe () {
  if (this.regexp || this.regexp === false) return this.regexp

  // at this point, this.set is a 2d array of partial
  // pattern strings, or "**".
  //
  // It's better to use .match().  This function shouldn't
  // be used, really, but it's pretty convenient sometimes,
  // when you just want to work with a regex.
  var set = this.set;

  if (!set.length) {
    this.regexp = false;
    return this.regexp
  }
  var options = this.options;

  var twoStar = options.noglobstar ? star
    : options.dot ? twoStarDot
    : twoStarNoDot;
  var flags = options.nocase ? 'i' : '';

  var re = set.map(function (pattern) {
    return pattern.map(function (p) {
      return (p === GLOBSTAR) ? twoStar
      : (typeof p === 'string') ? regExpEscape(p)
      : p._src
    }).join('\\\/')
  }).join('|');

  // must match entire pattern
  // ending in a * or ** will make it less strict.
  re = '^(?:' + re + ')$';

  // can match anything, as long as it's not this.
  if (this.negate) re = '^(?!' + re + ').*$';

  try {
    this.regexp = new RegExp(re, flags);
  } catch (ex) {
    this.regexp = false;
  }
  return this.regexp
}

minimatch.match = function (list, pattern, options) {
  options = options || {};
  var mm = new Minimatch(pattern, options);
  list = list.filter(function (f) {
    return mm.match(f)
  });
  if (mm.options.nonull && !list.length) {
    list.push(pattern);
  }
  return list
};

Minimatch.prototype.match = match$1;
function match$1 (f, partial) {
  this.debug('match', f, this.pattern);
  // short-circuit in the case of busted things.
  // comments, etc.
  if (this.comment) return false
  if (this.empty) return f === ''

  if (f === '/' && partial) return true

  var options = this.options;

  // windows: need to use /, not \
  if (path.sep !== '/') {
    f = f.split(path.sep).join('/');
  }

  // treat the test path as a set of pathparts.
  f = f.split(slashSplit);
  this.debug(this.pattern, 'split', f);

  // just ONE of the pattern sets in this.set needs to match
  // in order for it to be valid.  If negating, then just one
  // match means that we have failed.
  // Either way, return on the first hit.

  var set = this.set;
  this.debug(this.pattern, 'set', set);

  // Find the basename of the path by looking for the last non-empty segment
  var filename;
  var i;
  for (i = f.length - 1; i >= 0; i--) {
    filename = f[i];
    if (filename) break
  }

  for (i = 0; i < set.length; i++) {
    var pattern = set[i];
    var file = f;
    if (options.matchBase && pattern.length === 1) {
      file = [filename];
    }
    var hit = this.matchOne(file, pattern, partial);
    if (hit) {
      if (options.flipNegate) return true
      return !this.negate
    }
  }

  // didn't get any hits.  this is success if it's a negative
  // pattern, failure otherwise.
  if (options.flipNegate) return false
  return this.negate
}

// set partial to true to test if, for example,
// "/a/b" matches the start of "/*/b/*/d"
// Partial means, if you run out of file before you run
// out of pattern, then that's fine, as long as all
// the parts match.
Minimatch.prototype.matchOne = function (file, pattern, partial) {
  var options = this.options;

  this.debug('matchOne',
    { 'this': this, file: file, pattern: pattern });

  this.debug('matchOne', file.length, pattern.length);

  for (var fi = 0,
      pi = 0,
      fl = file.length,
      pl = pattern.length
      ; (fi < fl) && (pi < pl)
      ; fi++, pi++) {
    this.debug('matchOne loop');
    var p = pattern[pi];
    var f = file[fi];

    this.debug(pattern, p, f);

    // should be impossible.
    // some invalid regexp stuff in the set.
    if (p === false) return false

    if (p === GLOBSTAR) {
      this.debug('GLOBSTAR', [pattern, p, f]);

      // "**"
      // a/**/b/**/c would match the following:
      // a/b/x/y/z/c
      // a/x/y/z/b/c
      // a/b/x/b/x/c
      // a/b/c
      // To do this, take the rest of the pattern after
      // the **, and see if it would match the file remainder.
      // If so, return success.
      // If not, the ** "swallows" a segment, and try again.
      // This is recursively awful.
      //
      // a/**/b/**/c matching a/b/x/y/z/c
      // - a matches a
      // - doublestar
      //   - matchOne(b/x/y/z/c, b/**/c)
      //     - b matches b
      //     - doublestar
      //       - matchOne(x/y/z/c, c) -> no
      //       - matchOne(y/z/c, c) -> no
      //       - matchOne(z/c, c) -> no
      //       - matchOne(c, c) yes, hit
      var fr = fi;
      var pr = pi + 1;
      if (pr === pl) {
        this.debug('** at the end');
        // a ** at the end will just swallow the rest.
        // We have found a match.
        // however, it will not swallow /.x, unless
        // options.dot is set.
        // . and .. are *never* matched by **, for explosively
        // exponential reasons.
        for (; fi < fl; fi++) {
          if (file[fi] === '.' || file[fi] === '..' ||
            (!options.dot && file[fi].charAt(0) === '.')) return false
        }
        return true
      }

      // ok, let's see if we can swallow whatever we can.
      while (fr < fl) {
        var swallowee = file[fr];

        this.debug('\nglobstar while', file, fr, pattern, pr, swallowee);

        // XXX remove this slice.  Just pass the start index.
        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
          this.debug('globstar found match!', fr, fl, swallowee);
          // found a match.
          return true
        } else {
          // can't swallow "." or ".." ever.
          // can only swallow ".foo" when explicitly asked.
          if (swallowee === '.' || swallowee === '..' ||
            (!options.dot && swallowee.charAt(0) === '.')) {
            this.debug('dot detected!', file, fr, pattern, pr);
            break
          }

          // ** swallows a segment, and continue.
          this.debug('globstar swallow a segment, and continue');
          fr++;
        }
      }

      // no match was found.
      // However, in partial mode, we can't say this is necessarily over.
      // If there's more *pattern* left, then
      if (partial) {
        // ran out of file
        this.debug('\n>>> no match, partial?', file, fr, pattern, pr);
        if (fr === fl) return true
      }
      return false
    }

    // something other than **
    // non-magic patterns just have to match exactly
    // patterns with magic have been turned into regexps.
    var hit;
    if (typeof p === 'string') {
      if (options.nocase) {
        hit = f.toLowerCase() === p.toLowerCase();
      } else {
        hit = f === p;
      }
      this.debug('string match', p, f, hit);
    } else {
      hit = f.match(p);
      this.debug('pattern match', p, f, hit);
    }

    if (!hit) return false
  }

  // Note: ending in / means that we'll get a final ""
  // at the end of the pattern.  This can only match a
  // corresponding "" at the end of the file.
  // If the file ends in /, then it can only match a
  // a pattern that ends in /, unless the pattern just
  // doesn't have any more for it. But, a/b/ should *not*
  // match "a/b/*", even though "" matches against the
  // [^/]*? pattern, except in partial mode, where it might
  // simply not be reached yet.
  // However, a/b/ should still satisfy a/*

  // now either we fell off the end of the pattern, or we're done.
  if (fi === fl && pi === pl) {
    // ran out of pattern and filename at the same time.
    // an exact hit!
    return true
  } else if (fi === fl) {
    // ran out of file, but still had pattern left.
    // this is ok if we're doing the match as part of
    // a glob fs traversal.
    return partial
  } else if (pi === pl) {
    // ran out of pattern, still have file left.
    // this is only acceptable if we're on the very last
    // empty segment of a file with a trailing slash.
    // a/* should match a/b/
    var emptyFileEnd = (fi === fl - 1) && (file[fi] === '');
    return emptyFileEnd
  }

  // should be unreachable.
  throw new Error('wtf?')
};

// replace stuff like \* with *
function globUnescape (s) {
  return s.replace(/\\(.)/g, '$1')
}

function regExpEscape (s) {
  return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&')
}

var inherits_browser = createCommonjsModule(function (module) {
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function () {};
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    }
  };
}
});

var inherits = createCommonjsModule(function (module) {
try {
  var util$1 = util;
  /* istanbul ignore next */
  if (typeof util$1.inherits !== 'function') throw '';
  module.exports = util$1.inherits;
} catch (e) {
  /* istanbul ignore next */
  module.exports = inherits_browser;
}
});

function posix(path) {
	return path.charAt(0) === '/';
}

function win32$1(path) {
	// https://github.com/nodejs/node/blob/b3fcc245fb25539909ef1d5eaa01dbf92e168633/lib/path.js#L56
	var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
	var result = splitDeviceRe.exec(path);
	var device = result[1] || '';
	var isUnc = Boolean(device && device.charAt(1) !== ':');

	// UNC paths are always absolute
	return Boolean(result[2] || isUnc);
}

var pathIsAbsolute = process.platform === 'win32' ? win32$1 : posix;
var posix_1 = posix;
var win32_1$1 = win32$1;
pathIsAbsolute.posix = posix_1;
pathIsAbsolute.win32 = win32_1$1;

var alphasort_1 = alphasort;
var alphasorti_1 = alphasorti;
var setopts_1 = setopts;
var ownProp_1 = ownProp;
var makeAbs_1 = makeAbs;
var finish_1 = finish;
var mark_1 = mark;
var isIgnored_1 = isIgnored;
var childrenIgnored_1 = childrenIgnored;

function ownProp (obj, field) {
  return Object.prototype.hasOwnProperty.call(obj, field)
}




var Minimatch$1 = minimatch_1.Minimatch;

function alphasorti (a, b) {
  return a.toLowerCase().localeCompare(b.toLowerCase())
}

function alphasort (a, b) {
  return a.localeCompare(b)
}

function setupIgnores (self, options) {
  self.ignore = options.ignore || [];

  if (!Array.isArray(self.ignore))
    self.ignore = [self.ignore];

  if (self.ignore.length) {
    self.ignore = self.ignore.map(ignoreMap);
  }
}

// ignore patterns are always in dot:true mode.
function ignoreMap (pattern) {
  var gmatcher = null;
  if (pattern.slice(-3) === '/**') {
    var gpattern = pattern.replace(/(\/\*\*)+$/, '');
    gmatcher = new Minimatch$1(gpattern, { dot: true });
  }

  return {
    matcher: new Minimatch$1(pattern, { dot: true }),
    gmatcher: gmatcher
  }
}

function setopts (self, pattern, options) {
  if (!options)
    options = {};

  // base-matching: just use globstar for that.
  if (options.matchBase && -1 === pattern.indexOf("/")) {
    if (options.noglobstar) {
      throw new Error("base matching requires globstar")
    }
    pattern = "**/" + pattern;
  }

  self.silent = !!options.silent;
  self.pattern = pattern;
  self.strict = options.strict !== false;
  self.realpath = !!options.realpath;
  self.realpathCache = options.realpathCache || Object.create(null);
  self.follow = !!options.follow;
  self.dot = !!options.dot;
  self.mark = !!options.mark;
  self.nodir = !!options.nodir;
  if (self.nodir)
    self.mark = true;
  self.sync = !!options.sync;
  self.nounique = !!options.nounique;
  self.nonull = !!options.nonull;
  self.nosort = !!options.nosort;
  self.nocase = !!options.nocase;
  self.stat = !!options.stat;
  self.noprocess = !!options.noprocess;
  self.absolute = !!options.absolute;

  self.maxLength = options.maxLength || Infinity;
  self.cache = options.cache || Object.create(null);
  self.statCache = options.statCache || Object.create(null);
  self.symlinks = options.symlinks || Object.create(null);

  setupIgnores(self, options);

  self.changedCwd = false;
  var cwd = process.cwd();
  if (!ownProp(options, "cwd"))
    self.cwd = cwd;
  else {
    self.cwd = path$1.resolve(options.cwd);
    self.changedCwd = self.cwd !== cwd;
  }

  self.root = options.root || path$1.resolve(self.cwd, "/");
  self.root = path$1.resolve(self.root);
  if (process.platform === "win32")
    self.root = self.root.replace(/\\/g, "/");

  // TODO: is an absolute `cwd` supposed to be resolved against `root`?
  // e.g. { cwd: '/test', root: __dirname } === path.join(__dirname, '/test')
  self.cwdAbs = pathIsAbsolute(self.cwd) ? self.cwd : makeAbs(self, self.cwd);
  if (process.platform === "win32")
    self.cwdAbs = self.cwdAbs.replace(/\\/g, "/");
  self.nomount = !!options.nomount;

  // disable comments and negation in Minimatch.
  // Note that they are not supported in Glob itself anyway.
  options.nonegate = true;
  options.nocomment = true;

  self.minimatch = new Minimatch$1(pattern, options);
  self.options = self.minimatch.options;
}

function finish (self) {
  var nou = self.nounique;
  var all = nou ? [] : Object.create(null);

  for (var i = 0, l = self.matches.length; i < l; i ++) {
    var matches = self.matches[i];
    if (!matches || Object.keys(matches).length === 0) {
      if (self.nonull) {
        // do like the shell, and spit out the literal glob
        var literal = self.minimatch.globSet[i];
        if (nou)
          all.push(literal);
        else
          all[literal] = true;
      }
    } else {
      // had matches
      var m = Object.keys(matches);
      if (nou)
        all.push.apply(all, m);
      else
        m.forEach(function (m) {
          all[m] = true;
        });
    }
  }

  if (!nou)
    all = Object.keys(all);

  if (!self.nosort)
    all = all.sort(self.nocase ? alphasorti : alphasort);

  // at *some* point we statted all of these
  if (self.mark) {
    for (var i = 0; i < all.length; i++) {
      all[i] = self._mark(all[i]);
    }
    if (self.nodir) {
      all = all.filter(function (e) {
        var notDir = !(/\/$/.test(e));
        var c = self.cache[e] || self.cache[makeAbs(self, e)];
        if (notDir && c)
          notDir = c !== 'DIR' && !Array.isArray(c);
        return notDir
      });
    }
  }

  if (self.ignore.length)
    all = all.filter(function(m) {
      return !isIgnored(self, m)
    });

  self.found = all;
}

function mark (self, p) {
  var abs = makeAbs(self, p);
  var c = self.cache[abs];
  var m = p;
  if (c) {
    var isDir = c === 'DIR' || Array.isArray(c);
    var slash = p.slice(-1) === '/';

    if (isDir && !slash)
      m += '/';
    else if (!isDir && slash)
      m = m.slice(0, -1);

    if (m !== p) {
      var mabs = makeAbs(self, m);
      self.statCache[mabs] = self.statCache[abs];
      self.cache[mabs] = self.cache[abs];
    }
  }

  return m
}

// lotta situps...
function makeAbs (self, f) {
  var abs = f;
  if (f.charAt(0) === '/') {
    abs = path$1.join(self.root, f);
  } else if (pathIsAbsolute(f) || f === '') {
    abs = f;
  } else if (self.changedCwd) {
    abs = path$1.resolve(self.cwd, f);
  } else {
    abs = path$1.resolve(f);
  }

  if (process.platform === 'win32')
    abs = abs.replace(/\\/g, '/');

  return abs
}


// Return true, if pattern ends with globstar '**', for the accompanying parent directory.
// Ex:- If node_modules/** is the pattern, add 'node_modules' to ignore list along with it's contents
function isIgnored (self, path) {
  if (!self.ignore.length)
    return false

  return self.ignore.some(function(item) {
    return item.matcher.match(path) || !!(item.gmatcher && item.gmatcher.match(path))
  })
}

function childrenIgnored (self, path) {
  if (!self.ignore.length)
    return false

  return self.ignore.some(function(item) {
    return !!(item.gmatcher && item.gmatcher.match(path))
  })
}

var common = {
	alphasort: alphasort_1,
	alphasorti: alphasorti_1,
	setopts: setopts_1,
	ownProp: ownProp_1,
	makeAbs: makeAbs_1,
	finish: finish_1,
	mark: mark_1,
	isIgnored: isIgnored_1,
	childrenIgnored: childrenIgnored_1
};

var sync = globSync;
globSync.GlobSync = GlobSync;
var setopts$1 = common.setopts;
var ownProp$1 = common.ownProp;
var childrenIgnored$1 = common.childrenIgnored;
var isIgnored$1 = common.isIgnored;

function globSync (pattern, options) {
  if (typeof options === 'function' || arguments.length === 3)
    throw new TypeError('callback provided to sync glob\n'+
                        'See: https://github.com/isaacs/node-glob/issues/167')

  return new GlobSync(pattern, options).found
}

function GlobSync (pattern, options) {
  if (!pattern)
    throw new Error('must provide pattern')

  if (typeof options === 'function' || arguments.length === 3)
    throw new TypeError('callback provided to sync glob\n'+
                        'See: https://github.com/isaacs/node-glob/issues/167')

  if (!(this instanceof GlobSync))
    return new GlobSync(pattern, options)

  setopts$1(this, pattern, options);

  if (this.noprocess)
    return this

  var n = this.minimatch.set.length;
  this.matches = new Array(n);
  for (var i = 0; i < n; i ++) {
    this._process(this.minimatch.set[i], i, false);
  }
  this._finish();
}

GlobSync.prototype._finish = function () {
  assert(this instanceof GlobSync);
  if (this.realpath) {
    var self = this;
    this.matches.forEach(function (matchset, index) {
      var set = self.matches[index] = Object.create(null);
      for (var p in matchset) {
        try {
          p = self._makeAbs(p);
          var real = fs_realpath.realpathSync(p, self.realpathCache);
          set[real] = true;
        } catch (er) {
          if (er.syscall === 'stat')
            set[self._makeAbs(p)] = true;
          else
            throw er
        }
      }
    });
  }
  common.finish(this);
};


GlobSync.prototype._process = function (pattern, index, inGlobStar) {
  assert(this instanceof GlobSync);

  // Get the first [n] parts of pattern that are all strings.
  var n = 0;
  while (typeof pattern[n] === 'string') {
    n ++;
  }
  // now n is the index of the first one that is *not* a string.

  // See if there's anything else
  var prefix;
  switch (n) {
    // if not, then this is rather simple
    case pattern.length:
      this._processSimple(pattern.join('/'), index);
      return

    case 0:
      // pattern *starts* with some non-trivial item.
      // going to readdir(cwd), but not include the prefix in matches.
      prefix = null;
      break

    default:
      // pattern has some string bits in the front.
      // whatever it starts with, whether that's 'absolute' like /foo/bar,
      // or 'relative' like '../baz'
      prefix = pattern.slice(0, n).join('/');
      break
  }

  var remain = pattern.slice(n);

  // get the list of entries.
  var read;
  if (prefix === null)
    read = '.';
  else if (pathIsAbsolute(prefix) || pathIsAbsolute(pattern.join('/'))) {
    if (!prefix || !pathIsAbsolute(prefix))
      prefix = '/' + prefix;
    read = prefix;
  } else
    read = prefix;

  var abs = this._makeAbs(read);

  //if ignored, skip processing
  if (childrenIgnored$1(this, read))
    return

  var isGlobStar = remain[0] === minimatch_1.GLOBSTAR;
  if (isGlobStar)
    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar);
  else
    this._processReaddir(prefix, read, abs, remain, index, inGlobStar);
};


GlobSync.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar) {
  var entries = this._readdir(abs, inGlobStar);

  // if the abs isn't a dir, then nothing can match!
  if (!entries)
    return

  // It will only match dot entries if it starts with a dot, or if
  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.
  var pn = remain[0];
  var negate = !!this.minimatch.negate;
  var rawGlob = pn._glob;
  var dotOk = this.dot || rawGlob.charAt(0) === '.';

  var matchedEntries = [];
  for (var i = 0; i < entries.length; i++) {
    var e = entries[i];
    if (e.charAt(0) !== '.' || dotOk) {
      var m;
      if (negate && !prefix) {
        m = !e.match(pn);
      } else {
        m = e.match(pn);
      }
      if (m)
        matchedEntries.push(e);
    }
  }

  var len = matchedEntries.length;
  // If there are no matched entries, then nothing matches.
  if (len === 0)
    return

  // if this is the last remaining pattern bit, then no need for
  // an additional stat *unless* the user has specified mark or
  // stat explicitly.  We know they exist, since readdir returned
  // them.

  if (remain.length === 1 && !this.mark && !this.stat) {
    if (!this.matches[index])
      this.matches[index] = Object.create(null);

    for (var i = 0; i < len; i ++) {
      var e = matchedEntries[i];
      if (prefix) {
        if (prefix.slice(-1) !== '/')
          e = prefix + '/' + e;
        else
          e = prefix + e;
      }

      if (e.charAt(0) === '/' && !this.nomount) {
        e = path$1.join(this.root, e);
      }
      this._emitMatch(index, e);
    }
    // This was the last one, and no stats were needed
    return
  }

  // now test all matched entries as stand-ins for that part
  // of the pattern.
  remain.shift();
  for (var i = 0; i < len; i ++) {
    var e = matchedEntries[i];
    var newPattern;
    if (prefix)
      newPattern = [prefix, e];
    else
      newPattern = [e];
    this._process(newPattern.concat(remain), index, inGlobStar);
  }
};


GlobSync.prototype._emitMatch = function (index, e) {
  if (isIgnored$1(this, e))
    return

  var abs = this._makeAbs(e);

  if (this.mark)
    e = this._mark(e);

  if (this.absolute) {
    e = abs;
  }

  if (this.matches[index][e])
    return

  if (this.nodir) {
    var c = this.cache[abs];
    if (c === 'DIR' || Array.isArray(c))
      return
  }

  this.matches[index][e] = true;

  if (this.stat)
    this._stat(e);
};


GlobSync.prototype._readdirInGlobStar = function (abs) {
  // follow all symlinked directories forever
  // just proceed as if this is a non-globstar situation
  if (this.follow)
    return this._readdir(abs, false)

  var entries;
  var lstat;
  try {
    lstat = fs.lstatSync(abs);
  } catch (er) {
    if (er.code === 'ENOENT') {
      // lstat failed, doesn't exist
      return null
    }
  }

  var isSym = lstat && lstat.isSymbolicLink();
  this.symlinks[abs] = isSym;

  // If it's not a symlink or a dir, then it's definitely a regular file.
  // don't bother doing a readdir in that case.
  if (!isSym && lstat && !lstat.isDirectory())
    this.cache[abs] = 'FILE';
  else
    entries = this._readdir(abs, false);

  return entries
};

GlobSync.prototype._readdir = function (abs, inGlobStar) {

  if (inGlobStar && !ownProp$1(this.symlinks, abs))
    return this._readdirInGlobStar(abs)

  if (ownProp$1(this.cache, abs)) {
    var c = this.cache[abs];
    if (!c || c === 'FILE')
      return null

    if (Array.isArray(c))
      return c
  }

  try {
    return this._readdirEntries(abs, fs.readdirSync(abs))
  } catch (er) {
    this._readdirError(abs, er);
    return null
  }
};

GlobSync.prototype._readdirEntries = function (abs, entries) {
  // if we haven't asked to stat everything, then just
  // assume that everything in there exists, so we can avoid
  // having to stat it a second time.
  if (!this.mark && !this.stat) {
    for (var i = 0; i < entries.length; i ++) {
      var e = entries[i];
      if (abs === '/')
        e = abs + e;
      else
        e = abs + '/' + e;
      this.cache[e] = true;
    }
  }

  this.cache[abs] = entries;

  // mark and cache dir-ness
  return entries
};

GlobSync.prototype._readdirError = function (f, er) {
  // handle errors, and cache the information
  switch (er.code) {
    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205
    case 'ENOTDIR': // totally normal. means it *does* exist.
      var abs = this._makeAbs(f);
      this.cache[abs] = 'FILE';
      if (abs === this.cwdAbs) {
        var error = new Error(er.code + ' invalid cwd ' + this.cwd);
        error.path = this.cwd;
        error.code = er.code;
        throw error
      }
      break

    case 'ENOENT': // not terribly unusual
    case 'ELOOP':
    case 'ENAMETOOLONG':
    case 'UNKNOWN':
      this.cache[this._makeAbs(f)] = false;
      break

    default: // some unusual error.  Treat as failure.
      this.cache[this._makeAbs(f)] = false;
      if (this.strict)
        throw er
      if (!this.silent)
        console.error('glob error', er);
      break
  }
};

GlobSync.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar) {

  var entries = this._readdir(abs, inGlobStar);

  // no entries means not a dir, so it can never have matches
  // foo.txt/** doesn't match foo.txt
  if (!entries)
    return

  // test without the globstar, and with every child both below
  // and replacing the globstar.
  var remainWithoutGlobStar = remain.slice(1);
  var gspref = prefix ? [ prefix ] : [];
  var noGlobStar = gspref.concat(remainWithoutGlobStar);

  // the noGlobStar pattern exits the inGlobStar state
  this._process(noGlobStar, index, false);

  var len = entries.length;
  var isSym = this.symlinks[abs];

  // If it's a symlink, and we're in a globstar, then stop
  if (isSym && inGlobStar)
    return

  for (var i = 0; i < len; i++) {
    var e = entries[i];
    if (e.charAt(0) === '.' && !this.dot)
      continue

    // these two cases enter the inGlobStar state
    var instead = gspref.concat(entries[i], remainWithoutGlobStar);
    this._process(instead, index, true);

    var below = gspref.concat(entries[i], remain);
    this._process(below, index, true);
  }
};

GlobSync.prototype._processSimple = function (prefix, index) {
  // XXX review this.  Shouldn't it be doing the mounting etc
  // before doing stat?  kinda weird?
  var exists = this._stat(prefix);

  if (!this.matches[index])
    this.matches[index] = Object.create(null);

  // If it doesn't exist, then just mark the lack of results
  if (!exists)
    return

  if (prefix && pathIsAbsolute(prefix) && !this.nomount) {
    var trail = /[\/\\]$/.test(prefix);
    if (prefix.charAt(0) === '/') {
      prefix = path$1.join(this.root, prefix);
    } else {
      prefix = path$1.resolve(this.root, prefix);
      if (trail)
        prefix += '/';
    }
  }

  if (process.platform === 'win32')
    prefix = prefix.replace(/\\/g, '/');

  // Mark this as a match
  this._emitMatch(index, prefix);
};

// Returns either 'DIR', 'FILE', or false
GlobSync.prototype._stat = function (f) {
  var abs = this._makeAbs(f);
  var needDir = f.slice(-1) === '/';

  if (f.length > this.maxLength)
    return false

  if (!this.stat && ownProp$1(this.cache, abs)) {
    var c = this.cache[abs];

    if (Array.isArray(c))
      c = 'DIR';

    // It exists, but maybe not how we need it
    if (!needDir || c === 'DIR')
      return c

    if (needDir && c === 'FILE')
      return false

    // otherwise we have to stat, because maybe c=true
    // if we know it exists, but not what it is.
  }
  var stat = this.statCache[abs];
  if (!stat) {
    var lstat;
    try {
      lstat = fs.lstatSync(abs);
    } catch (er) {
      if (er && (er.code === 'ENOENT' || er.code === 'ENOTDIR')) {
        this.statCache[abs] = false;
        return false
      }
    }

    if (lstat && lstat.isSymbolicLink()) {
      try {
        stat = fs.statSync(abs);
      } catch (er) {
        stat = lstat;
      }
    } else {
      stat = lstat;
    }
  }

  this.statCache[abs] = stat;

  var c = true;
  if (stat)
    c = stat.isDirectory() ? 'DIR' : 'FILE';

  this.cache[abs] = this.cache[abs] || c;

  if (needDir && c === 'FILE')
    return false

  return c
};

GlobSync.prototype._mark = function (p) {
  return common.mark(this, p)
};

GlobSync.prototype._makeAbs = function (f) {
  return common.makeAbs(this, f)
};

// Returns a wrapper function that returns a wrapped callback
// The wrapper function should do some stuff, and return a
// presumably different callback function.
// This makes sure that own properties are retained, so that
// decorations and such are not lost along the way.
var wrappy_1 = wrappy;
function wrappy (fn, cb) {
  if (fn && cb) return wrappy(fn)(cb)

  if (typeof fn !== 'function')
    throw new TypeError('need wrapper function')

  Object.keys(fn).forEach(function (k) {
    wrapper[k] = fn[k];
  });

  return wrapper

  function wrapper() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    var ret = fn.apply(this, args);
    var cb = args[args.length-1];
    if (typeof ret === 'function' && ret !== cb) {
      Object.keys(cb).forEach(function (k) {
        ret[k] = cb[k];
      });
    }
    return ret
  }
}

var once_1 = wrappy_1(once);
var strict = wrappy_1(onceStrict);

once.proto = once(function () {
  Object.defineProperty(Function.prototype, 'once', {
    value: function () {
      return once(this)
    },
    configurable: true
  });

  Object.defineProperty(Function.prototype, 'onceStrict', {
    value: function () {
      return onceStrict(this)
    },
    configurable: true
  });
});

function once (fn) {
  var f = function () {
    if (f.called) return f.value
    f.called = true;
    return f.value = fn.apply(this, arguments)
  };
  f.called = false;
  return f
}

function onceStrict (fn) {
  var f = function () {
    if (f.called)
      throw new Error(f.onceError)
    f.called = true;
    return f.value = fn.apply(this, arguments)
  };
  var name = fn.name || 'Function wrapped with `once`';
  f.onceError = name + " shouldn't be called more than once";
  f.called = false;
  return f
}
once_1.strict = strict;

var reqs = Object.create(null);


var inflight_1 = wrappy_1(inflight);

function inflight (key, cb) {
  if (reqs[key]) {
    reqs[key].push(cb);
    return null
  } else {
    reqs[key] = [cb];
    return makeres(key)
  }
}

function makeres (key) {
  return once_1(function RES () {
    var cbs = reqs[key];
    var len = cbs.length;
    var args = slice(arguments);

    // XXX It's somewhat ambiguous whether a new callback added in this
    // pass should be queued for later execution if something in the
    // list of callbacks throws, or if it should just be discarded.
    // However, it's such an edge case that it hardly matters, and either
    // choice is likely as surprising as the other.
    // As it happens, we do go ahead and schedule it for later execution.
    try {
      for (var i = 0; i < len; i++) {
        cbs[i].apply(null, args);
      }
    } finally {
      if (cbs.length > len) {
        // added more in the interim.
        // de-zalgo, just in case, but don't call again.
        cbs.splice(0, len);
        process.nextTick(function () {
          RES.apply(null, args);
        });
      } else {
        delete reqs[key];
      }
    }
  })
}

function slice (args) {
  var length = args.length;
  var array = [];

  for (var i = 0; i < length; i++) array[i] = args[i];
  return array
}

// Approach:
//
// 1. Get the minimatch set
// 2. For each pattern in the set, PROCESS(pattern, false)
// 3. Store matches per-set, then uniq them
//
// PROCESS(pattern, inGlobStar)
// Get the first [n] items from pattern that are all strings
// Join these together.  This is PREFIX.
//   If there is no more remaining, then stat(PREFIX) and
//   add to matches if it succeeds.  END.
//
// If inGlobStar and PREFIX is symlink and points to dir
//   set ENTRIES = []
// else readdir(PREFIX) as ENTRIES
//   If fail, END
//
// with ENTRIES
//   If pattern[n] is GLOBSTAR
//     // handle the case where the globstar match is empty
//     // by pruning it out, and testing the resulting pattern
//     PROCESS(pattern[0..n] + pattern[n+1 .. $], false)
//     // handle other cases.
//     for ENTRY in ENTRIES (not dotfiles)
//       // attach globstar + tail onto the entry
//       // Mark that this entry is a globstar match
//       PROCESS(pattern[0..n] + ENTRY + pattern[n .. $], true)
//
//   else // not globstar
//     for ENTRY in ENTRIES (not dotfiles, unless pattern[n] is dot)
//       Test ENTRY against pattern[n]
//       If fails, continue
//       If passes, PROCESS(pattern[0..n] + item + pattern[n+1 .. $])
//
// Caveat:
//   Cache all stats and readdirs results to minimize syscall.  Since all
//   we ever care about is existence and directory-ness, we can just keep
//   `true` for files, and [children,...] for directories, or `false` for
//   things that don't exist.

var glob_1 = glob;

var EE = events.EventEmitter;
var setopts$2 = common.setopts;
var ownProp$2 = common.ownProp;


var childrenIgnored$2 = common.childrenIgnored;
var isIgnored$2 = common.isIgnored;



function glob (pattern, options, cb) {
  if (typeof options === 'function') cb = options, options = {};
  if (!options) options = {};

  if (options.sync) {
    if (cb)
      throw new TypeError('callback provided to sync glob')
    return sync(pattern, options)
  }

  return new Glob(pattern, options, cb)
}

glob.sync = sync;
var GlobSync$1 = glob.GlobSync = sync.GlobSync;

// old api surface
glob.glob = glob;

function extend$1 (origin, add) {
  if (add === null || typeof add !== 'object') {
    return origin
  }

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin
}

glob.hasMagic = function (pattern, options_) {
  var options = extend$1({}, options_);
  options.noprocess = true;

  var g = new Glob(pattern, options);
  var set = g.minimatch.set;

  if (!pattern)
    return false

  if (set.length > 1)
    return true

  for (var j = 0; j < set[0].length; j++) {
    if (typeof set[0][j] !== 'string')
      return true
  }

  return false
};

glob.Glob = Glob;
inherits(Glob, EE);
function Glob (pattern, options, cb) {
  if (typeof options === 'function') {
    cb = options;
    options = null;
  }

  if (options && options.sync) {
    if (cb)
      throw new TypeError('callback provided to sync glob')
    return new GlobSync$1(pattern, options)
  }

  if (!(this instanceof Glob))
    return new Glob(pattern, options, cb)

  setopts$2(this, pattern, options);
  this._didRealPath = false;

  // process each pattern in the minimatch set
  var n = this.minimatch.set.length;

  // The matches are stored as {<filename>: true,...} so that
  // duplicates are automagically pruned.
  // Later, we do an Object.keys() on these.
  // Keep them as a list so we can fill in when nonull is set.
  this.matches = new Array(n);

  if (typeof cb === 'function') {
    cb = once_1(cb);
    this.on('error', cb);
    this.on('end', function (matches) {
      cb(null, matches);
    });
  }

  var self = this;
  this._processing = 0;

  this._emitQueue = [];
  this._processQueue = [];
  this.paused = false;

  if (this.noprocess)
    return this

  if (n === 0)
    return done()

  var sync = true;
  for (var i = 0; i < n; i ++) {
    this._process(this.minimatch.set[i], i, false, done);
  }
  sync = false;

  function done () {
    --self._processing;
    if (self._processing <= 0) {
      if (sync) {
        process.nextTick(function () {
          self._finish();
        });
      } else {
        self._finish();
      }
    }
  }
}

Glob.prototype._finish = function () {
  assert(this instanceof Glob);
  if (this.aborted)
    return

  if (this.realpath && !this._didRealpath)
    return this._realpath()

  common.finish(this);
  this.emit('end', this.found);
};

Glob.prototype._realpath = function () {
  if (this._didRealpath)
    return

  this._didRealpath = true;

  var n = this.matches.length;
  if (n === 0)
    return this._finish()

  var self = this;
  for (var i = 0; i < this.matches.length; i++)
    this._realpathSet(i, next);

  function next () {
    if (--n === 0)
      self._finish();
  }
};

Glob.prototype._realpathSet = function (index, cb) {
  var matchset = this.matches[index];
  if (!matchset)
    return cb()

  var found = Object.keys(matchset);
  var self = this;
  var n = found.length;

  if (n === 0)
    return cb()

  var set = this.matches[index] = Object.create(null);
  found.forEach(function (p, i) {
    // If there's a problem with the stat, then it means that
    // one or more of the links in the realpath couldn't be
    // resolved.  just return the abs value in that case.
    p = self._makeAbs(p);
    fs_realpath.realpath(p, self.realpathCache, function (er, real) {
      if (!er)
        set[real] = true;
      else if (er.syscall === 'stat')
        set[p] = true;
      else
        self.emit('error', er); // srsly wtf right here

      if (--n === 0) {
        self.matches[index] = set;
        cb();
      }
    });
  });
};

Glob.prototype._mark = function (p) {
  return common.mark(this, p)
};

Glob.prototype._makeAbs = function (f) {
  return common.makeAbs(this, f)
};

Glob.prototype.abort = function () {
  this.aborted = true;
  this.emit('abort');
};

Glob.prototype.pause = function () {
  if (!this.paused) {
    this.paused = true;
    this.emit('pause');
  }
};

Glob.prototype.resume = function () {
  if (this.paused) {
    this.emit('resume');
    this.paused = false;
    if (this._emitQueue.length) {
      var eq = this._emitQueue.slice(0);
      this._emitQueue.length = 0;
      for (var i = 0; i < eq.length; i ++) {
        var e = eq[i];
        this._emitMatch(e[0], e[1]);
      }
    }
    if (this._processQueue.length) {
      var pq = this._processQueue.slice(0);
      this._processQueue.length = 0;
      for (var i = 0; i < pq.length; i ++) {
        var p = pq[i];
        this._processing--;
        this._process(p[0], p[1], p[2], p[3]);
      }
    }
  }
};

Glob.prototype._process = function (pattern, index, inGlobStar, cb) {
  assert(this instanceof Glob);
  assert(typeof cb === 'function');

  if (this.aborted)
    return

  this._processing++;
  if (this.paused) {
    this._processQueue.push([pattern, index, inGlobStar, cb]);
    return
  }

  //console.error('PROCESS %d', this._processing, pattern)

  // Get the first [n] parts of pattern that are all strings.
  var n = 0;
  while (typeof pattern[n] === 'string') {
    n ++;
  }
  // now n is the index of the first one that is *not* a string.

  // see if there's anything else
  var prefix;
  switch (n) {
    // if not, then this is rather simple
    case pattern.length:
      this._processSimple(pattern.join('/'), index, cb);
      return

    case 0:
      // pattern *starts* with some non-trivial item.
      // going to readdir(cwd), but not include the prefix in matches.
      prefix = null;
      break

    default:
      // pattern has some string bits in the front.
      // whatever it starts with, whether that's 'absolute' like /foo/bar,
      // or 'relative' like '../baz'
      prefix = pattern.slice(0, n).join('/');
      break
  }

  var remain = pattern.slice(n);

  // get the list of entries.
  var read;
  if (prefix === null)
    read = '.';
  else if (pathIsAbsolute(prefix) || pathIsAbsolute(pattern.join('/'))) {
    if (!prefix || !pathIsAbsolute(prefix))
      prefix = '/' + prefix;
    read = prefix;
  } else
    read = prefix;

  var abs = this._makeAbs(read);

  //if ignored, skip _processing
  if (childrenIgnored$2(this, read))
    return cb()

  var isGlobStar = remain[0] === minimatch_1.GLOBSTAR;
  if (isGlobStar)
    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb);
  else
    this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb);
};

Glob.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar, cb) {
  var self = this;
  this._readdir(abs, inGlobStar, function (er, entries) {
    return self._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb)
  });
};

Glob.prototype._processReaddir2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {

  // if the abs isn't a dir, then nothing can match!
  if (!entries)
    return cb()

  // It will only match dot entries if it starts with a dot, or if
  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.
  var pn = remain[0];
  var negate = !!this.minimatch.negate;
  var rawGlob = pn._glob;
  var dotOk = this.dot || rawGlob.charAt(0) === '.';

  var matchedEntries = [];
  for (var i = 0; i < entries.length; i++) {
    var e = entries[i];
    if (e.charAt(0) !== '.' || dotOk) {
      var m;
      if (negate && !prefix) {
        m = !e.match(pn);
      } else {
        m = e.match(pn);
      }
      if (m)
        matchedEntries.push(e);
    }
  }

  //console.error('prd2', prefix, entries, remain[0]._glob, matchedEntries)

  var len = matchedEntries.length;
  // If there are no matched entries, then nothing matches.
  if (len === 0)
    return cb()

  // if this is the last remaining pattern bit, then no need for
  // an additional stat *unless* the user has specified mark or
  // stat explicitly.  We know they exist, since readdir returned
  // them.

  if (remain.length === 1 && !this.mark && !this.stat) {
    if (!this.matches[index])
      this.matches[index] = Object.create(null);

    for (var i = 0; i < len; i ++) {
      var e = matchedEntries[i];
      if (prefix) {
        if (prefix !== '/')
          e = prefix + '/' + e;
        else
          e = prefix + e;
      }

      if (e.charAt(0) === '/' && !this.nomount) {
        e = path$1.join(this.root, e);
      }
      this._emitMatch(index, e);
    }
    // This was the last one, and no stats were needed
    return cb()
  }

  // now test all matched entries as stand-ins for that part
  // of the pattern.
  remain.shift();
  for (var i = 0; i < len; i ++) {
    var e = matchedEntries[i];
    if (prefix) {
      if (prefix !== '/')
        e = prefix + '/' + e;
      else
        e = prefix + e;
    }
    this._process([e].concat(remain), index, inGlobStar, cb);
  }
  cb();
};

Glob.prototype._emitMatch = function (index, e) {
  if (this.aborted)
    return

  if (isIgnored$2(this, e))
    return

  if (this.paused) {
    this._emitQueue.push([index, e]);
    return
  }

  var abs = pathIsAbsolute(e) ? e : this._makeAbs(e);

  if (this.mark)
    e = this._mark(e);

  if (this.absolute)
    e = abs;

  if (this.matches[index][e])
    return

  if (this.nodir) {
    var c = this.cache[abs];
    if (c === 'DIR' || Array.isArray(c))
      return
  }

  this.matches[index][e] = true;

  var st = this.statCache[abs];
  if (st)
    this.emit('stat', e, st);

  this.emit('match', e);
};

Glob.prototype._readdirInGlobStar = function (abs, cb) {
  if (this.aborted)
    return

  // follow all symlinked directories forever
  // just proceed as if this is a non-globstar situation
  if (this.follow)
    return this._readdir(abs, false, cb)

  var lstatkey = 'lstat\0' + abs;
  var self = this;
  var lstatcb = inflight_1(lstatkey, lstatcb_);

  if (lstatcb)
    fs.lstat(abs, lstatcb);

  function lstatcb_ (er, lstat) {
    if (er && er.code === 'ENOENT')
      return cb()

    var isSym = lstat && lstat.isSymbolicLink();
    self.symlinks[abs] = isSym;

    // If it's not a symlink or a dir, then it's definitely a regular file.
    // don't bother doing a readdir in that case.
    if (!isSym && lstat && !lstat.isDirectory()) {
      self.cache[abs] = 'FILE';
      cb();
    } else
      self._readdir(abs, false, cb);
  }
};

Glob.prototype._readdir = function (abs, inGlobStar, cb) {
  if (this.aborted)
    return

  cb = inflight_1('readdir\0'+abs+'\0'+inGlobStar, cb);
  if (!cb)
    return

  //console.error('RD %j %j', +inGlobStar, abs)
  if (inGlobStar && !ownProp$2(this.symlinks, abs))
    return this._readdirInGlobStar(abs, cb)

  if (ownProp$2(this.cache, abs)) {
    var c = this.cache[abs];
    if (!c || c === 'FILE')
      return cb()

    if (Array.isArray(c))
      return cb(null, c)
  }
  fs.readdir(abs, readdirCb(this, abs, cb));
};

function readdirCb (self, abs, cb) {
  return function (er, entries) {
    if (er)
      self._readdirError(abs, er, cb);
    else
      self._readdirEntries(abs, entries, cb);
  }
}

Glob.prototype._readdirEntries = function (abs, entries, cb) {
  if (this.aborted)
    return

  // if we haven't asked to stat everything, then just
  // assume that everything in there exists, so we can avoid
  // having to stat it a second time.
  if (!this.mark && !this.stat) {
    for (var i = 0; i < entries.length; i ++) {
      var e = entries[i];
      if (abs === '/')
        e = abs + e;
      else
        e = abs + '/' + e;
      this.cache[e] = true;
    }
  }

  this.cache[abs] = entries;
  return cb(null, entries)
};

Glob.prototype._readdirError = function (f, er, cb) {
  if (this.aborted)
    return

  // handle errors, and cache the information
  switch (er.code) {
    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205
    case 'ENOTDIR': // totally normal. means it *does* exist.
      var abs = this._makeAbs(f);
      this.cache[abs] = 'FILE';
      if (abs === this.cwdAbs) {
        var error = new Error(er.code + ' invalid cwd ' + this.cwd);
        error.path = this.cwd;
        error.code = er.code;
        this.emit('error', error);
        this.abort();
      }
      break

    case 'ENOENT': // not terribly unusual
    case 'ELOOP':
    case 'ENAMETOOLONG':
    case 'UNKNOWN':
      this.cache[this._makeAbs(f)] = false;
      break

    default: // some unusual error.  Treat as failure.
      this.cache[this._makeAbs(f)] = false;
      if (this.strict) {
        this.emit('error', er);
        // If the error is handled, then we abort
        // if not, we threw out of here
        this.abort();
      }
      if (!this.silent)
        console.error('glob error', er);
      break
  }

  return cb()
};

Glob.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar, cb) {
  var self = this;
  this._readdir(abs, inGlobStar, function (er, entries) {
    self._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
  });
};


Glob.prototype._processGlobStar2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {
  //console.error('pgs2', prefix, remain[0], entries)

  // no entries means not a dir, so it can never have matches
  // foo.txt/** doesn't match foo.txt
  if (!entries)
    return cb()

  // test without the globstar, and with every child both below
  // and replacing the globstar.
  var remainWithoutGlobStar = remain.slice(1);
  var gspref = prefix ? [ prefix ] : [];
  var noGlobStar = gspref.concat(remainWithoutGlobStar);

  // the noGlobStar pattern exits the inGlobStar state
  this._process(noGlobStar, index, false, cb);

  var isSym = this.symlinks[abs];
  var len = entries.length;

  // If it's a symlink, and we're in a globstar, then stop
  if (isSym && inGlobStar)
    return cb()

  for (var i = 0; i < len; i++) {
    var e = entries[i];
    if (e.charAt(0) === '.' && !this.dot)
      continue

    // these two cases enter the inGlobStar state
    var instead = gspref.concat(entries[i], remainWithoutGlobStar);
    this._process(instead, index, true, cb);

    var below = gspref.concat(entries[i], remain);
    this._process(below, index, true, cb);
  }

  cb();
};

Glob.prototype._processSimple = function (prefix, index, cb) {
  // XXX review this.  Shouldn't it be doing the mounting etc
  // before doing stat?  kinda weird?
  var self = this;
  this._stat(prefix, function (er, exists) {
    self._processSimple2(prefix, index, er, exists, cb);
  });
};
Glob.prototype._processSimple2 = function (prefix, index, er, exists, cb) {

  //console.error('ps2', prefix, exists)

  if (!this.matches[index])
    this.matches[index] = Object.create(null);

  // If it doesn't exist, then just mark the lack of results
  if (!exists)
    return cb()

  if (prefix && pathIsAbsolute(prefix) && !this.nomount) {
    var trail = /[\/\\]$/.test(prefix);
    if (prefix.charAt(0) === '/') {
      prefix = path$1.join(this.root, prefix);
    } else {
      prefix = path$1.resolve(this.root, prefix);
      if (trail)
        prefix += '/';
    }
  }

  if (process.platform === 'win32')
    prefix = prefix.replace(/\\/g, '/');

  // Mark this as a match
  this._emitMatch(index, prefix);
  cb();
};

// Returns either 'DIR', 'FILE', or false
Glob.prototype._stat = function (f, cb) {
  var abs = this._makeAbs(f);
  var needDir = f.slice(-1) === '/';

  if (f.length > this.maxLength)
    return cb()

  if (!this.stat && ownProp$2(this.cache, abs)) {
    var c = this.cache[abs];

    if (Array.isArray(c))
      c = 'DIR';

    // It exists, but maybe not how we need it
    if (!needDir || c === 'DIR')
      return cb(null, c)

    if (needDir && c === 'FILE')
      return cb()

    // otherwise we have to stat, because maybe c=true
    // if we know it exists, but not what it is.
  }
  var stat = this.statCache[abs];
  if (stat !== undefined) {
    if (stat === false)
      return cb(null, stat)
    else {
      var type = stat.isDirectory() ? 'DIR' : 'FILE';
      if (needDir && type === 'FILE')
        return cb()
      else
        return cb(null, type, stat)
    }
  }

  var self = this;
  var statcb = inflight_1('stat\0' + abs, lstatcb_);
  if (statcb)
    fs.lstat(abs, statcb);

  function lstatcb_ (er, lstat) {
    if (lstat && lstat.isSymbolicLink()) {
      // If it's a symlink, then treat it as the target, unless
      // the target does not exist, then treat it as a file.
      return fs.stat(abs, function (er, stat) {
        if (er)
          self._stat2(f, abs, null, lstat, cb);
        else
          self._stat2(f, abs, er, stat, cb);
      })
    } else {
      self._stat2(f, abs, er, lstat, cb);
    }
  }
};

Glob.prototype._stat2 = function (f, abs, er, stat, cb) {
  if (er && (er.code === 'ENOENT' || er.code === 'ENOTDIR')) {
    this.statCache[abs] = false;
    return cb()
  }

  var needDir = f.slice(-1) === '/';
  this.statCache[abs] = stat;

  if (abs.slice(-1) === '/' && stat && !stat.isDirectory())
    return cb(null, false, stat)

  var c = true;
  if (stat)
    c = stat.isDirectory() ? 'DIR' : 'FILE';
  this.cache[abs] = this.cache[abs] || c;

  if (needDir && c === 'FILE')
    return cb()

  return cb(null, c, stat)
};

let glob$1 = undefined;
try {
  glob$1 = glob_1;
} catch (_err) {
  // treat glob as optional.
}

const defaultGlobOpts = {
  nosort: true,
  silent: true
};

// for EMFILE handling
let timeout = 0;

const isWindows$1 = (process.platform === "win32");

const defaults = options => {
  const methods = [
    'unlink',
    'chmod',
    'stat',
    'lstat',
    'rmdir',
    'readdir'
  ];
  methods.forEach(m => {
    options[m] = options[m] || fs[m];
    m = m + 'Sync';
    options[m] = options[m] || fs[m];
  });

  options.maxBusyTries = options.maxBusyTries || 3;
  options.emfileWait = options.emfileWait || 1000;
  if (options.glob === false) {
    options.disableGlob = true;
  }
  if (options.disableGlob !== true && glob$1 === undefined) {
    throw Error('glob dependency not found, set `options.disableGlob = true` if intentional')
  }
  options.disableGlob = options.disableGlob || false;
  options.glob = options.glob || defaultGlobOpts;
};

const rimraf = (p, options, cb) => {
  if (typeof options === 'function') {
    cb = options;
    options = {};
  }

  assert(p, 'rimraf: missing path');
  assert.equal(typeof p, 'string', 'rimraf: path should be a string');
  assert.equal(typeof cb, 'function', 'rimraf: callback function required');
  assert(options, 'rimraf: invalid options argument provided');
  assert.equal(typeof options, 'object', 'rimraf: options should be object');

  defaults(options);

  let busyTries = 0;
  let errState = null;
  let n = 0;

  const next = (er) => {
    errState = errState || er;
    if (--n === 0)
      cb(errState);
  };

  const afterGlob = (er, results) => {
    if (er)
      return cb(er)

    n = results.length;
    if (n === 0)
      return cb()

    results.forEach(p => {
      const CB = (er) => {
        if (er) {
          if ((er.code === "EBUSY" || er.code === "ENOTEMPTY" || er.code === "EPERM") &&
              busyTries < options.maxBusyTries) {
            busyTries ++;
            // try again, with the same exact callback as this one.
            return setTimeout(() => rimraf_(p, options, CB), busyTries * 100)
          }

          // this one won't happen if graceful-fs is used.
          if (er.code === "EMFILE" && timeout < options.emfileWait) {
            return setTimeout(() => rimraf_(p, options, CB), timeout ++)
          }

          // already gone
          if (er.code === "ENOENT") er = null;
        }

        timeout = 0;
        next(er);
      };
      rimraf_(p, options, CB);
    });
  };

  if (options.disableGlob || !glob$1.hasMagic(p))
    return afterGlob(null, [p])

  options.lstat(p, (er, stat) => {
    if (!er)
      return afterGlob(null, [p])

    glob$1(p, options.glob, afterGlob);
  });

};

// Two possible strategies.
// 1. Assume it's a file.  unlink it, then do the dir stuff on EPERM or EISDIR
// 2. Assume it's a directory.  readdir, then do the file stuff on ENOTDIR
//
// Both result in an extra syscall when you guess wrong.  However, there
// are likely far more normal files in the world than directories.  This
// is based on the assumption that a the average number of files per
// directory is >= 1.
//
// If anyone ever complains about this, then I guess the strategy could
// be made configurable somehow.  But until then, YAGNI.
const rimraf_ = (p, options, cb) => {
  assert(p);
  assert(options);
  assert(typeof cb === 'function');

  // sunos lets the root user unlink directories, which is... weird.
  // so we have to lstat here and make sure it's not a dir.
  options.lstat(p, (er, st) => {
    if (er && er.code === "ENOENT")
      return cb(null)

    // Windows can EPERM on stat.  Life is suffering.
    if (er && er.code === "EPERM" && isWindows$1)
      fixWinEPERM(p, options, er, cb);

    if (st && st.isDirectory())
      return rmdir(p, options, er, cb)

    options.unlink(p, er => {
      if (er) {
        if (er.code === "ENOENT")
          return cb(null)
        if (er.code === "EPERM")
          return (isWindows$1)
            ? fixWinEPERM(p, options, er, cb)
            : rmdir(p, options, er, cb)
        if (er.code === "EISDIR")
          return rmdir(p, options, er, cb)
      }
      return cb(er)
    });
  });
};

const fixWinEPERM = (p, options, er, cb) => {
  assert(p);
  assert(options);
  assert(typeof cb === 'function');

  options.chmod(p, 0o666, er2 => {
    if (er2)
      cb(er2.code === "ENOENT" ? null : er);
    else
      options.stat(p, (er3, stats) => {
        if (er3)
          cb(er3.code === "ENOENT" ? null : er);
        else if (stats.isDirectory())
          rmdir(p, options, er, cb);
        else
          options.unlink(p, cb);
      });
  });
};

const fixWinEPERMSync = (p, options, er) => {
  assert(p);
  assert(options);

  try {
    options.chmodSync(p, 0o666);
  } catch (er2) {
    if (er2.code === "ENOENT")
      return
    else
      throw er
  }

  let stats;
  try {
    stats = options.statSync(p);
  } catch (er3) {
    if (er3.code === "ENOENT")
      return
    else
      throw er
  }

  if (stats.isDirectory())
    rmdirSync(p, options, er);
  else
    options.unlinkSync(p);
};

const rmdir = (p, options, originalEr, cb) => {
  assert(p);
  assert(options);
  assert(typeof cb === 'function');

  // try to rmdir first, and only readdir on ENOTEMPTY or EEXIST (SunOS)
  // if we guessed wrong, and it's not a directory, then
  // raise the original error.
  options.rmdir(p, er => {
    if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM"))
      rmkids(p, options, cb);
    else if (er && er.code === "ENOTDIR")
      cb(originalEr);
    else
      cb(er);
  });
};

const rmkids = (p, options, cb) => {
  assert(p);
  assert(options);
  assert(typeof cb === 'function');

  options.readdir(p, (er, files) => {
    if (er)
      return cb(er)
    let n = files.length;
    if (n === 0)
      return options.rmdir(p, cb)
    let errState;
    files.forEach(f => {
      rimraf(path$1.join(p, f), options, er => {
        if (errState)
          return
        if (er)
          return cb(errState = er)
        if (--n === 0)
          options.rmdir(p, cb);
      });
    });
  });
};

// this looks simpler, and is strictly *faster*, but will
// tie up the JavaScript thread and fail on excessively
// deep directory trees.
const rimrafSync = (p, options) => {
  options = options || {};
  defaults(options);

  assert(p, 'rimraf: missing path');
  assert.equal(typeof p, 'string', 'rimraf: path should be a string');
  assert(options, 'rimraf: missing options');
  assert.equal(typeof options, 'object', 'rimraf: options should be object');

  let results;

  if (options.disableGlob || !glob$1.hasMagic(p)) {
    results = [p];
  } else {
    try {
      options.lstatSync(p);
      results = [p];
    } catch (er) {
      results = glob$1.sync(p, options.glob);
    }
  }

  if (!results.length)
    return

  for (let i = 0; i < results.length; i++) {
    const p = results[i];

    let st;
    try {
      st = options.lstatSync(p);
    } catch (er) {
      if (er.code === "ENOENT")
        return

      // Windows can EPERM on stat.  Life is suffering.
      if (er.code === "EPERM" && isWindows$1)
        fixWinEPERMSync(p, options, er);
    }

    try {
      // sunos lets the root user unlink directories, which is... weird.
      if (st && st.isDirectory())
        rmdirSync(p, options, null);
      else
        options.unlinkSync(p);
    } catch (er) {
      if (er.code === "ENOENT")
        return
      if (er.code === "EPERM")
        return isWindows$1 ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er)
      if (er.code !== "EISDIR")
        throw er

      rmdirSync(p, options, er);
    }
  }
};

const rmdirSync = (p, options, originalEr) => {
  assert(p);
  assert(options);

  try {
    options.rmdirSync(p);
  } catch (er) {
    if (er.code === "ENOENT")
      return
    if (er.code === "ENOTDIR")
      throw originalEr
    if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")
      rmkidsSync(p, options);
  }
};

const rmkidsSync = (p, options) => {
  assert(p);
  assert(options);
  options.readdirSync(p).forEach(f => rimrafSync(path$1.join(p, f), options));

  // We only end up here once we got ENOTEMPTY at least once, and
  // at this point, we are guaranteed to have removed all the kids.
  // So, we know that it won't be ENOENT or ENOTDIR or anything else.
  // try really hard to delete stuff on windows, because it has a
  // PROFOUNDLY annoying habit of not closing handles promptly when
  // files are deleted, resulting in spurious ENOTEMPTY errors.
  const retries = isWindows$1 ? 100 : 1;
  let i = 0;
  do {
    let threw = true;
    try {
      const ret = options.rmdirSync(p, options);
      threw = false;
      return ret
    } finally {
      if (++i < retries && threw)
        continue
    }
  } while (true)
};

var rimraf_1 = rimraf;
rimraf.sync = rimrafSync;

let { promisify } = util;

let readFile = promisify(fs.readFile);
let writeFile = promisify(fs.writeFile);
let mkdir = promisify(fs.mkdir);
let exists$1 = promisify(fs.exists);
let stat = promisify(fs.stat);
let readdir = promisify(fs.readdir);
let unlink = promisify(fs.unlink);

var fs_1 = { readFile, writeFile, mkdir, exists: exists$1, readdir, stat, unlink };

var handlePromiseRejectionInJs = function(e) {
  /* TODO */
  console.log(e);
};

var Child_process = require("child_process");








var Stdout = { };

var Process = {
  Stdout: Stdout
};

var $$Error$1 = { };

var scriptPath = (process.argv[1]);

function downloadGit(repo, path) {
  return new Promise((function (resolve, param) {
                downloadGitRepo(repo, path, (function (err) {
                        if (err == null) {
                          return resolve(/* Ok */caml_chrome_debugger.variant("Ok", 0, [/* () */0]));
                        } else {
                          return resolve(/* Error */caml_chrome_debugger.variant("Error", 1, [err]));
                        }
                      }));
                return /* () */0;
              }));
}

function ofString(prim) {
  return Buffer.from(prim);
}

var $$Buffer$1 = {
  ofString: ofString
};

function StreamFunctor(S) {
  var onData = function (t, cb) {
    t.on("data", cb);
    return /* () */0;
  };
  var onEnd = function (t, cb) {
    t.on("end", cb);
    return /* () */0;
  };
  var onClose = function (t, cb) {
    t.on("close", cb);
    return /* () */0;
  };
  return {
          onData: onData,
          onEnd: onEnd,
          onClose: onClose
        };
}

function onData(t, cb) {
  t.on("data", cb);
  return /* () */0;
}

function onEnd(t, cb) {
  t.on("end", cb);
  return /* () */0;
}

function onClose(t, cb) {
  t.on("close", cb);
  return /* () */0;
}

var Stream = {
  onData: onData,
  onEnd: onEnd,
  onClose: onClose
};

var ExecFailure = caml_exceptions.create("Bindings.ChildProcess.ExecFailure");

function onClose$1(t, cb) {
  t.on("close", cb);
  return /* () */0;
}

function exec(cmd, options) {
  return new Promise((function (resolve, param) {
                var cp = {
                  contents: {
                    exitCode: 0
                  }
                };
                cp.contents = Child_process.exec(cmd, options, (function (err, stdout, stderr) {
                        if (err == null) {
                          return resolve(/* Ok */caml_chrome_debugger.variant("Ok", 0, [/* tuple */[
                                          cp.contents.exitCode,
                                          stdout,
                                          stderr
                                        ]]));
                        } else {
                          return resolve(/* Error */caml_chrome_debugger.variant("Error", 1, [/* () */0]));
                        }
                      }));
                return /* () */0;
              }));
}

function spawn(prim, prim$1, prim$2) {
  return Child_process.spawn(prim, prim$1, prim$2);
}

var ChildProcess_Options = {
  make: (function (prim, prim$1, prim$2, prim$3) {
      var tmp = { };
      if (prim !== undefined) {
        tmp.cwd = caml_option.valFromOption(prim);
      }
      if (prim$1 !== undefined) {
        tmp.env = caml_option.valFromOption(prim$1);
      }
      if (prim$2 !== undefined) {
        tmp.stdio = caml_option.valFromOption(prim$2);
      }
      return tmp;
    })
};

var ChildProcess = {
  Options: ChildProcess_Options,
  ExecFailure: ExecFailure,
  spawn: spawn,
  onClose: onClose$1,
  exec: exec
};

var $$Response = { };

var $$Request = { };

function onData$1(t, cb) {
  t.on("data", cb);
  return /* () */0;
}

function onProgress(t, cb) {
  t.on("progress", cb);
  return /* () */0;
}

function onError(t, cb) {
  t.on("error", cb);
  return /* () */0;
}

function onEnd$1(t, cb) {
  t.on("end", cb);
  return /* () */0;
}

var RequestProgress = {
  onData: onData$1,
  onProgress: onProgress,
  onError: onError,
  onEnd: onEnd$1
};

function toString(param) {
  return "Failed to place request to " + (String(param[0]) + "");
}

var E = {
  toString: toString
};

function getCompleteResponse(url) {
  return new Promise((function (resolve, param) {
                https.get(url, (function (response) {
                        response.statusCode;
                        var responseText = {
                          contents: ""
                        };
                        response.on("data", (function (c) {
                                responseText.contents = responseText.contents + c.toString();
                                return /* () */0;
                              }));
                        response.on("end", (function (param) {
                                return resolve(/* Ok */caml_chrome_debugger.variant("Ok", 0, [responseText.contents]));
                              }));
                        response.on("error", (function (_err) {
                                return resolve(/* Error */caml_chrome_debugger.variant("Error", 1, [/* Failure */caml_chrome_debugger.simpleVariant("Failure", ["Error occurred while placing request to " + (String(url) + "")])]));
                              }));
                        return /* () */0;
                      }));
                return /* () */0;
              }));
}

var Https$1 = {
  E: E,
  getCompleteResponse: getCompleteResponse
};

var writeFile$1 = fs_1.writeFile;

var readFile$1 = fs_1.readFile;

function unlink$1(prim) {
  return fs_1.unlink(prim);
}

function copy$4(dryRun, src, dest, param) {
  var dryRun$1 = dryRun !== undefined ? dryRun : false;
  if (dryRun$1) {
    return Promise.resolve((console.log("Copying " + (String(src) + (" to " + (String(dest) + "")))), /* () */0));
  } else {
    return readFile$1(src).then((function (b) {
                  return writeFile$1(dest, b);
                }));
  }
}

var DirEnt = { };

var Dir = { };

function opendir(prim) {
  return fs_1.opendir(prim);
}

function readdir$1(prim) {
  return fs_1.readdir(prim);
}

var Stats = { };

function stat$1(prim) {
  return fs_1.stat(prim);
}

function isDirectory(p) {
  return fs_1.stat(p).then((function (stats) {
                return stats.isDirectory();
              }));
}

function exists$2(prim) {
  return fs_1.exists(prim);
}

function mkdir$prime(prim) {
  return fs_1.mkdir(prim);
}

function mkdir$1(dryRun, p, path) {
  var forceCreate = p !== undefined ? p : false;
  var dryRun$1 = dryRun !== undefined ? dryRun : false;
  if (dryRun$1) {
    return Promise.resolve(/* () */0);
  } else if (forceCreate) {
    return fs_1.exists(path).then((function (doesExist) {
                  if (doesExist) {
                    return Promise.resolve(/* () */0);
                  } else {
                    var homePath = caml_sys.caml_sys_getenv( "HOME" );
                    if (path === homePath) {
                      return Promise.reject([
                                  caml_builtin_exceptions.failure,
                                  "mkdir(~p=true) received home path and it was not found"
                                ]);
                    } else {
                      return mkdir$1(undefined, true, curry._1(filename.dirname, path)).then((function (param) {
                                    return fs_1.mkdir(path);
                                  }));
                    }
                  }
                }));
  } else {
    return fs_1.mkdir(path);
  }
}

var Fs$1 = {
  writeFile: writeFile$1,
  readFile: readFile$1,
  unlink: unlink$1,
  copy: copy$4,
  DirEnt: DirEnt,
  Dir: Dir,
  opendir: opendir,
  readdir: readdir$1,
  Stats: Stats,
  stat: stat$1,
  isDirectory: isDirectory,
  exists: exists$2,
  mkdir$prime: mkdir$prime,
  mkdir: mkdir$1
};

var throwJSError = (e => { throw e; });

function handlePromiseRejectInJS(prim) {
  return handlePromiseRejectionInJs(prim);
}

function fromInt(level) {
  if (level > 3 || level < 0) {
    return /* None */0;
  } else {
    return level;
  }
}

function toInt(level) {
  return level;
}

var Level = {
  fromInt: fromInt,
  toInt: toInt
};

var level = fromInt(chalk.level);

function rgb(r, g, b) {
  return chalk.rgb(r, g, b);
}

function hsl(h, s, l) {
  return chalk.hsl(h, s, l);
}

function hsv(h, s, v) {
  return chalk.hsv(h, s, v);
}

function hwb(h, w, b) {
  return chalk.hwb(h, w, b);
}

function bgRgb(r, g, b) {
  return chalk.bgRgb(r, g, b);
}

function bgHsl(h, s, l) {
  return chalk.bgHsl(h, s, l);
}

function bgHsv(h, s, v) {
  return chalk.bgHsv(h, s, v);
}

function bgHwb(h, w, b) {
  return chalk.bgHwb(h, w, b);
}

var Chalk$1 = {
  Level: Level,
  level: level,
  rgb: rgb,
  hsl: hsl,
  hsv: hsv,
  hwb: hwb,
  bgRgb: bgRgb,
  bgHsl: bgHsl,
  bgHsv: bgHsv,
  bgHwb: bgHwb
};

var Path$1 = { };

function run(p) {
  return new Promise((function (resolve, param) {
                rimraf_1(p, (function (err) {
                        if (err == null) {
                          return resolve(/* Ok */caml_chrome_debugger.variant("Ok", 0, [/* () */0]));
                        } else {
                          return resolve(/* Error */caml_chrome_debugger.variant("Error", 1, [err.message]));
                        }
                      }));
                return /* () */0;
              }));
}

var Rimraf$1 = {
  run: run
};

var JsError = /* alias */0;

var Process_1 = Process;
var $$Error_1$1 = $$Error$1;
var JsError_1 = JsError;
var scriptPath_1 = scriptPath;
var downloadGit_1 = downloadGit;
var $$Buffer = $$Buffer$1;
var StreamFunctor_1 = StreamFunctor;
var Stream_1 = Stream;
var ChildProcess_1 = ChildProcess;
var $$Response_1 = $$Response;
var $$Request_1 = $$Request;
var RequestProgress_1 = RequestProgress;
var Https_1 = Https$1;
var Fs_1 = Fs$1;
var throwJSError_1 = throwJSError;
var handlePromiseRejectInJS_1 = handlePromiseRejectInJS;
var Chalk_1 = Chalk$1;
var Path_1$1 = Path$1;
var Rimraf_1 = Rimraf$1;
/* scriptPath Not a pure module */

var Bindings_bs = {
	Process: Process_1,
	$$Error: $$Error_1$1,
	JsError: JsError_1,
	scriptPath: scriptPath_1,
	downloadGit: downloadGit_1,
	$$Buffer: $$Buffer,
	StreamFunctor: StreamFunctor_1,
	Stream: Stream_1,
	ChildProcess: ChildProcess_1,
	$$Response: $$Response_1,
	$$Request: $$Request_1,
	RequestProgress: RequestProgress_1,
	Https: Https_1,
	Fs: Fs_1,
	throwJSError: throwJSError_1,
	handlePromiseRejectInJS: handlePromiseRejectInJS_1,
	Chalk: Chalk_1,
	Path: Path_1$1,
	Rimraf: Rimraf_1
};

var pathMissingFromEnv = "'PATH' variable not found in the environment";

var env_sep =  ";" ;

function binPath(c) {
  return c.cmd;
}

function make$4(env, cmd) {
  var match = js_dict.get(env, "PATH");
  if (match !== undefined) {
    var path = match;
    var cmds =  /* array */[cmd] ;
    return Promise.all(array.map((function (cmd) {
                              return path.split(env_sep).map((function (p) {
                                            return filename.concat(p, cmd);
                                          }));
                            }), cmds).reduce((function (prim, prim$1) {
                            return prim$1.concat(prim);
                            }), /* array */[]).map((function (p) {
			      console.log("Checking...", p);
                          return Bindings_bs.Fs.exists(p).then((function (exists) {
                                        return Promise.resolve(/* tuple */[
                                                    p,
                                                    exists
                                                  ]);
                                      }));
                        }))).then((function (r) {
                    return Promise.resolve(r.filter((function (param) {
                                      return param[1];
                                    })));
                  })).then((function (r) {
                    var r$1 = array.to_list(r);
		    console.log(process.env['PATH']);
                  return Promise.resolve(r$1 ? /* Ok */caml_chrome_debugger.variant("Ok", 0, [{
                                    cmd: r$1[0][0],
                                    env: env
                                  }]) : /* Error */caml_chrome_debugger.variant("Error", 1, [" Command \"" + (String(cmd) + "\" not found ")]));
                }));
  } else {
    return Promise.resolve(/* Error */caml_chrome_debugger.variant("Error", 1, [pathMissingFromEnv]));
  }
}

function output$2(args, cwd, cmd) {
  var cmd$1 = cmd.cmd;
  var shellString = /* array */[cmd$1].concat(args).join(" ");
  return Bindings_bs.ChildProcess.exec(shellString, curry._4(Bindings_bs.ChildProcess.Options.make, cwd, caml_option.some(cmd.env), undefined, /* () */0)).then((function (r) {
                var tmp;
                if (r.tag) {
                  tmp = Utils_bs.Result.fail(" Exec failed: " + (String(shellString) + " "));
                } else {
                  var match = r[0];
                  var stderr = match[2];
                  var exitCode = match[0];
                  tmp = exitCode === 0 ? /* Ok */caml_chrome_debugger.variant("Ok", 0, [/* tuple */[
                          match[1],
                          stderr
                        ]]) : /* Error */caml_chrome_debugger.variant("Error", 1, [" Command " + (String(cmd$1) + (" failed:\nexitCode: " + (String(exitCode) + ("\nstderr: " + (String(stderr) + "\n")))))]);
                }
                return Promise.resolve(tmp);
              }));
}

function spawn$1(args, cwd, cmd) {
  console.log("<<<<<<<<", cmd);
  var cmd$1 = cmd.cmd;
  return new Promise((function (resolve, param) {
                var $$process = Bindings_bs.ChildProcess.spawn(cmd$1, args, curry._4(Bindings_bs.ChildProcess.Options.make, cwd, undefined, "inherit", /* () */0));
                return Bindings_bs.ChildProcess.onClose($$process, (function (exitCode) {
                              if (exitCode === 0) {
                                return resolve(/* Ok */caml_chrome_debugger.variant("Ok", 0, [/* () */0]));
                              } else {
                                return resolve(/* Error */caml_chrome_debugger.variant("Error", 1, [/* array */[cmd$1].concat(args).join(" ")]));
                              }
                            }));
              }));
}

var pathMissingFromEnv_1 = pathMissingFromEnv;
var env_sep_1 = env_sep;
var binPath_1 = binPath;
var make_1$2 = make$4;
var output_1$2 = output$2;
var spawn_1 = spawn$1;
/* Bindings Not a pure module */

var Cmd_bs = {
	pathMissingFromEnv: pathMissingFromEnv_1,
	env_sep: env_sep_1,
	binPath: binPath_1,
	make: make_1$2,
	output: output_1$2,
	spawn: spawn_1
};

function raiseError(str) {
  throw new Error(str);
}

function raiseEvalError(str) {
  throw new EvalError(str);
}

function raiseRangeError(str) {
  throw new RangeError(str);
}

function raiseReferenceError(str) {
  throw new ReferenceError(str);
}

function raiseSyntaxError(str) {
  throw new SyntaxError(str);
}

function raiseTypeError(str) {
  throw new TypeError(str);
}

function raiseUriError(str) {
  throw new URIError(str);
}

var $$Error$1$1 = caml_js_exceptions.$$Error;

var $$Error$2 = $$Error$1$1;
var raiseError_1 = raiseError;
var raiseEvalError_1 = raiseEvalError;
var raiseRangeError_1 = raiseRangeError;
var raiseReferenceError_1 = raiseReferenceError;
var raiseSyntaxError_1 = raiseSyntaxError;
var raiseTypeError_1 = raiseTypeError;
var raiseUriError_1 = raiseUriError;
/* No side effect */

var js_exn = {
	$$Error: $$Error$2,
	raiseError: raiseError_1,
	raiseEvalError: raiseEvalError_1,
	raiseRangeError: raiseRangeError_1,
	raiseReferenceError: raiseReferenceError_1,
	raiseSyntaxError: raiseSyntaxError_1,
	raiseTypeError: raiseTypeError_1,
	raiseUriError: raiseUriError_1
};

var ParseError = caml_exceptions.create("Json.ParseError");

function parse$1(s) {
  try {
    return caml_option.some(JSON.parse(s));
  }
  catch (exn){
    return ;
  }
}

function parseOrRaise(s) {
  try {
    return JSON.parse(s);
  }
  catch (raw_exn){
    var exn = caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] === js_exn.$$Error) {
      var match = exn[1].message;
      var message = match !== undefined ? match : "Unknown error";
      throw [
            ParseError,
            message
          ];
    } else {
      throw exn;
    }
  }
}

var Decode = /* alias */0;

var Encode = /* alias */0;

function stringify(prim) {
  return JSON.stringify(prim);
}

var Decode_1 = Decode;
var Encode_1 = Encode;
var ParseError_1 = ParseError;
var parse_1 = parse$1;
var parseOrRaise_1 = parseOrRaise;
var stringify_1 = stringify;
/* No side effect */

var Json_bs = {
	Decode: Decode_1,
	Encode: Encode_1,
	ParseError: ParseError_1,
	parse: parse_1,
	parseOrRaise: parseOrRaise_1,
	stringify: stringify_1
};

function length$2(l) {
  var _len = 0;
  var _param = l;
  while(true) {
    var param = _param;
    var len = _len;
    if (param) {
      _param = param[1];
      _len = len + 1 | 0;
      continue ;
    } else {
      return len;
    }
  }}

function cons(a, l) {
  return /* :: */[
          a,
          l
        ];
}

function hd(param) {
  if (param) {
    return param[0];
  } else {
    throw [
          caml_builtin_exceptions.failure,
          "hd"
        ];
  }
}

function tl(param) {
  if (param) {
    return param[1];
  } else {
    throw [
          caml_builtin_exceptions.failure,
          "tl"
        ];
  }
}

function nth$1(l, n) {
  if (n < 0) {
    throw [
          caml_builtin_exceptions.invalid_argument,
          "List.nth"
        ];
  }
  var _l = l;
  var _n = n;
  while(true) {
    var n$1 = _n;
    var l$1 = _l;
    if (l$1) {
      if (n$1 === 0) {
        return l$1[0];
      } else {
        _n = n$1 - 1 | 0;
        _l = l$1[1];
        continue ;
      }
    } else {
      throw [
            caml_builtin_exceptions.failure,
            "nth"
          ];
    }
  }}

function nth_opt(l, n) {
  if (n < 0) {
    throw [
          caml_builtin_exceptions.invalid_argument,
          "List.nth"
        ];
  }
  var _l = l;
  var _n = n;
  while(true) {
    var n$1 = _n;
    var l$1 = _l;
    if (l$1) {
      if (n$1 === 0) {
        return caml_option.some(l$1[0]);
      } else {
        _n = n$1 - 1 | 0;
        _l = l$1[1];
        continue ;
      }
    } else {
      return ;
    }
  }}

function rev_append(_l1, _l2) {
  while(true) {
    var l2 = _l2;
    var l1 = _l1;
    if (l1) {
      _l2 = /* :: */[
        l1[0],
        l2
      ];
      _l1 = l1[1];
      continue ;
    } else {
      return l2;
    }
  }}

function rev(l) {
  return rev_append(l, /* [] */0);
}

function init_tailrec_aux(_acc, _i, n, f) {
  while(true) {
    var i = _i;
    var acc = _acc;
    if (i >= n) {
      return acc;
    } else {
      _i = i + 1 | 0;
      _acc = /* :: */[
        curry._1(f, i),
        acc
      ];
      continue ;
    }
  }}

function init_aux(i, n, f) {
  if (i >= n) {
    return /* [] */0;
  } else {
    var r = curry._1(f, i);
    return /* :: */[
            r,
            init_aux(i + 1 | 0, n, f)
          ];
  }
}

function init$4(len, f) {
  if (len < 0) {
    throw [
          caml_builtin_exceptions.invalid_argument,
          "List.init"
        ];
  }
  if (len > 10000) {
    return rev_append(init_tailrec_aux(/* [] */0, 0, len, f), /* [] */0);
  } else {
    return init_aux(0, len, f);
  }
}

function flatten(param) {
  if (param) {
    return pervasives.$at(param[0], flatten(param[1]));
  } else {
    return /* [] */0;
  }
}

function map$6(f, param) {
  if (param) {
    var r = curry._1(f, param[0]);
    return /* :: */[
            r,
            map$6(f, param[1])
          ];
  } else {
    return /* [] */0;
  }
}

function mapi$3(i, f, param) {
  if (param) {
    var r = curry._2(f, i, param[0]);
    return /* :: */[
            r,
            mapi$3(i + 1 | 0, f, param[1])
          ];
  } else {
    return /* [] */0;
  }
}

function mapi$1$1(f, l) {
  return mapi$3(0, f, l);
}

function rev_map(f, l) {
  var _accu = /* [] */0;
  var _param = l;
  while(true) {
    var param = _param;
    var accu = _accu;
    if (param) {
      _param = param[1];
      _accu = /* :: */[
        curry._1(f, param[0]),
        accu
      ];
      continue ;
    } else {
      return accu;
    }
  }}

function iter$3(f, _param) {
  while(true) {
    var param = _param;
    if (param) {
      curry._1(f, param[0]);
      _param = param[1];
      continue ;
    } else {
      return /* () */0;
    }
  }}

function iteri$3(f, l) {
  var _i = 0;
  var f$1 = f;
  var _param = l;
  while(true) {
    var param = _param;
    var i = _i;
    if (param) {
      curry._2(f$1, i, param[0]);
      _param = param[1];
      _i = i + 1 | 0;
      continue ;
    } else {
      return /* () */0;
    }
  }}

function fold_left$1(f, _accu, _l) {
  while(true) {
    var l = _l;
    var accu = _accu;
    if (l) {
      _l = l[1];
      _accu = curry._2(f, accu, l[0]);
      continue ;
    } else {
      return accu;
    }
  }}

function fold_right$1(f, l, accu) {
  if (l) {
    return curry._2(f, l[0], fold_right$1(f, l[1], accu));
  } else {
    return accu;
  }
}

function map2$1(f, l1, l2) {
  if (l1) {
    if (l2) {
      var r = curry._2(f, l1[0], l2[0]);
      return /* :: */[
              r,
              map2$1(f, l1[1], l2[1])
            ];
    } else {
      throw [
            caml_builtin_exceptions.invalid_argument,
            "List.map2"
          ];
    }
  } else if (l2) {
    throw [
          caml_builtin_exceptions.invalid_argument,
          "List.map2"
        ];
  } else {
    return /* [] */0;
  }
}

function rev_map2(f, l1, l2) {
  var _accu = /* [] */0;
  var _l1 = l1;
  var _l2 = l2;
  while(true) {
    var l2$1 = _l2;
    var l1$1 = _l1;
    var accu = _accu;
    if (l1$1) {
      if (l2$1) {
        _l2 = l2$1[1];
        _l1 = l1$1[1];
        _accu = /* :: */[
          curry._2(f, l1$1[0], l2$1[0]),
          accu
        ];
        continue ;
      } else {
        throw [
              caml_builtin_exceptions.invalid_argument,
              "List.rev_map2"
            ];
      }
    } else {
      if (l2$1) {
        throw [
              caml_builtin_exceptions.invalid_argument,
              "List.rev_map2"
            ];
      }
      return accu;
    }
  }}

function iter2$1(f, _l1, _l2) {
  while(true) {
    var l2 = _l2;
    var l1 = _l1;
    if (l1) {
      if (l2) {
        curry._2(f, l1[0], l2[0]);
        _l2 = l2[1];
        _l1 = l1[1];
        continue ;
      } else {
        throw [
              caml_builtin_exceptions.invalid_argument,
              "List.iter2"
            ];
      }
    } else if (l2) {
      throw [
            caml_builtin_exceptions.invalid_argument,
            "List.iter2"
          ];
    } else {
      return /* () */0;
    }
  }}

function fold_left2(f, _accu, _l1, _l2) {
  while(true) {
    var l2 = _l2;
    var l1 = _l1;
    var accu = _accu;
    if (l1) {
      if (l2) {
        _l2 = l2[1];
        _l1 = l1[1];
        _accu = curry._3(f, accu, l1[0], l2[0]);
        continue ;
      } else {
        throw [
              caml_builtin_exceptions.invalid_argument,
              "List.fold_left2"
            ];
      }
    } else {
      if (l2) {
        throw [
              caml_builtin_exceptions.invalid_argument,
              "List.fold_left2"
            ];
      }
      return accu;
    }
  }}

function fold_right2(f, l1, l2, accu) {
  if (l1) {
    if (l2) {
      return curry._3(f, l1[0], l2[0], fold_right2(f, l1[1], l2[1], accu));
    } else {
      throw [
            caml_builtin_exceptions.invalid_argument,
            "List.fold_right2"
          ];
    }
  } else {
    if (l2) {
      throw [
            caml_builtin_exceptions.invalid_argument,
            "List.fold_right2"
          ];
    }
    return accu;
  }
}

function for_all$1(p, _param) {
  while(true) {
    var param = _param;
    if (param) {
      if (curry._1(p, param[0])) {
        _param = param[1];
        continue ;
      } else {
        return false;
      }
    } else {
      return true;
    }
  }}

function exists$3(p, _param) {
  while(true) {
    var param = _param;
    if (param) {
      if (curry._1(p, param[0])) {
        return true;
      } else {
        _param = param[1];
        continue ;
      }
    } else {
      return false;
    }
  }}

function for_all2(p, _l1, _l2) {
  while(true) {
    var l2 = _l2;
    var l1 = _l1;
    if (l1) {
      if (l2) {
        if (curry._2(p, l1[0], l2[0])) {
          _l2 = l2[1];
          _l1 = l1[1];
          continue ;
        } else {
          return false;
        }
      } else {
        throw [
              caml_builtin_exceptions.invalid_argument,
              "List.for_all2"
            ];
      }
    } else if (l2) {
      throw [
            caml_builtin_exceptions.invalid_argument,
            "List.for_all2"
          ];
    } else {
      return true;
    }
  }}

function exists2(p, _l1, _l2) {
  while(true) {
    var l2 = _l2;
    var l1 = _l1;
    if (l1) {
      if (l2) {
        if (curry._2(p, l1[0], l2[0])) {
          return true;
        } else {
          _l2 = l2[1];
          _l1 = l1[1];
          continue ;
        }
      } else {
        throw [
              caml_builtin_exceptions.invalid_argument,
              "List.exists2"
            ];
      }
    } else if (l2) {
      throw [
            caml_builtin_exceptions.invalid_argument,
            "List.exists2"
          ];
    } else {
      return false;
    }
  }}

function mem$1(x, _param) {
  while(true) {
    var param = _param;
    if (param) {
      if (caml_obj.caml_equal(param[0], x)) {
        return true;
      } else {
        _param = param[1];
        continue ;
      }
    } else {
      return false;
    }
  }}

function memq$1(x, _param) {
  while(true) {
    var param = _param;
    if (param) {
      if (param[0] === x) {
        return true;
      } else {
        _param = param[1];
        continue ;
      }
    } else {
      return false;
    }
  }}

function assoc(x, _param) {
  while(true) {
    var param = _param;
    if (param) {
      var match = param[0];
      if (caml_obj.caml_equal(match[0], x)) {
        return match[1];
      } else {
        _param = param[1];
        continue ;
      }
    } else {
      throw caml_builtin_exceptions.not_found;
    }
  }}

function assoc_opt(x, _param) {
  while(true) {
    var param = _param;
    if (param) {
      var match = param[0];
      if (caml_obj.caml_equal(match[0], x)) {
        return caml_option.some(match[1]);
      } else {
        _param = param[1];
        continue ;
      }
    } else {
      return ;
    }
  }}

function assq(x, _param) {
  while(true) {
    var param = _param;
    if (param) {
      var match = param[0];
      if (match[0] === x) {
        return match[1];
      } else {
        _param = param[1];
        continue ;
      }
    } else {
      throw caml_builtin_exceptions.not_found;
    }
  }}

function assq_opt(x, _param) {
  while(true) {
    var param = _param;
    if (param) {
      var match = param[0];
      if (match[0] === x) {
        return caml_option.some(match[1]);
      } else {
        _param = param[1];
        continue ;
      }
    } else {
      return ;
    }
  }}

function mem_assoc(x, _param) {
  while(true) {
    var param = _param;
    if (param) {
      if (caml_obj.caml_equal(param[0][0], x)) {
        return true;
      } else {
        _param = param[1];
        continue ;
      }
    } else {
      return false;
    }
  }}

function mem_assq(x, _param) {
  while(true) {
    var param = _param;
    if (param) {
      if (param[0][0] === x) {
        return true;
      } else {
        _param = param[1];
        continue ;
      }
    } else {
      return false;
    }
  }}

function remove_assoc(x, param) {
  if (param) {
    var l = param[1];
    var pair = param[0];
    if (caml_obj.caml_equal(pair[0], x)) {
      return l;
    } else {
      return /* :: */[
              pair,
              remove_assoc(x, l)
            ];
    }
  } else {
    return /* [] */0;
  }
}

function remove_assq(x, param) {
  if (param) {
    var l = param[1];
    var pair = param[0];
    if (pair[0] === x) {
      return l;
    } else {
      return /* :: */[
              pair,
              remove_assq(x, l)
            ];
    }
  } else {
    return /* [] */0;
  }
}

function find(p, _param) {
  while(true) {
    var param = _param;
    if (param) {
      var x = param[0];
      if (curry._1(p, x)) {
        return x;
      } else {
        _param = param[1];
        continue ;
      }
    } else {
      throw caml_builtin_exceptions.not_found;
    }
  }}

function find_opt(p, _param) {
  while(true) {
    var param = _param;
    if (param) {
      var x = param[0];
      if (curry._1(p, x)) {
        return caml_option.some(x);
      } else {
        _param = param[1];
        continue ;
      }
    } else {
      return ;
    }
  }}

function find_all(p) {
  return (function (param) {
      var _accu = /* [] */0;
      var _param = param;
      while(true) {
        var param$1 = _param;
        var accu = _accu;
        if (param$1) {
          var l = param$1[1];
          var x = param$1[0];
          if (curry._1(p, x)) {
            _param = l;
            _accu = /* :: */[
              x,
              accu
            ];
            continue ;
          } else {
            _param = l;
            continue ;
          }
        } else {
          return rev_append(accu, /* [] */0);
        }
      }    });
}

function partition(p, l) {
  var _yes = /* [] */0;
  var _no = /* [] */0;
  var _param = l;
  while(true) {
    var param = _param;
    var no = _no;
    var yes = _yes;
    if (param) {
      var l$1 = param[1];
      var x = param[0];
      if (curry._1(p, x)) {
        _param = l$1;
        _yes = /* :: */[
          x,
          yes
        ];
        continue ;
      } else {
        _param = l$1;
        _no = /* :: */[
          x,
          no
        ];
        continue ;
      }
    } else {
      return /* tuple */[
              rev_append(yes, /* [] */0),
              rev_append(no, /* [] */0)
            ];
    }
  }}

function split(param) {
  if (param) {
    var match = param[0];
    var match$1 = split(param[1]);
    return /* tuple */[
            /* :: */[
              match[0],
              match$1[0]
            ],
            /* :: */[
              match[1],
              match$1[1]
            ]
          ];
  } else {
    return /* tuple */[
            /* [] */0,
            /* [] */0
          ];
  }
}

function combine(l1, l2) {
  if (l1) {
    if (l2) {
      return /* :: */[
              /* tuple */[
                l1[0],
                l2[0]
              ],
              combine(l1[1], l2[1])
            ];
    } else {
      throw [
            caml_builtin_exceptions.invalid_argument,
            "List.combine"
          ];
    }
  } else if (l2) {
    throw [
          caml_builtin_exceptions.invalid_argument,
          "List.combine"
        ];
  } else {
    return /* [] */0;
  }
}

function merge(cmp, l1, l2) {
  if (l1) {
    if (l2) {
      var h2 = l2[0];
      var h1 = l1[0];
      if (curry._2(cmp, h1, h2) <= 0) {
        return /* :: */[
                h1,
                merge(cmp, l1[1], l2)
              ];
      } else {
        return /* :: */[
                h2,
                merge(cmp, l1, l2[1])
              ];
      }
    } else {
      return l1;
    }
  } else {
    return l2;
  }
}

function chop(_k, _l) {
  while(true) {
    var l = _l;
    var k = _k;
    if (k === 0) {
      return l;
    } else if (l) {
      _l = l[1];
      _k = k - 1 | 0;
      continue ;
    } else {
      throw [
            caml_builtin_exceptions.assert_failure,
            /* tuple */[
              "list.ml",
              262,
              11
            ]
          ];
    }
  }}

function stable_sort$1(cmp, l) {
  var sort = function (n, l) {
    if (n !== 2) {
      if (n === 3 && l) {
        var match = l[1];
        if (match) {
          var match$1 = match[1];
          if (match$1) {
            var x3 = match$1[0];
            var x2 = match[0];
            var x1 = l[0];
            if (curry._2(cmp, x1, x2) <= 0) {
              if (curry._2(cmp, x2, x3) <= 0) {
                return /* :: */[
                        x1,
                        /* :: */[
                          x2,
                          /* :: */[
                            x3,
                            /* [] */0
                          ]
                        ]
                      ];
              } else if (curry._2(cmp, x1, x3) <= 0) {
                return /* :: */[
                        x1,
                        /* :: */[
                          x3,
                          /* :: */[
                            x2,
                            /* [] */0
                          ]
                        ]
                      ];
              } else {
                return /* :: */[
                        x3,
                        /* :: */[
                          x1,
                          /* :: */[
                            x2,
                            /* [] */0
                          ]
                        ]
                      ];
              }
            } else if (curry._2(cmp, x1, x3) <= 0) {
              return /* :: */[
                      x2,
                      /* :: */[
                        x1,
                        /* :: */[
                          x3,
                          /* [] */0
                        ]
                      ]
                    ];
            } else if (curry._2(cmp, x2, x3) <= 0) {
              return /* :: */[
                      x2,
                      /* :: */[
                        x3,
                        /* :: */[
                          x1,
                          /* [] */0
                        ]
                      ]
                    ];
            } else {
              return /* :: */[
                      x3,
                      /* :: */[
                        x2,
                        /* :: */[
                          x1,
                          /* [] */0
                        ]
                      ]
                    ];
            }
          }
          
        }
        
      }
      
    } else if (l) {
      var match$2 = l[1];
      if (match$2) {
        var x2$1 = match$2[0];
        var x1$1 = l[0];
        if (curry._2(cmp, x1$1, x2$1) <= 0) {
          return /* :: */[
                  x1$1,
                  /* :: */[
                    x2$1,
                    /* [] */0
                  ]
                ];
        } else {
          return /* :: */[
                  x2$1,
                  /* :: */[
                    x1$1,
                    /* [] */0
                  ]
                ];
        }
      }
      
    }
    var n1 = (n >> 1);
    var n2 = n - n1 | 0;
    var l2 = chop(n1, l);
    var s1 = rev_sort(n1, l);
    var s2 = rev_sort(n2, l2);
    var _l1 = s1;
    var _l2 = s2;
    var _accu = /* [] */0;
    while(true) {
      var accu = _accu;
      var l2$1 = _l2;
      var l1 = _l1;
      if (l1) {
        if (l2$1) {
          var h2 = l2$1[0];
          var h1 = l1[0];
          if (curry._2(cmp, h1, h2) > 0) {
            _accu = /* :: */[
              h1,
              accu
            ];
            _l1 = l1[1];
            continue ;
          } else {
            _accu = /* :: */[
              h2,
              accu
            ];
            _l2 = l2$1[1];
            continue ;
          }
        } else {
          return rev_append(l1, accu);
        }
      } else {
        return rev_append(l2$1, accu);
      }
    }  };
  var rev_sort = function (n, l) {
    if (n !== 2) {
      if (n === 3 && l) {
        var match = l[1];
        if (match) {
          var match$1 = match[1];
          if (match$1) {
            var x3 = match$1[0];
            var x2 = match[0];
            var x1 = l[0];
            if (curry._2(cmp, x1, x2) > 0) {
              if (curry._2(cmp, x2, x3) > 0) {
                return /* :: */[
                        x1,
                        /* :: */[
                          x2,
                          /* :: */[
                            x3,
                            /* [] */0
                          ]
                        ]
                      ];
              } else if (curry._2(cmp, x1, x3) > 0) {
                return /* :: */[
                        x1,
                        /* :: */[
                          x3,
                          /* :: */[
                            x2,
                            /* [] */0
                          ]
                        ]
                      ];
              } else {
                return /* :: */[
                        x3,
                        /* :: */[
                          x1,
                          /* :: */[
                            x2,
                            /* [] */0
                          ]
                        ]
                      ];
              }
            } else if (curry._2(cmp, x1, x3) > 0) {
              return /* :: */[
                      x2,
                      /* :: */[
                        x1,
                        /* :: */[
                          x3,
                          /* [] */0
                        ]
                      ]
                    ];
            } else if (curry._2(cmp, x2, x3) > 0) {
              return /* :: */[
                      x2,
                      /* :: */[
                        x3,
                        /* :: */[
                          x1,
                          /* [] */0
                        ]
                      ]
                    ];
            } else {
              return /* :: */[
                      x3,
                      /* :: */[
                        x2,
                        /* :: */[
                          x1,
                          /* [] */0
                        ]
                      ]
                    ];
            }
          }
          
        }
        
      }
      
    } else if (l) {
      var match$2 = l[1];
      if (match$2) {
        var x2$1 = match$2[0];
        var x1$1 = l[0];
        if (curry._2(cmp, x1$1, x2$1) > 0) {
          return /* :: */[
                  x1$1,
                  /* :: */[
                    x2$1,
                    /* [] */0
                  ]
                ];
        } else {
          return /* :: */[
                  x2$1,
                  /* :: */[
                    x1$1,
                    /* [] */0
                  ]
                ];
        }
      }
      
    }
    var n1 = (n >> 1);
    var n2 = n - n1 | 0;
    var l2 = chop(n1, l);
    var s1 = sort(n1, l);
    var s2 = sort(n2, l2);
    var _l1 = s1;
    var _l2 = s2;
    var _accu = /* [] */0;
    while(true) {
      var accu = _accu;
      var l2$1 = _l2;
      var l1 = _l1;
      if (l1) {
        if (l2$1) {
          var h2 = l2$1[0];
          var h1 = l1[0];
          if (curry._2(cmp, h1, h2) <= 0) {
            _accu = /* :: */[
              h1,
              accu
            ];
            _l1 = l1[1];
            continue ;
          } else {
            _accu = /* :: */[
              h2,
              accu
            ];
            _l2 = l2$1[1];
            continue ;
          }
        } else {
          return rev_append(l1, accu);
        }
      } else {
        return rev_append(l2$1, accu);
      }
    }  };
  var len = length$2(l);
  if (len < 2) {
    return l;
  } else {
    return sort(len, l);
  }
}

function sort_uniq(cmp, l) {
  var sort = function (n, l) {
    if (n !== 2) {
      if (n === 3 && l) {
        var match = l[1];
        if (match) {
          var match$1 = match[1];
          if (match$1) {
            var x3 = match$1[0];
            var x2 = match[0];
            var x1 = l[0];
            var c = curry._2(cmp, x1, x2);
            if (c === 0) {
              var c$1 = curry._2(cmp, x2, x3);
              if (c$1 === 0) {
                return /* :: */[
                        x2,
                        /* [] */0
                      ];
              } else if (c$1 < 0) {
                return /* :: */[
                        x2,
                        /* :: */[
                          x3,
                          /* [] */0
                        ]
                      ];
              } else {
                return /* :: */[
                        x3,
                        /* :: */[
                          x2,
                          /* [] */0
                        ]
                      ];
              }
            } else if (c < 0) {
              var c$2 = curry._2(cmp, x2, x3);
              if (c$2 === 0) {
                return /* :: */[
                        x1,
                        /* :: */[
                          x2,
                          /* [] */0
                        ]
                      ];
              } else if (c$2 < 0) {
                return /* :: */[
                        x1,
                        /* :: */[
                          x2,
                          /* :: */[
                            x3,
                            /* [] */0
                          ]
                        ]
                      ];
              } else {
                var c$3 = curry._2(cmp, x1, x3);
                if (c$3 === 0) {
                  return /* :: */[
                          x1,
                          /* :: */[
                            x2,
                            /* [] */0
                          ]
                        ];
                } else if (c$3 < 0) {
                  return /* :: */[
                          x1,
                          /* :: */[
                            x3,
                            /* :: */[
                              x2,
                              /* [] */0
                            ]
                          ]
                        ];
                } else {
                  return /* :: */[
                          x3,
                          /* :: */[
                            x1,
                            /* :: */[
                              x2,
                              /* [] */0
                            ]
                          ]
                        ];
                }
              }
            } else {
              var c$4 = curry._2(cmp, x1, x3);
              if (c$4 === 0) {
                return /* :: */[
                        x2,
                        /* :: */[
                          x1,
                          /* [] */0
                        ]
                      ];
              } else if (c$4 < 0) {
                return /* :: */[
                        x2,
                        /* :: */[
                          x1,
                          /* :: */[
                            x3,
                            /* [] */0
                          ]
                        ]
                      ];
              } else {
                var c$5 = curry._2(cmp, x2, x3);
                if (c$5 === 0) {
                  return /* :: */[
                          x2,
                          /* :: */[
                            x1,
                            /* [] */0
                          ]
                        ];
                } else if (c$5 < 0) {
                  return /* :: */[
                          x2,
                          /* :: */[
                            x3,
                            /* :: */[
                              x1,
                              /* [] */0
                            ]
                          ]
                        ];
                } else {
                  return /* :: */[
                          x3,
                          /* :: */[
                            x2,
                            /* :: */[
                              x1,
                              /* [] */0
                            ]
                          ]
                        ];
                }
              }
            }
          }
          
        }
        
      }
      
    } else if (l) {
      var match$2 = l[1];
      if (match$2) {
        var x2$1 = match$2[0];
        var x1$1 = l[0];
        var c$6 = curry._2(cmp, x1$1, x2$1);
        if (c$6 === 0) {
          return /* :: */[
                  x1$1,
                  /* [] */0
                ];
        } else if (c$6 < 0) {
          return /* :: */[
                  x1$1,
                  /* :: */[
                    x2$1,
                    /* [] */0
                  ]
                ];
        } else {
          return /* :: */[
                  x2$1,
                  /* :: */[
                    x1$1,
                    /* [] */0
                  ]
                ];
        }
      }
      
    }
    var n1 = (n >> 1);
    var n2 = n - n1 | 0;
    var l2 = chop(n1, l);
    var s1 = rev_sort(n1, l);
    var s2 = rev_sort(n2, l2);
    var _l1 = s1;
    var _l2 = s2;
    var _accu = /* [] */0;
    while(true) {
      var accu = _accu;
      var l2$1 = _l2;
      var l1 = _l1;
      if (l1) {
        if (l2$1) {
          var t2 = l2$1[1];
          var h2 = l2$1[0];
          var t1 = l1[1];
          var h1 = l1[0];
          var c$7 = curry._2(cmp, h1, h2);
          if (c$7 === 0) {
            _accu = /* :: */[
              h1,
              accu
            ];
            _l2 = t2;
            _l1 = t1;
            continue ;
          } else if (c$7 > 0) {
            _accu = /* :: */[
              h1,
              accu
            ];
            _l1 = t1;
            continue ;
          } else {
            _accu = /* :: */[
              h2,
              accu
            ];
            _l2 = t2;
            continue ;
          }
        } else {
          return rev_append(l1, accu);
        }
      } else {
        return rev_append(l2$1, accu);
      }
    }  };
  var rev_sort = function (n, l) {
    if (n !== 2) {
      if (n === 3 && l) {
        var match = l[1];
        if (match) {
          var match$1 = match[1];
          if (match$1) {
            var x3 = match$1[0];
            var x2 = match[0];
            var x1 = l[0];
            var c = curry._2(cmp, x1, x2);
            if (c === 0) {
              var c$1 = curry._2(cmp, x2, x3);
              if (c$1 === 0) {
                return /* :: */[
                        x2,
                        /* [] */0
                      ];
              } else if (c$1 > 0) {
                return /* :: */[
                        x2,
                        /* :: */[
                          x3,
                          /* [] */0
                        ]
                      ];
              } else {
                return /* :: */[
                        x3,
                        /* :: */[
                          x2,
                          /* [] */0
                        ]
                      ];
              }
            } else if (c > 0) {
              var c$2 = curry._2(cmp, x2, x3);
              if (c$2 === 0) {
                return /* :: */[
                        x1,
                        /* :: */[
                          x2,
                          /* [] */0
                        ]
                      ];
              } else if (c$2 > 0) {
                return /* :: */[
                        x1,
                        /* :: */[
                          x2,
                          /* :: */[
                            x3,
                            /* [] */0
                          ]
                        ]
                      ];
              } else {
                var c$3 = curry._2(cmp, x1, x3);
                if (c$3 === 0) {
                  return /* :: */[
                          x1,
                          /* :: */[
                            x2,
                            /* [] */0
                          ]
                        ];
                } else if (c$3 > 0) {
                  return /* :: */[
                          x1,
                          /* :: */[
                            x3,
                            /* :: */[
                              x2,
                              /* [] */0
                            ]
                          ]
                        ];
                } else {
                  return /* :: */[
                          x3,
                          /* :: */[
                            x1,
                            /* :: */[
                              x2,
                              /* [] */0
                            ]
                          ]
                        ];
                }
              }
            } else {
              var c$4 = curry._2(cmp, x1, x3);
              if (c$4 === 0) {
                return /* :: */[
                        x2,
                        /* :: */[
                          x1,
                          /* [] */0
                        ]
                      ];
              } else if (c$4 > 0) {
                return /* :: */[
                        x2,
                        /* :: */[
                          x1,
                          /* :: */[
                            x3,
                            /* [] */0
                          ]
                        ]
                      ];
              } else {
                var c$5 = curry._2(cmp, x2, x3);
                if (c$5 === 0) {
                  return /* :: */[
                          x2,
                          /* :: */[
                            x1,
                            /* [] */0
                          ]
                        ];
                } else if (c$5 > 0) {
                  return /* :: */[
                          x2,
                          /* :: */[
                            x3,
                            /* :: */[
                              x1,
                              /* [] */0
                            ]
                          ]
                        ];
                } else {
                  return /* :: */[
                          x3,
                          /* :: */[
                            x2,
                            /* :: */[
                              x1,
                              /* [] */0
                            ]
                          ]
                        ];
                }
              }
            }
          }
          
        }
        
      }
      
    } else if (l) {
      var match$2 = l[1];
      if (match$2) {
        var x2$1 = match$2[0];
        var x1$1 = l[0];
        var c$6 = curry._2(cmp, x1$1, x2$1);
        if (c$6 === 0) {
          return /* :: */[
                  x1$1,
                  /* [] */0
                ];
        } else if (c$6 > 0) {
          return /* :: */[
                  x1$1,
                  /* :: */[
                    x2$1,
                    /* [] */0
                  ]
                ];
        } else {
          return /* :: */[
                  x2$1,
                  /* :: */[
                    x1$1,
                    /* [] */0
                  ]
                ];
        }
      }
      
    }
    var n1 = (n >> 1);
    var n2 = n - n1 | 0;
    var l2 = chop(n1, l);
    var s1 = sort(n1, l);
    var s2 = sort(n2, l2);
    var _l1 = s1;
    var _l2 = s2;
    var _accu = /* [] */0;
    while(true) {
      var accu = _accu;
      var l2$1 = _l2;
      var l1 = _l1;
      if (l1) {
        if (l2$1) {
          var t2 = l2$1[1];
          var h2 = l2$1[0];
          var t1 = l1[1];
          var h1 = l1[0];
          var c$7 = curry._2(cmp, h1, h2);
          if (c$7 === 0) {
            _accu = /* :: */[
              h1,
              accu
            ];
            _l2 = t2;
            _l1 = t1;
            continue ;
          } else if (c$7 < 0) {
            _accu = /* :: */[
              h1,
              accu
            ];
            _l1 = t1;
            continue ;
          } else {
            _accu = /* :: */[
              h2,
              accu
            ];
            _l2 = t2;
            continue ;
          }
        } else {
          return rev_append(l1, accu);
        }
      } else {
        return rev_append(l2$1, accu);
      }
    }  };
  var len = length$2(l);
  if (len < 2) {
    return l;
  } else {
    return sort(len, l);
  }
}

function compare_lengths(_l1, _l2) {
  while(true) {
    var l2 = _l2;
    var l1 = _l1;
    if (l1) {
      if (l2) {
        _l2 = l2[1];
        _l1 = l1[1];
        continue ;
      } else {
        return 1;
      }
    } else if (l2) {
      return -1;
    } else {
      return 0;
    }
  }}

function compare_length_with(_l, _n) {
  while(true) {
    var n = _n;
    var l = _l;
    if (l) {
      if (n <= 0) {
        return 1;
      } else {
        _n = n - 1 | 0;
        _l = l[1];
        continue ;
      }
    } else if (n === 0) {
      return 0;
    } else if (n > 0) {
      return -1;
    } else {
      return 1;
    }
  }}

var append$1 = pervasives.$at;

var concat$4 = flatten;

var filter$1 = find_all;

var sort$1 = stable_sort$1;

var fast_sort$1 = stable_sort$1;

var length_1$1 = length$2;
var compare_lengths_1 = compare_lengths;
var compare_length_with_1 = compare_length_with;
var cons_1 = cons;
var hd_1 = hd;
var tl_1 = tl;
var nth_1$1 = nth$1;
var nth_opt_1 = nth_opt;
var rev_1 = rev;
var init_1$4 = init$4;
var append_1$1 = append$1;
var rev_append_1 = rev_append;
var concat_1$4 = concat$4;
var flatten_1 = flatten;
var iter_1$3 = iter$3;
var iteri_1$3 = iteri$3;
var map_1$6 = map$6;
var mapi_1$3 = mapi$1$1;
var rev_map_1 = rev_map;
var fold_left_1$1 = fold_left$1;
var fold_right_1$1 = fold_right$1;
var iter2_1$1 = iter2$1;
var map2_1$1 = map2$1;
var rev_map2_1 = rev_map2;
var fold_left2_1 = fold_left2;
var fold_right2_1 = fold_right2;
var for_all_1$1 = for_all$1;
var exists_1$1 = exists$3;
var for_all2_1 = for_all2;
var exists2_1 = exists2;
var mem_1$1 = mem$1;
var memq_1$1 = memq$1;
var find_1 = find;
var find_opt_1 = find_opt;
var filter_1 = filter$1;
var find_all_1 = find_all;
var partition_1 = partition;
var assoc_1 = assoc;
var assoc_opt_1 = assoc_opt;
var assq_1 = assq;
var assq_opt_1 = assq_opt;
var mem_assoc_1 = mem_assoc;
var mem_assq_1 = mem_assq;
var remove_assoc_1 = remove_assoc;
var remove_assq_1 = remove_assq;
var split_1 = split;
var combine_1 = combine;
var sort_1$1 = sort$1;
var stable_sort_1$1 = stable_sort$1;
var fast_sort_1$1 = fast_sort$1;
var sort_uniq_1 = sort_uniq;
var merge_1 = merge;
/* No side effect */

var list = {
	length: length_1$1,
	compare_lengths: compare_lengths_1,
	compare_length_with: compare_length_with_1,
	cons: cons_1,
	hd: hd_1,
	tl: tl_1,
	nth: nth_1$1,
	nth_opt: nth_opt_1,
	rev: rev_1,
	init: init_1$4,
	append: append_1$1,
	rev_append: rev_append_1,
	concat: concat_1$4,
	flatten: flatten_1,
	iter: iter_1$3,
	iteri: iteri_1$3,
	map: map_1$6,
	mapi: mapi_1$3,
	rev_map: rev_map_1,
	fold_left: fold_left_1$1,
	fold_right: fold_right_1$1,
	iter2: iter2_1$1,
	map2: map2_1$1,
	rev_map2: rev_map2_1,
	fold_left2: fold_left2_1,
	fold_right2: fold_right2_1,
	for_all: for_all_1$1,
	exists: exists_1$1,
	for_all2: for_all2_1,
	exists2: exists2_1,
	mem: mem_1$1,
	memq: memq_1$1,
	find: find_1,
	find_opt: find_opt_1,
	filter: filter_1,
	find_all: find_all_1,
	partition: partition_1,
	assoc: assoc_1,
	assoc_opt: assoc_opt_1,
	assq: assq_1,
	assq_opt: assq_opt_1,
	mem_assoc: mem_assoc_1,
	mem_assq: mem_assq_1,
	remove_assoc: remove_assoc_1,
	remove_assq: remove_assq_1,
	split: split_1,
	combine: combine_1,
	sort: sort_1$1,
	stable_sort: stable_sort_1$1,
	fast_sort: fast_sort_1$1,
	sort_uniq: sort_uniq_1,
	merge: merge_1
};

function _isInteger(value) {
  if (isFinite(value)) {
    return Math.floor(value) === value;
  } else {
    return false;
  }
}

var DecodeError = caml_exceptions.create("Json_decode.DecodeError");

function id$1(json) {
  return json;
}

function bool$2(json) {
  if (typeof json === "boolean") {
    return json;
  } else {
    throw [
          DecodeError,
          "Expected boolean, got " + JSON.stringify(json)
        ];
  }
}

function $$float$2(json) {
  if (typeof json === "number") {
    return json;
  } else {
    throw [
          DecodeError,
          "Expected number, got " + JSON.stringify(json)
        ];
  }
}

function $$int$2(json) {
  var f = $$float$2(json);
  if (_isInteger(f)) {
    return f;
  } else {
    throw [
          DecodeError,
          "Expected integer, got " + JSON.stringify(json)
        ];
  }
}

function string$2(json) {
  if (typeof json === "string") {
    return json;
  } else {
    throw [
          DecodeError,
          "Expected string, got " + JSON.stringify(json)
        ];
  }
}

function $$char(json) {
  var s = string$2(json);
  if (s.length === 1) {
    return caml_string.get(s, 0);
  } else {
    throw [
          DecodeError,
          "Expected single-character string, got " + JSON.stringify(json)
        ];
  }
}

function date(json) {
  return new Date(string$2(json));
}

function nullable(decode, json) {
  if (json === null) {
    return null;
  } else {
    return curry._1(decode, json);
  }
}

function nullAs(value, json) {
  if (json === null) {
    return value;
  } else {
    throw [
          DecodeError,
          "Expected null, got " + JSON.stringify(json)
        ];
  }
}

function array$1(decode, json) {
  if (Array.isArray(json)) {
    var length = json.length;
    var target = new Array(length);
    for(var i = 0 ,i_finish = length - 1 | 0; i <= i_finish; ++i){
      var value;
      try {
        value = curry._1(decode, json[i]);
      }
      catch (raw_exn){
        var exn = caml_js_exceptions.internalToOCamlException(raw_exn);
        if (exn[0] === DecodeError) {
          throw [
                DecodeError,
                exn[1] + ("\n\tin array at index " + String(i))
              ];
        }
        throw exn;
      }
      target[i] = value;
    }
    return target;
  } else {
    throw [
          DecodeError,
          "Expected array, got " + JSON.stringify(json)
        ];
  }
}

function list$1(decode, json) {
  return array.to_list(array$1(decode, json));
}

function pair(decodeA, decodeB, json) {
  if (Array.isArray(json)) {
    var length = json.length;
    if (length === 2) {
      try {
        return /* tuple */[
                curry._1(decodeA, json[0]),
                curry._1(decodeB, json[1])
              ];
      }
      catch (raw_exn){
        var exn = caml_js_exceptions.internalToOCamlException(raw_exn);
        if (exn[0] === DecodeError) {
          throw [
                DecodeError,
                exn[1] + "\n\tin pair/tuple2"
              ];
        }
        throw exn;
      }
    } else {
      throw [
            DecodeError,
            "Expected array of length 2, got array of length " + (String(length) + "")
          ];
    }
  } else {
    throw [
          DecodeError,
          "Expected array, got " + JSON.stringify(json)
        ];
  }
}

function tuple3(decodeA, decodeB, decodeC, json) {
  if (Array.isArray(json)) {
    var length = json.length;
    if (length === 3) {
      try {
        return /* tuple */[
                curry._1(decodeA, json[0]),
                curry._1(decodeB, json[1]),
                curry._1(decodeC, json[2])
              ];
      }
      catch (raw_exn){
        var exn = caml_js_exceptions.internalToOCamlException(raw_exn);
        if (exn[0] === DecodeError) {
          throw [
                DecodeError,
                exn[1] + "\n\tin tuple3"
              ];
        }
        throw exn;
      }
    } else {
      throw [
            DecodeError,
            "Expected array of length 3, got array of length " + (String(length) + "")
          ];
    }
  } else {
    throw [
          DecodeError,
          "Expected array, got " + JSON.stringify(json)
        ];
  }
}

function tuple4(decodeA, decodeB, decodeC, decodeD, json) {
  if (Array.isArray(json)) {
    var length = json.length;
    if (length === 4) {
      try {
        return /* tuple */[
                curry._1(decodeA, json[0]),
                curry._1(decodeB, json[1]),
                curry._1(decodeC, json[2]),
                curry._1(decodeD, json[3])
              ];
      }
      catch (raw_exn){
        var exn = caml_js_exceptions.internalToOCamlException(raw_exn);
        if (exn[0] === DecodeError) {
          throw [
                DecodeError,
                exn[1] + "\n\tin tuple4"
              ];
        }
        throw exn;
      }
    } else {
      throw [
            DecodeError,
            "Expected array of length 4, got array of length " + (String(length) + "")
          ];
    }
  } else {
    throw [
          DecodeError,
          "Expected array, got " + JSON.stringify(json)
        ];
  }
}

function dict(decode, json) {
  if (typeof json === "object" && !Array.isArray(json) && json !== null) {
    var keys = Object.keys(json);
    var l = keys.length;
    var target = { };
    for(var i = 0 ,i_finish = l - 1 | 0; i <= i_finish; ++i){
      var key = keys[i];
      var value;
      try {
        value = curry._1(decode, json[key]);
      }
      catch (raw_exn){
        var exn = caml_js_exceptions.internalToOCamlException(raw_exn);
        if (exn[0] === DecodeError) {
          throw [
                DecodeError,
                exn[1] + "\n\tin dict"
              ];
        }
        throw exn;
      }
      target[key] = value;
    }
    return target;
  } else {
    throw [
          DecodeError,
          "Expected object, got " + JSON.stringify(json)
        ];
  }
}

function field(key, decode, json) {
  if (typeof json === "object" && !Array.isArray(json) && json !== null) {
    var match = js_dict.get(json, key);
    if (match !== undefined) {
      try {
        return curry._1(decode, caml_option.valFromOption(match));
      }
      catch (raw_exn){
        var exn = caml_js_exceptions.internalToOCamlException(raw_exn);
        if (exn[0] === DecodeError) {
          throw [
                DecodeError,
                exn[1] + ("\n\tat field '" + (key + "'"))
              ];
        }
        throw exn;
      }
    } else {
      throw [
            DecodeError,
            "Expected field \'" + (String(key) + "\'")
          ];
    }
  } else {
    throw [
          DecodeError,
          "Expected object, got " + JSON.stringify(json)
        ];
  }
}

function at(key_path, decoder) {
  if (key_path) {
    var rest = key_path[1];
    var key = key_path[0];
    if (rest) {
      var partial_arg = at(rest, decoder);
      return (function (param) {
          return field(key, partial_arg, param);
        });
    } else {
      return (function (param) {
          return field(key, decoder, param);
        });
    }
  } else {
    throw [
          caml_builtin_exceptions.invalid_argument,
          "Expected key_path to contain at least one element"
        ];
  }
}

function optional(decode, json) {
  try {
    return caml_option.some(curry._1(decode, json));
  }
  catch (raw_exn){
    var exn = caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] === DecodeError) {
      return ;
    } else {
      throw exn;
    }
  }
}

function oneOf(decoders, json) {
  var _decoders = decoders;
  var _errors = /* [] */0;
  while(true) {
    var errors = _errors;
    var decoders$1 = _decoders;
    if (decoders$1) {
      try {
        return curry._1(decoders$1[0], json);
      }
      catch (raw_exn){
        var exn = caml_js_exceptions.internalToOCamlException(raw_exn);
        if (exn[0] === DecodeError) {
          _errors = /* :: */[
            exn[1],
            errors
          ];
          _decoders = decoders$1[1];
          continue ;
        } else {
          throw exn;
        }
      }
    } else {
      var revErrors = list.rev(errors);
      throw [
            DecodeError,
            "All decoders given to oneOf failed. Here are all the errors: " + (String(revErrors) + ". And the JSON being decoded: ") + JSON.stringify(json)
          ];
    }
  }}

function either(a, b) {
  var partial_arg_001 = /* :: */[
    b,
    /* [] */0
  ];
  var partial_arg = /* :: */[
    a,
    partial_arg_001
  ];
  return (function (param) {
      return oneOf(partial_arg, param);
    });
}

function withDefault($$default, decode, json) {
  try {
    return curry._1(decode, json);
  }
  catch (raw_exn){
    var exn = caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] === DecodeError) {
      return $$default;
    } else {
      throw exn;
    }
  }
}

function map$7(f, decode, json) {
  return curry._1(f, curry._1(decode, json));
}

function andThen(b, a, json) {
  return curry._2(b, curry._1(a, json), json);
}

var tuple2 = pair;

var DecodeError_1 = DecodeError;
var id_1 = id$1;
var bool_1$1 = bool$2;
var $$float_1$1 = $$float$2;
var $$int_1$1 = $$int$2;
var string_1$1 = string$2;
var $$char_1 = $$char;
var date_1 = date;
var nullable_1 = nullable;
var nullAs_1 = nullAs;
var array_1 = array$1;
var list_1 = list$1;
var pair_1 = pair;
var tuple2_1 = tuple2;
var tuple3_1 = tuple3;
var tuple4_1 = tuple4;
var dict_1 = dict;
var field_1 = field;
var at_1 = at;
var optional_1 = optional;
var oneOf_1 = oneOf;
var either_1 = either;
var withDefault_1 = withDefault;
var map_1$7 = map$7;
var andThen_1 = andThen;
/* No side effect */

var Json_decode_bs = {
	DecodeError: DecodeError_1,
	id: id_1,
	bool: bool_1$1,
	$$float: $$float_1$1,
	$$int: $$int_1$1,
	string: string_1$1,
	$$char: $$char_1,
	date: date_1,
	nullable: nullable_1,
	nullAs: nullAs_1,
	array: array_1,
	list: list_1,
	pair: pair_1,
	tuple2: tuple2_1,
	tuple3: tuple3_1,
	tuple4: tuple4_1,
	dict: dict_1,
	field: field_1,
	at: at_1,
	optional: optional_1,
	oneOf: oneOf_1,
	either: either_1,
	withDefault: withDefault_1,
	map: map_1$7,
	andThen: andThen_1
};

var printers = {
  contents: /* [] */0
};

var locfmt = /* Format */[
  /* String_literal */block.__(11, [
      "File \"",
      /* String */block.__(2, [
          /* No_padding */0,
          /* String_literal */block.__(11, [
              "\", line ",
              /* Int */block.__(4, [
                  /* Int_d */0,
                  /* No_padding */0,
                  /* No_precision */0,
                  /* String_literal */block.__(11, [
                      ", characters ",
                      /* Int */block.__(4, [
                          /* Int_d */0,
                          /* No_padding */0,
                          /* No_precision */0,
                          /* Char_literal */block.__(12, [
                              /* "-" */45,
                              /* Int */block.__(4, [
                                  /* Int_d */0,
                                  /* No_padding */0,
                                  /* No_precision */0,
                                  /* String_literal */block.__(11, [
                                      ": ",
                                      /* String */block.__(2, [
                                          /* No_padding */0,
                                          /* End_of_format */0
                                        ])
                                    ])
                                ])
                            ])
                        ])
                    ])
                ])
            ])
        ])
    ]),
  "File \"%s\", line %d, characters %d-%d: %s"
];

function field$1(x, i) {
  var f = x[i];
  if (typeof f === "number") {
    return curry._1(printf_1.sprintf(/* Format */[
                    /* Int */block.__(4, [
                        /* Int_d */0,
                        /* No_padding */0,
                        /* No_precision */0,
                        /* End_of_format */0
                      ]),
                    "%d"
                  ]), f);
  } else if ((f.tag | 0) === obj.string_tag) {
    return curry._1(printf_1.sprintf(/* Format */[
                    /* Caml_string */block.__(3, [
                        /* No_padding */0,
                        /* End_of_format */0
                      ]),
                    "%S"
                  ]), f);
  } else if ((f.tag | 0) === obj.double_tag) {
    return pervasives.string_of_float(f);
  } else {
    return "_";
  }
}

function other_fields(x, i) {
  if (i >= x.length) {
    return "";
  } else {
    return curry._2(printf_1.sprintf(/* Format */[
                    /* String_literal */block.__(11, [
                        ", ",
                        /* String */block.__(2, [
                            /* No_padding */0,
                            /* String */block.__(2, [
                                /* No_padding */0,
                                /* End_of_format */0
                              ])
                          ])
                      ]),
                    ", %s%s"
                  ]), field$1(x, i), other_fields(x, i + 1 | 0));
  }
}

function fields(x) {
  var match = x.length;
  switch (match) {
    case 0 :
    case 1 :
        return "";
    case 2 :
        return curry._1(printf_1.sprintf(/* Format */[
                        /* Char_literal */block.__(12, [
                            /* "(" */40,
                            /* String */block.__(2, [
                                /* No_padding */0,
                                /* Char_literal */block.__(12, [
                                    /* ")" */41,
                                    /* End_of_format */0
                                  ])
                              ])
                          ]),
                        "(%s)"
                      ]), field$1(x, 1));
    default:
      return curry._2(printf_1.sprintf(/* Format */[
                      /* Char_literal */block.__(12, [
                          /* "(" */40,
                          /* String */block.__(2, [
                              /* No_padding */0,
                              /* String */block.__(2, [
                                  /* No_padding */0,
                                  /* Char_literal */block.__(12, [
                                      /* ")" */41,
                                      /* End_of_format */0
                                    ])
                                ])
                            ])
                        ]),
                      "(%s%s)"
                    ]), field$1(x, 1), other_fields(x, 2));
  }
}

function to_string$3(x) {
  var _param = printers.contents;
  while(true) {
    var param = _param;
    if (param) {
      var match;
      try {
        match = curry._1(param[0], x);
      }
      catch (exn){
        match = undefined;
      }
      if (match !== undefined) {
        return match;
      } else {
        _param = param[1];
        continue ;
      }
    } else if (x === caml_builtin_exceptions.out_of_memory) {
      return "Out of memory";
    } else if (x === caml_builtin_exceptions.stack_overflow) {
      return "Stack overflow";
    } else if (x[0] === caml_builtin_exceptions.match_failure) {
      var match$1 = x[1];
      var $$char = match$1[2];
      return curry._5(printf_1.sprintf(locfmt), match$1[0], match$1[1], $$char, $$char + 5 | 0, "Pattern matching failed");
    } else if (x[0] === caml_builtin_exceptions.assert_failure) {
      var match$2 = x[1];
      var $$char$1 = match$2[2];
      return curry._5(printf_1.sprintf(locfmt), match$2[0], match$2[1], $$char$1, $$char$1 + 6 | 0, "Assertion failed");
    } else if (x[0] === caml_builtin_exceptions.undefined_recursive_module) {
      var match$3 = x[1];
      var $$char$2 = match$3[2];
      return curry._5(printf_1.sprintf(locfmt), match$3[0], match$3[1], $$char$2, $$char$2 + 6 | 0, "Undefined recursive module");
    } else if ((x.tag | 0) !== 0) {
      return x[0];
    } else {
      var constructor = x[0][0];
      return constructor + fields(x);
    }
  }}

function print(fct, arg) {
  try {
    return curry._1(fct, arg);
  }
  catch (raw_x){
    var x = caml_js_exceptions.internalToOCamlException(raw_x);
    curry._1(printf_1.eprintf(/* Format */[
              /* String_literal */block.__(11, [
                  "Uncaught exception: ",
                  /* String */block.__(2, [
                      /* No_padding */0,
                      /* Char_literal */block.__(12, [
                          /* "\n" */10,
                          /* End_of_format */0
                        ])
                    ])
                ]),
              "Uncaught exception: %s\n"
            ]), to_string$3(x));
    caml_io.caml_ml_flush(pervasives.stderr);
    throw x;
  }
}

function $$catch(fct, arg) {
  try {
    return curry._1(fct, arg);
  }
  catch (raw_x){
    var x = caml_js_exceptions.internalToOCamlException(raw_x);
    caml_io.caml_ml_flush(pervasives.stdout);
    curry._1(printf_1.eprintf(/* Format */[
              /* String_literal */block.__(11, [
                  "Uncaught exception: ",
                  /* String */block.__(2, [
                      /* No_padding */0,
                      /* Char_literal */block.__(12, [
                          /* "\n" */10,
                          /* End_of_format */0
                        ])
                    ])
                ]),
              "Uncaught exception: %s\n"
            ]), to_string$3(x));
    return pervasives.exit(2);
  }
}

function convert_raw_backtrace_slot(param) {
  throw [
        caml_builtin_exceptions.failure,
        "convert_raw_backtrace_slot not implemented"
      ];
}

function convert_raw_backtrace(bt) {
  try {
    return /* () */0;
  }
  catch (raw_exn){
    var exn = caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] === caml_builtin_exceptions.failure) {
      return ;
    } else {
      throw exn;
    }
  }
}

function format_backtrace_slot(pos, slot) {
  var info = function (is_raise) {
    if (is_raise) {
      if (pos === 0) {
        return "Raised at";
      } else {
        return "Re-raised at";
      }
    } else if (pos === 0) {
      return "Raised by primitive operation at";
    } else {
      return "Called from";
    }
  };
  if (slot.tag) {
    if (slot[/* is_raise */0]) {
      return ;
    } else {
      return curry._1(printf_1.sprintf(/* Format */[
                      /* String */block.__(2, [
                          /* No_padding */0,
                          /* String_literal */block.__(11, [
                              " unknown location",
                              /* End_of_format */0
                            ])
                        ]),
                      "%s unknown location"
                    ]), info(false));
    }
  } else {
    return curry._6(printf_1.sprintf(/* Format */[
                    /* String */block.__(2, [
                        /* No_padding */0,
                        /* String_literal */block.__(11, [
                            " file \"",
                            /* String */block.__(2, [
                                /* No_padding */0,
                                /* Char_literal */block.__(12, [
                                    /* "\"" */34,
                                    /* String */block.__(2, [
                                        /* No_padding */0,
                                        /* String_literal */block.__(11, [
                                            ", line ",
                                            /* Int */block.__(4, [
                                                /* Int_d */0,
                                                /* No_padding */0,
                                                /* No_precision */0,
                                                /* String_literal */block.__(11, [
                                                    ", characters ",
                                                    /* Int */block.__(4, [
                                                        /* Int_d */0,
                                                        /* No_padding */0,
                                                        /* No_precision */0,
                                                        /* Char_literal */block.__(12, [
                                                            /* "-" */45,
                                                            /* Int */block.__(4, [
                                                                /* Int_d */0,
                                                                /* No_padding */0,
                                                                /* No_precision */0,
                                                                /* End_of_format */0
                                                              ])
                                                          ])
                                                      ])
                                                  ])
                                              ])
                                          ])
                                      ])
                                  ])
                              ])
                          ])
                      ]),
                    "%s file \"%s\"%s, line %d, characters %d-%d"
                  ]), info(slot[/* is_raise */0]), slot[/* filename */1], slot[/* is_inline */5] ? " (inlined)" : "", slot[/* line_number */2], slot[/* start_char */3], slot[/* end_char */4]);
  }
}

function print_raw_backtrace(outchan, raw_backtrace) {
  var outchan$1 = outchan;
  var backtrace = convert_raw_backtrace();
  if (backtrace !== undefined) {
    var a = backtrace;
    for(var i = 0 ,i_finish = a.length - 1 | 0; i <= i_finish; ++i){
      var match = format_backtrace_slot(i, caml_array.caml_array_get(a, i));
      if (match !== undefined) {
        curry._1(printf_1.fprintf(outchan$1, /* Format */[
                  /* String */block.__(2, [
                      /* No_padding */0,
                      /* Char_literal */block.__(12, [
                          /* "\n" */10,
                          /* End_of_format */0
                        ])
                    ]),
                  "%s\n"
                ]), match);
      }
      
    }
    return /* () */0;
  } else {
    return printf_1.fprintf(outchan$1, /* Format */[
                /* String_literal */block.__(11, [
                    "(Program not linked with -g, cannot print stack backtrace)\n",
                    /* End_of_format */0
                  ]),
                "(Program not linked with -g, cannot print stack backtrace)\n"
              ]);
  }
}

function print_backtrace(outchan) {
  return print_raw_backtrace(outchan);
}

function raw_backtrace_to_string(raw_backtrace) {
  var backtrace = convert_raw_backtrace();
  if (backtrace !== undefined) {
    var a = backtrace;
    var b = buffer.create(1024);
    for(var i = 0 ,i_finish = a.length - 1 | 0; i <= i_finish; ++i){
      var match = format_backtrace_slot(i, caml_array.caml_array_get(a, i));
      if (match !== undefined) {
        curry._1(printf_1.bprintf(b, /* Format */[
                  /* String */block.__(2, [
                      /* No_padding */0,
                      /* Char_literal */block.__(12, [
                          /* "\n" */10,
                          /* End_of_format */0
                        ])
                    ]),
                  "%s\n"
                ]), match);
      }
      
    }
    return buffer.contents(b);
  } else {
    return "(Program not linked with -g, cannot print stack backtrace)\n";
  }
}

function backtrace_slot_is_raise(param) {
  return param[/* is_raise */0];
}

function backtrace_slot_is_inline(param) {
  if (param.tag) {
    return false;
  } else {
    return param[/* is_inline */5];
  }
}

function backtrace_slot_location(param) {
  if (param.tag) {
    return ;
  } else {
    return {
            filename: param[/* filename */1],
            line_number: param[/* line_number */2],
            start_char: param[/* start_char */3],
            end_char: param[/* end_char */4]
          };
  }
}

function backtrace_slots(raw_backtrace) {
  var match = convert_raw_backtrace();
  if (match !== undefined) {
    var backtrace = match;
    var usable_slot = function (param) {
      if (param.tag) {
        return false;
      } else {
        return true;
      }
    };
    var exists_usable = function (_i) {
      while(true) {
        var i = _i;
        if (i !== -1) {
          if (usable_slot(caml_array.caml_array_get(backtrace, i))) {
            return true;
          } else {
            _i = i - 1 | 0;
            continue ;
          }
        } else {
          return false;
        }
      }    };
    if (exists_usable(backtrace.length - 1 | 0)) {
      return backtrace;
    } else {
      return ;
    }
  }
  
}

function get_backtrace(param) {
  return raw_backtrace_to_string();
}

function register_printer(fn) {
  printers.contents = /* :: */[
    fn,
    printers.contents
  ];
  return /* () */0;
}

function exn_slot(x) {
  if (x.tag) {
    return x;
  } else {
    return x[0];
  }
}

function exn_slot_id(x) {
  var slot = exn_slot(x);
  return slot[1];
}

function exn_slot_name(x) {
  var slot = exn_slot(x);
  return slot[0];
}

function set_uncaught_exception_handler(fn) {
  return /* () */0;
}

function record_backtrace(prim) {
  return /* () */0;
}

function backtrace_status(prim) {
  return /* () */0;
}

function get_raw_backtrace(prim) {
  return /* () */0;
}

function get_callstack(prim) {
  return /* () */0;
}

var Slot = {
  is_raise: backtrace_slot_is_raise,
  is_inline: backtrace_slot_is_inline,
  $$location: backtrace_slot_location,
  format: format_backtrace_slot
};

function raw_backtrace_length(prim) {
  return caml_external_polyfill.resolve("caml_raw_backtrace_length")(prim);
}

function get_raw_backtrace_slot(prim, prim$1) {
  return caml_external_polyfill.resolve("caml_raw_backtrace_slot")(prim, prim$1);
}

function get_raw_backtrace_next_slot(prim) {
  return caml_external_polyfill.resolve("caml_raw_backtrace_next_slot")(prim);
}

var to_string_1$3 = to_string$3;
var print_1 = print;
var $$catch_1 = $$catch;
var print_backtrace_1 = print_backtrace;
var get_backtrace_1 = get_backtrace;
var record_backtrace_1 = record_backtrace;
var backtrace_status_1 = backtrace_status;
var register_printer_1 = register_printer;
var get_raw_backtrace_1 = get_raw_backtrace;
var print_raw_backtrace_1 = print_raw_backtrace;
var raw_backtrace_to_string_1 = raw_backtrace_to_string;
var get_callstack_1 = get_callstack;
var set_uncaught_exception_handler_1 = set_uncaught_exception_handler;
var backtrace_slots_1 = backtrace_slots;
var Slot_1 = Slot;
var raw_backtrace_length_1 = raw_backtrace_length;
var get_raw_backtrace_slot_1 = get_raw_backtrace_slot;
var convert_raw_backtrace_slot_1 = convert_raw_backtrace_slot;
var get_raw_backtrace_next_slot_1 = get_raw_backtrace_next_slot;
var exn_slot_id_1 = exn_slot_id;
var exn_slot_name_1 = exn_slot_name;
/* No side effect */

var printexc = {
	to_string: to_string_1$3,
	print: print_1,
	$$catch: $$catch_1,
	print_backtrace: print_backtrace_1,
	get_backtrace: get_backtrace_1,
	record_backtrace: record_backtrace_1,
	backtrace_status: backtrace_status_1,
	register_printer: register_printer_1,
	get_raw_backtrace: get_raw_backtrace_1,
	print_raw_backtrace: print_raw_backtrace_1,
	raw_backtrace_to_string: raw_backtrace_to_string_1,
	get_callstack: get_callstack_1,
	set_uncaught_exception_handler: set_uncaught_exception_handler_1,
	backtrace_slots: backtrace_slots_1,
	Slot: Slot_1,
	raw_backtrace_length: raw_backtrace_length_1,
	get_raw_backtrace_slot: get_raw_backtrace_slot_1,
	convert_raw_backtrace_slot: convert_raw_backtrace_slot_1,
	get_raw_backtrace_next_slot: get_raw_backtrace_next_slot_1,
	exn_slot_id: exn_slot_id_1,
	exn_slot_name: exn_slot_name_1
};

function ofString$1(x) {
  return x;
}

function validate(x) {
  var match = caml_string.get(x, 0) === /* "/" */47;
  var start = match ? 1 : 0;
  var len = x.length;
  var match$1 = caml_string.get(x, len - 1 | 0) === /* "/" */47;
  var end_ = match$1 ? len - 1 | 0 : len;
  return x.substring(start, end_);
}

function toString$1(x) {
  return x;
}

var ProjectName = {
  ofString: ofString$1,
  validate: validate,
  toString: toString$1
};

function toString$1$1(param) {
  if (typeof param === "number") {
    return "Unexpected array value in Azure response";
  } else if (param.tag) {
    return " Response from Azure did not contain build " + (String(param[0]) + " ");
  } else {
    return "Field " + (String(param[0]) + " in Azure\'s response was undefined");
  }
}

var E$1 = {
  toString: toString$1$1
};

function guard(jsonParser, str) {
  try {
    return curry._1(jsonParser, str);
  }
  catch (raw_e){
    var e = caml_js_exceptions.internalToOCamlException(raw_e);
    var msg = printexc.to_string(e);
    return /* Error */caml_chrome_debugger.variant("Error", 1, ["Failed to parse Azure response\n" + (String(msg) + ("\n" + (String(str) + "\n")))]);
  }
}

function getBuildId$prime(json) {
  var buildIdObject = function (json) {
    return {
            id: Json_decode_bs.field("id", Json_decode_bs.$$int, json)
          };
  };
  var valueArray = Json_decode_bs.field("value", (function (param) {
          return Json_decode_bs.array(buildIdObject, param);
        }), json);
  return caml_array.caml_array_get(valueArray, 0).id;
}

function getBuildId(param) {
  return guard((function (responseText) {
                var match = Json_bs.parse(responseText);
                if (match !== undefined) {
                  return /* Ok */caml_chrome_debugger.variant("Ok", 0, [getBuildId$prime(caml_option.valFromOption(match))]);
                } else {
                  return /* Error */caml_chrome_debugger.variant("Error", 1, ["getBuildId(): responseText could not be parsed"]);
                }
              }), param);
}

function getDownloadURL$prime(json) {
  var downloadUrlObject = function (json) {
    return {
            downloadUrl: Json_decode_bs.field("downloadUrl", Json_decode_bs.string, json)
          };
  };
  var match = Json_decode_bs.optional((function (param) {
          return Json_decode_bs.field("resource", downloadUrlObject, param);
        }), json);
  if (match !== undefined) {
    return /* Ok */caml_chrome_debugger.variant("Ok", 0, [match.downloadUrl]);
  } else {
    return /* Error */caml_chrome_debugger.variant("Error", 1, ["getDownloadURL(): responseObject.resource as not of the form { downloadURL: \"...\" }. Instead got\n$responseText "]);
  }
}

function getDownloadURL(param) {
  return guard((function (responseText) {
                var match = Json_bs.parse(responseText);
                if (match !== undefined) {
                  return getDownloadURL$prime(caml_option.valFromOption(match));
                } else {
                  return /* Error */caml_chrome_debugger.variant("Error", 1, ["getDownloadURL(): could not parse responseText"]);
                }
              }), param);
}

var RESTResponse = {
  guard: guard,
  getBuildId$prime: getBuildId$prime,
  getBuildId: getBuildId,
  getDownloadURL$prime: getDownloadURL$prime,
  getDownloadURL: getDownloadURL
};

var match$2 = process.platform;

var os;

switch (match$2) {
  case "darwin" :
      os = "Darwin";
      break;
  case "linux" :
      os = "Linux";
      break;
  case "win32" :
      os = "Windows";
      break;
  default:
    os = undefined;
}

var artifactName = os !== undefined ? "cache-" + (String(os) + "-install-v1") : undefined;

var master = "branchName=refs%2Fheads%2Fmaster";

var filter$2 = "deletedFilter=excludeDeleted&statusFilter=completed&resultFilter=succeeded";

var latest = "queryOrder=finishTimeDescending&$top=1";

var restBase = "https://dev.azure.com";

function getBuildID(projName) {
  return Bindings_bs.Https.getCompleteResponse("" + (String(restBase) + ("/" + (String(projName) + ("/_apis/build/builds?" + (String(filter$2) + ("&" + (String(master) + ("&" + (String(latest) + "&api-version=4.1")))))))))).then((function (r) {
                var tmp;
                tmp = r.tag ? /* Error */caml_chrome_debugger.variant("Error", 1, [" Could not download " + (String(r[0][0]) + " ")]) : getBuildId(r[0]);
                return Promise.resolve(tmp);
              }));
}

function getDownloadURL$1(projName, latestBuildID) {
  var latestBuildID$1 = latestBuildID.toString();
  if (artifactName !== undefined) {
    return Bindings_bs.Https.getCompleteResponse("" + (String(restBase) + ("/" + (String(projName) + ("/_apis/build/builds/" + (String(latestBuildID$1) + ("/artifacts?artifactname=" + (String(artifactName) + "&api-version=4.1")))))))).then((function (param) {
                  if (param.tag) {
                    return Promise.resolve(/* Error */caml_chrome_debugger.variant("Error", 1, [" Failed to download " + (String(param[0][0]) + " ")]));
                  } else {
                    return Promise.resolve(getDownloadURL(param[0]));
                  }
                }));
  } else {
    return Promise.resolve(/* Error */caml_chrome_debugger.variant("Error", 1, ["We detected a platform for which we couldn't find cached builds"]));
  }
}

var P = /* alias */0;

var P_1 = P;
var ProjectName_1 = ProjectName;
var E_1 = E$1;
var RESTResponse_1 = RESTResponse;
var os_1 = os;
var artifactName_1 = artifactName;
var master_1 = master;
var filter_1$1 = filter$2;
var latest_1 = latest;
var restBase_1 = restBase;
var getBuildID_1 = getBuildID;
var getDownloadURL_1 = getDownloadURL$1;
/* match Not a pure module */

var AzurePipelines_bs = {
	P: P_1,
	ProjectName: ProjectName_1,
	E: E_1,
	RESTResponse: RESTResponse_1,
	os: os_1,
	artifactName: artifactName_1,
	master: master_1,
	filter: filter_1$1,
	latest: latest_1,
	restBase: restBase_1,
	getBuildID: getBuildID_1,
	getDownloadURL: getDownloadURL_1
};

function decoder(json) {
  return {
          azureProject: Json_decode_bs.field("azure-project", Json_decode_bs.string, json)
        };
}

function make$5(manifest) {
  var match = Json_bs.parse(manifest);
  if (match !== undefined) {
    try {
      return Utils_bs.Result.$$return(Json_decode_bs.field("pesy", decoder, caml_option.valFromOption(match)));
    }
    catch (raw_exn){
      var exn = caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn[0] === Json_decode_bs.DecodeError) {
        return /* Error */caml_chrome_debugger.variant("Error", 1, [exn[1]]);
      } else {
        throw exn;
      }
    }
  } else {
    return /* Error */caml_chrome_debugger.variant("Error", 1, ["Json parser failed: " + manifest]);
  }
}

function getAzureProject(config) {
  return config.azureProject;
}

var PesyConfig = {
  decoder: decoder,
  getAzureProject: getAzureProject,
  make: make$5
};

function prepareAzureCacheURL(projStr) {
  var proj = AzurePipelines_bs.ProjectName.validate(AzurePipelines_bs.ProjectName.ofString(projStr));
  return AzurePipelines_bs.getBuildID(proj).then((function (param) {
                if (param.tag) {
                  return Promise.resolve(/* Error */caml_chrome_debugger.variant("Error", 1, [param[0]]));
                } else {
                  return AzurePipelines_bs.getDownloadURL(proj, param[0]);
                }
              }));
}

function make$1$1(statusOutput) {
  var match = Json_bs.parse(statusOutput);
  if (match !== undefined) {
    try {
      return Utils_bs.Result.$$return({
                  rootPackageConfigPath: Json_decode_bs.field("rootPackageConfigPath", Json_decode_bs.string, caml_option.valFromOption(match))
                });
    }
    catch (raw_exn){
      var exn = caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn[0] === Json_decode_bs.DecodeError) {
        return /* Error */caml_chrome_debugger.variant("Error", 1, [exn[1]]);
      } else {
        throw exn;
      }
    }
  } else {
    return /* Error */caml_chrome_debugger.variant("Error", 1, [" Json parser failed\n" + (String(statusOutput) + " ")]);
  }
}

function getRootPackageConfigPath(config) {
  return config.rootPackageConfigPath;
}

var EsyStatus = {
  make: make$1$1,
  getRootPackageConfigPath: getRootPackageConfigPath
};

function make$2$1(param) {
  return Cmd_bs.make(process.env, "esy");
}

function manifestPath(path, cmd) {
  return Utils_bs.ResultPromise.$great$great$eq(Cmd_bs.output(/* array */["status"], path, cmd), (function (param) {
                return Promise.resolve(curry._2(Utils_bs.Result.$great$great$pipe, make$1$1(param[0]), (function (status) {
                                  return status.rootPackageConfigPath;
                                })));
              }));
}

function importDependencies(path, cmd) {
  return Cmd_bs.output(/* array */["import-dependencies"], path, cmd);
}

var Esy = {
  make: make$2$1,
  manifestPath: manifestPath,
  importDependencies: importDependencies
};

function download(url, file, progress, end_, error) {
  var stream = requestProgress(request(url));
  Bindings_bs.RequestProgress.onProgress(stream, (function (state) {
          return curry._1(progress, state.size.transferred);
        }));
  Bindings_bs.RequestProgress.onEnd(stream, end_);
  Bindings_bs.RequestProgress.onError(stream, error);
  stream.pipe(fs.createWriteStream(file));
  return /* () */0;
}

function divideBy(n, x) {
  return x / n;
}

function toHumanReadableBytes(x) {
  if (x > 1073741824) {
    return curry._1(printf_1.sprintf(/* Format */caml_chrome_debugger.simpleVariant("Format", [
                      /* Float */caml_chrome_debugger.variant("Float", 8, [
                          /* Float_f */0,
                          /* No_padding */0,
                          /* Lit_precision */caml_chrome_debugger.simpleVariant("Lit_precision", [2]),
                          /* String_literal */caml_chrome_debugger.variant("String_literal", 11, [
                              " GB  ",
                              /* End_of_format */0
                            ])
                        ]),
                      "%.2f GB  "
                    ])), divideBy(1073741824, x));
  } else if (x > 1048576) {
    return curry._1(printf_1.sprintf(/* Format */caml_chrome_debugger.simpleVariant("Format", [
                      /* Float */caml_chrome_debugger.variant("Float", 8, [
                          /* Float_f */0,
                          /* No_padding */0,
                          /* Lit_precision */caml_chrome_debugger.simpleVariant("Lit_precision", [2]),
                          /* String_literal */caml_chrome_debugger.variant("String_literal", 11, [
                              " MB  ",
                              /* End_of_format */0
                            ])
                        ]),
                      "%.2f MB  "
                    ])), divideBy(1048576, x));
  } else if (x > 1024) {
    return curry._1(printf_1.sprintf(/* Format */caml_chrome_debugger.simpleVariant("Format", [
                      /* Float */caml_chrome_debugger.variant("Float", 8, [
                          /* Float_f */0,
                          /* No_padding */0,
                          /* Lit_precision */caml_chrome_debugger.simpleVariant("Lit_precision", [2]),
                          /* String_literal */caml_chrome_debugger.variant("String_literal", 11, [
                              " KB  ",
                              /* End_of_format */0
                            ])
                        ]),
                      "%.2f KB  "
                    ])), divideBy(1024, x));
  } else {
    return String(x) + " bytes";
  }
}

function run$1(projectPath) {
  return Utils_bs.ResultPromise.$great$great$eq(Cmd_bs.make(process.env, "esy"), (function (esy) {
                return Utils_bs.ResultPromise.$great$great$eq(manifestPath(projectPath, esy), (function (rootPackageConfigPath) {
                              return Bindings_bs.Fs.readFile(rootPackageConfigPath).then((function (manifestBytes) {
                                            var match = make$5(manifestBytes.toString());
                                            if (match.tag) {
                                              return Promise.resolve(/* Error */caml_chrome_debugger.variant("Error", 1, [match[0]]));
                                            } else {
                                              var azureProject = match[0].azureProject;
                                              console.log(chalk.dim("Fetching prebuilts for azure project"), chalk.whiteBright(azureProject));
                                              return Utils_bs.ResultPromise.$great$great$eq(Utils_bs.ResultPromise.$great$great$eq(Utils_bs.ResultPromise.$great$great$eq(Utils_bs.ResultPromise.$great$great$eq(Utils_bs.ResultPromise.$great$great$eq(prepareAzureCacheURL(azureProject), (function (downloadUrl) {
                                                                            return new Promise((function (resolve, param) {
                                                                                          return download(downloadUrl, "cache.zip", (function (bytes) {
                                                                                                        var x = toHumanReadableBytes(bytes);
                                                                                                        process.stdout.write("Downloading " + (chalk.green(x) + "\r"));
                                                                                                        return /* () */0;
                                                                                                      }), (function (param) {
                                                                                                        console.log(chalk.green("Downloaded. ") + chalk.whiteBright("Hydrating esy cache..."));
                                                                                                        return resolve(/* Ok */caml_chrome_debugger.variant("Ok", 0, [/* () */0]));
                                                                                                      }), (function (error) {
                                                                                                        console.log(error);
                                                                                                        return resolve(/* Error */caml_chrome_debugger.variant("Error", 1, ["Download failed"]));
                                                                                                      }));
                                                                                        }));
                                                                          })), (function (param) {
                                                                        return Utils_bs.ResultPromise.$great$great$eq(Cmd_bs.make(process.env, "unzip"), (function (cmd) {
                                                                                      return Utils_bs.ResultPromise.$great$great$pipe(Cmd_bs.output(/* array */[
                                                                                                      "-o",
                                                                                                      "cache.zip"
                                                                                                    ], projectPath, cmd), (function (param) {
                                                                                                    return /* () */0;
                                                                                                  }));
                                                                                    }));
                                                                      })), (function (_stdout) {
                                                                    return importDependencies(curry._2(Utils_bs.Path.$slash, projectPath, "cache-Darwin-install-v1"), esy);
                                                                  })), (function (param) {
                                                                console.log(chalk.whiteBright("Running ") + chalk.bold("esy import-dependencies"));
                                                                process.stdout.write(chalk.dim(param[0]));
                                                                process.stdout.write(chalk.dim(param[1]));
                                                                return Bindings_bs.Rimraf.run(curry._2(Utils_bs.Path.$slash, projectPath, "cache.zip"));
                                                              })), (function (param) {
                                                            return Bindings_bs.Rimraf.run(curry._2(Utils_bs.Path.$slash, projectPath, "cache-Darwin-install-v1"));
                                                          }));
                                            }
                                          }));
                            }));
              }));
}

var R = /* alias */0;

var giga = 1073741824;

var mega = 1048576;

var kilo = 1024;

var R_1 = R;
var PesyConfig_1 = PesyConfig;
var prepareAzureCacheURL_1 = prepareAzureCacheURL;
var EsyStatus_1 = EsyStatus;
var Esy_1 = Esy;
var download_1 = download;
var giga_1 = giga;
var mega_1 = mega;
var kilo_1 = kilo;
var divideBy_1 = divideBy;
var toHumanReadableBytes_1 = toHumanReadableBytes;
var run_1 = run$1;
/* fs Not a pure module */

var Warmup_bs = {
	R: R_1,
	PesyConfig: PesyConfig_1,
	prepareAzureCacheURL: prepareAzureCacheURL_1,
	EsyStatus: EsyStatus_1,
	Esy: Esy_1,
	download: download_1,
	giga: giga_1,
	mega: mega_1,
	kilo: kilo_1,
	divideBy: divideBy_1,
	toHumanReadableBytes: toHumanReadableBytes_1,
	run: run_1
};

function add_queue(x, q) {
  var c = /* Cons */[
    /* head */x,
    /* tail : Nil */0
  ];
  var match = q.insert;
  if (match) {
    q.insert = c;
    match[/* tail */1] = c;
    return /* () */0;
  } else {
    q.insert = c;
    q.body = c;
    return /* () */0;
  }
}

var Empty_queue = caml_exceptions.create("Format.Empty_queue");

function peek_queue(param) {
  var match = param.body;
  if (match) {
    return match[/* head */0];
  } else {
    throw Empty_queue;
  }
}

function take_queue(q) {
  var match = q.body;
  if (match) {
    var tl = match[/* tail */1];
    q.body = tl;
    if (tl === /* Nil */0) {
      q.insert = /* Nil */0;
    }
    return match[/* head */0];
  } else {
    throw Empty_queue;
  }
}

function pp_enqueue(state, token) {
  state.pp_right_total = state.pp_right_total + token.length | 0;
  return add_queue(token, state.pp_queue);
}

function pp_clear_queue(state) {
  state.pp_left_total = 1;
  state.pp_right_total = 1;
  var q = state.pp_queue;
  q.insert = /* Nil */0;
  q.body = /* Nil */0;
  return /* () */0;
}

function pp_output_string(state, s) {
  return curry._3(state.pp_out_string, s, 0, s.length);
}

function break_new_line(state, offset, width) {
  curry._1(state.pp_out_newline, /* () */0);
  state.pp_is_new_line = true;
  var indent = (state.pp_margin - width | 0) + offset | 0;
  var real_indent = state.pp_max_indent < indent ? state.pp_max_indent : indent;
  state.pp_current_indent = real_indent;
  state.pp_space_left = state.pp_margin - state.pp_current_indent | 0;
  return curry._1(state.pp_out_indent, state.pp_current_indent);
}

function break_same_line(state, width) {
  state.pp_space_left = state.pp_space_left - width | 0;
  return curry._1(state.pp_out_spaces, width);
}

function pp_force_break_line(state) {
  var match = state.pp_format_stack;
  if (match) {
    var match$1 = match[0];
    var width = match$1[1];
    if (width > state.pp_space_left && (match$1[0] - 1 >>> 0) <= 3) {
      return break_new_line(state, 0, width);
    } else {
      return 0;
    }
  } else {
    return curry._1(state.pp_out_newline, /* () */0);
  }
}

function format_pp_token(state, size, param) {
  if (typeof param === "number") {
    switch (param) {
      case /* Pp_stab */0 :
          var match = state.pp_tbox_stack;
          if (match) {
            var tabs = match[0][0];
            var add_tab = function (n, ls) {
              if (ls) {
                var x = ls[0];
                if (caml_obj.caml_lessthan(n, x)) {
                  return /* :: */[
                          n,
                          ls
                        ];
                } else {
                  return /* :: */[
                          x,
                          add_tab(n, ls[1])
                        ];
                }
              } else {
                return /* :: */[
                        n,
                        /* [] */0
                      ];
              }
            };
            tabs.contents = add_tab(state.pp_margin - state.pp_space_left | 0, tabs.contents);
            return /* () */0;
          } else {
            return /* () */0;
          }
      case /* Pp_end */1 :
          var match$1 = state.pp_format_stack;
          if (match$1) {
            state.pp_format_stack = match$1[1];
            return /* () */0;
          } else {
            return /* () */0;
          }
      case /* Pp_tend */2 :
          var match$2 = state.pp_tbox_stack;
          if (match$2) {
            state.pp_tbox_stack = match$2[1];
            return /* () */0;
          } else {
            return /* () */0;
          }
      case /* Pp_newline */3 :
          var match$3 = state.pp_format_stack;
          if (match$3) {
            return break_new_line(state, 0, match$3[0][1]);
          } else {
            return curry._1(state.pp_out_newline, /* () */0);
          }
      case /* Pp_if_newline */4 :
          if (state.pp_current_indent !== (state.pp_margin - state.pp_space_left | 0)) {
            var state$1 = state;
            var match$4 = take_queue(state$1.pp_queue);
            var size$1 = match$4.elem_size;
            state$1.pp_left_total = state$1.pp_left_total - match$4.length | 0;
            state$1.pp_space_left = state$1.pp_space_left + size$1 | 0;
            return /* () */0;
          } else {
            return 0;
          }
      case /* Pp_close_tag */5 :
          var match$5 = state.pp_mark_stack;
          if (match$5) {
            var marker = curry._1(state.pp_mark_close_tag, match$5[0]);
            pp_output_string(state, marker);
            state.pp_mark_stack = match$5[1];
            return /* () */0;
          } else {
            return /* () */0;
          }
      
    }
  } else {
    switch (param.tag | 0) {
      case /* Pp_text */0 :
          state.pp_space_left = state.pp_space_left - size | 0;
          pp_output_string(state, param[0]);
          state.pp_is_new_line = false;
          return /* () */0;
      case /* Pp_break */1 :
          var off = param[1];
          var n = param[0];
          var match$6 = state.pp_format_stack;
          if (match$6) {
            var match$7 = match$6[0];
            var width = match$7[1];
            switch (match$7[0]) {
              case /* Pp_vbox */1 :
              case /* Pp_hvbox */2 :
                  return break_new_line(state, off, width);
              case /* Pp_hovbox */3 :
                  if (size > state.pp_space_left) {
                    return break_new_line(state, off, width);
                  } else {
                    return break_same_line(state, n);
                  }
              case /* Pp_box */4 :
                  if (state.pp_is_new_line || !(size > state.pp_space_left || state.pp_current_indent > ((state.pp_margin - width | 0) + off | 0))) {
                    return break_same_line(state, n);
                  } else {
                    return break_new_line(state, off, width);
                  }
              case /* Pp_hbox */0 :
              case /* Pp_fits */5 :
                  return break_same_line(state, n);
              
            }
          } else {
            return /* () */0;
          }
      case /* Pp_tbreak */2 :
          var insertion_point = state.pp_margin - state.pp_space_left | 0;
          var match$8 = state.pp_tbox_stack;
          if (match$8) {
            var tabs$1 = match$8[0][0];
            var find = function (n, _param) {
              while(true) {
                var param = _param;
                if (param) {
                  var x = param[0];
                  if (caml_obj.caml_greaterequal(x, n)) {
                    return x;
                  } else {
                    _param = param[1];
                    continue ;
                  }
                } else {
                  throw caml_builtin_exceptions.not_found;
                }
              }            };
            var match$9 = tabs$1.contents;
            var tab;
            if (match$9) {
              try {
                tab = find(insertion_point, tabs$1.contents);
              }
              catch (exn){
                if (exn === caml_builtin_exceptions.not_found) {
                  tab = match$9[0];
                } else {
                  throw exn;
                }
              }
            } else {
              tab = insertion_point;
            }
            var offset = tab - insertion_point | 0;
            if (offset >= 0) {
              return break_same_line(state, offset + param[0] | 0);
            } else {
              return break_new_line(state, tab + param[1] | 0, state.pp_margin);
            }
          } else {
            return /* () */0;
          }
      case /* Pp_begin */3 :
          var ty = param[1];
          var insertion_point$1 = state.pp_margin - state.pp_space_left | 0;
          if (insertion_point$1 > state.pp_max_indent) {
            pp_force_break_line(state);
          }
          var offset$1 = state.pp_space_left - param[0] | 0;
          var bl_type = ty !== 1 ? (
              size > state.pp_space_left ? ty : /* Pp_fits */5
            ) : /* Pp_vbox */1;
          state.pp_format_stack = /* :: */[
            /* Format_elem */[
              bl_type,
              offset$1
            ],
            state.pp_format_stack
          ];
          return /* () */0;
      case /* Pp_tbegin */4 :
          state.pp_tbox_stack = /* :: */[
            param[0],
            state.pp_tbox_stack
          ];
          return /* () */0;
      case /* Pp_open_tag */5 :
          var tag_name = param[0];
          var marker$1 = curry._1(state.pp_mark_open_tag, tag_name);
          pp_output_string(state, marker$1);
          state.pp_mark_stack = /* :: */[
            tag_name,
            state.pp_mark_stack
          ];
          return /* () */0;
      
    }
  }
}

function advance_left(state) {
  try {
    var state$1 = state;
    while(true) {
      var match = peek_queue(state$1.pp_queue);
      var size = match.elem_size;
      if (size < 0 && (state$1.pp_right_total - state$1.pp_left_total | 0) < state$1.pp_space_left) {
        return 0;
      } else {
        take_queue(state$1.pp_queue);
        format_pp_token(state$1, size < 0 ? 1000000010 : size, match.token);
        state$1.pp_left_total = match.length + state$1.pp_left_total | 0;
        continue ;
      }
    };
  }
  catch (exn){
    if (exn === Empty_queue) {
      return /* () */0;
    } else {
      throw exn;
    }
  }
}

function enqueue_advance(state, tok) {
  pp_enqueue(state, tok);
  return advance_left(state);
}

function enqueue_string_as(state, size, s) {
  return enqueue_advance(state, {
              elem_size: size,
              token: /* Pp_text */block.__(0, [s]),
              length: size
            });
}

var q_elem = {
  elem_size: -1,
  token: /* Pp_text */block.__(0, [""]),
  length: 0
};

var scan_stack_bottom_000 = /* Scan_elem */[
  -1,
  q_elem
];

var scan_stack_bottom = /* :: */[
  scan_stack_bottom_000,
  /* [] */0
];

function set_size(state, ty) {
  var match = state.pp_scan_stack;
  if (match) {
    var match$1 = match[0];
    var queue_elem = match$1[1];
    var size = queue_elem.elem_size;
    var t = match[1];
    if (match$1[0] < state.pp_left_total) {
      state.pp_scan_stack = scan_stack_bottom;
      return /* () */0;
    } else {
      var tmp = queue_elem.token;
      if (typeof tmp === "number") {
        return /* () */0;
      } else {
        switch (tmp.tag | 0) {
          case /* Pp_break */1 :
          case /* Pp_tbreak */2 :
              break;
          case /* Pp_begin */3 :
              if (ty) {
                return 0;
              } else {
                queue_elem.elem_size = state.pp_right_total + size | 0;
                state.pp_scan_stack = t;
                return /* () */0;
              }
          default:
            return /* () */0;
        }
      }
      if (ty) {
        queue_elem.elem_size = state.pp_right_total + size | 0;
        state.pp_scan_stack = t;
        return /* () */0;
      } else {
        return 0;
      }
    }
  } else {
    return /* () */0;
  }
}

function scan_push(state, b, tok) {
  pp_enqueue(state, tok);
  if (b) {
    set_size(state, true);
  }
  state.pp_scan_stack = /* :: */[
    /* Scan_elem */[
      state.pp_right_total,
      tok
    ],
    state.pp_scan_stack
  ];
  return /* () */0;
}

function pp_open_box_gen(state, indent, br_ty) {
  state.pp_curr_depth = state.pp_curr_depth + 1 | 0;
  if (state.pp_curr_depth < state.pp_max_boxes) {
    var elem = {
      elem_size: -state.pp_right_total | 0,
      token: /* Pp_begin */block.__(3, [
          indent,
          br_ty
        ]),
      length: 0
    };
    return scan_push(state, false, elem);
  } else if (state.pp_curr_depth === state.pp_max_boxes) {
    var state$1 = state;
    var s = state.pp_ellipsis;
    var len = s.length;
    return enqueue_string_as(state$1, len, s);
  } else {
    return 0;
  }
}

function pp_close_box(state, param) {
  if (state.pp_curr_depth > 1) {
    if (state.pp_curr_depth < state.pp_max_boxes) {
      pp_enqueue(state, {
            elem_size: 0,
            token: /* Pp_end */1,
            length: 0
          });
      set_size(state, true);
      set_size(state, false);
    }
    state.pp_curr_depth = state.pp_curr_depth - 1 | 0;
    return /* () */0;
  } else {
    return 0;
  }
}

function pp_open_tag(state, tag_name) {
  if (state.pp_print_tags) {
    state.pp_tag_stack = /* :: */[
      tag_name,
      state.pp_tag_stack
    ];
    curry._1(state.pp_print_open_tag, tag_name);
  }
  if (state.pp_mark_tags) {
    return pp_enqueue(state, {
                elem_size: 0,
                token: /* Pp_open_tag */block.__(5, [tag_name]),
                length: 0
              });
  } else {
    return 0;
  }
}

function pp_close_tag(state, param) {
  if (state.pp_mark_tags) {
    pp_enqueue(state, {
          elem_size: 0,
          token: /* Pp_close_tag */5,
          length: 0
        });
  }
  if (state.pp_print_tags) {
    var match = state.pp_tag_stack;
    if (match) {
      curry._1(state.pp_print_close_tag, match[0]);
      state.pp_tag_stack = match[1];
      return /* () */0;
    } else {
      return /* () */0;
    }
  } else {
    return 0;
  }
}

function pp_set_print_tags(state, b) {
  state.pp_print_tags = b;
  return /* () */0;
}

function pp_set_mark_tags(state, b) {
  state.pp_mark_tags = b;
  return /* () */0;
}

function pp_get_print_tags(state, param) {
  return state.pp_print_tags;
}

function pp_get_mark_tags(state, param) {
  return state.pp_mark_tags;
}

function pp_set_tags(state, b) {
  state.pp_print_tags = b;
  state.pp_mark_tags = b;
  return /* () */0;
}

function pp_get_formatter_tag_functions(state, param) {
  return {
          mark_open_tag: state.pp_mark_open_tag,
          mark_close_tag: state.pp_mark_close_tag,
          print_open_tag: state.pp_print_open_tag,
          print_close_tag: state.pp_print_close_tag
        };
}

function pp_set_formatter_tag_functions(state, param) {
  state.pp_mark_open_tag = param.mark_open_tag;
  state.pp_mark_close_tag = param.mark_close_tag;
  state.pp_print_open_tag = param.print_open_tag;
  state.pp_print_close_tag = param.print_close_tag;
  return /* () */0;
}

function pp_rinit(state) {
  pp_clear_queue(state);
  state.pp_scan_stack = scan_stack_bottom;
  state.pp_format_stack = /* [] */0;
  state.pp_tbox_stack = /* [] */0;
  state.pp_tag_stack = /* [] */0;
  state.pp_mark_stack = /* [] */0;
  state.pp_current_indent = 0;
  state.pp_curr_depth = 0;
  state.pp_space_left = state.pp_margin;
  return pp_open_box_gen(state, 0, /* Pp_hovbox */3);
}

function clear_tag_stack(state) {
  return list.iter((function (param) {
                return pp_close_tag(state);
              }), state.pp_tag_stack);
}

function pp_flush_queue(state, b) {
  clear_tag_stack(state);
  while(state.pp_curr_depth > 1) {
    pp_close_box(state);
  }  state.pp_right_total = 1000000010;
  advance_left(state);
  if (b) {
    curry._1(state.pp_out_newline, /* () */0);
  }
  return pp_rinit(state);
}

function pp_print_as_size(state, size, s) {
  if (state.pp_curr_depth < state.pp_max_boxes) {
    return enqueue_string_as(state, size, s);
  } else {
    return 0;
  }
}

var pp_print_as = pp_print_as_size;

function pp_print_string(state, s) {
  return pp_print_as(state, s.length, s);
}

function pp_print_int(state, i) {
  return pp_print_string(state, String(i));
}

function pp_print_float(state, f) {
  return pp_print_string(state, pervasives.string_of_float(f));
}

function pp_print_bool(state, b) {
  return pp_print_string(state, b ? "true" : "false");
}

function pp_print_char(state, c) {
  return pp_print_as(state, 1, caml_bytes.bytes_to_string(bytes.make(1, c)));
}

function pp_open_hbox(state, param) {
  return pp_open_box_gen(state, 0, /* Pp_hbox */0);
}

function pp_open_vbox(state, indent) {
  return pp_open_box_gen(state, indent, /* Pp_vbox */1);
}

function pp_open_hvbox(state, indent) {
  return pp_open_box_gen(state, indent, /* Pp_hvbox */2);
}

function pp_open_hovbox(state, indent) {
  return pp_open_box_gen(state, indent, /* Pp_hovbox */3);
}

function pp_open_box(state, indent) {
  return pp_open_box_gen(state, indent, /* Pp_box */4);
}

function pp_print_newline(state, param) {
  pp_flush_queue(state, true);
  return curry._1(state.pp_out_flush, /* () */0);
}

function pp_print_flush(state, param) {
  pp_flush_queue(state, false);
  return curry._1(state.pp_out_flush, /* () */0);
}

function pp_force_newline(state, param) {
  if (state.pp_curr_depth < state.pp_max_boxes) {
    return enqueue_advance(state, {
                elem_size: 0,
                token: /* Pp_newline */3,
                length: 0
              });
  } else {
    return 0;
  }
}

function pp_print_if_newline(state, param) {
  if (state.pp_curr_depth < state.pp_max_boxes) {
    return enqueue_advance(state, {
                elem_size: 0,
                token: /* Pp_if_newline */4,
                length: 0
              });
  } else {
    return 0;
  }
}

function pp_print_break(state, width, offset) {
  if (state.pp_curr_depth < state.pp_max_boxes) {
    var elem = {
      elem_size: -state.pp_right_total | 0,
      token: /* Pp_break */block.__(1, [
          width,
          offset
        ]),
      length: width
    };
    return scan_push(state, true, elem);
  } else {
    return 0;
  }
}

function pp_print_space(state, param) {
  return pp_print_break(state, 1, 0);
}

function pp_print_cut(state, param) {
  return pp_print_break(state, 0, 0);
}

function pp_open_tbox(state, param) {
  state.pp_curr_depth = state.pp_curr_depth + 1 | 0;
  if (state.pp_curr_depth < state.pp_max_boxes) {
    var elem = {
      elem_size: 0,
      token: /* Pp_tbegin */block.__(4, [/* Pp_tbox */[{
              contents: /* [] */0
            }]]),
      length: 0
    };
    return enqueue_advance(state, elem);
  } else {
    return 0;
  }
}

function pp_close_tbox(state, param) {
  if (state.pp_curr_depth > 1 && state.pp_curr_depth < state.pp_max_boxes) {
    var elem = {
      elem_size: 0,
      token: /* Pp_tend */2,
      length: 0
    };
    enqueue_advance(state, elem);
    state.pp_curr_depth = state.pp_curr_depth - 1 | 0;
    return /* () */0;
  } else {
    return 0;
  }
}

function pp_print_tbreak(state, width, offset) {
  if (state.pp_curr_depth < state.pp_max_boxes) {
    var elem = {
      elem_size: -state.pp_right_total | 0,
      token: /* Pp_tbreak */block.__(2, [
          width,
          offset
        ]),
      length: width
    };
    return scan_push(state, true, elem);
  } else {
    return 0;
  }
}

function pp_print_tab(state, param) {
  return pp_print_tbreak(state, 0, 0);
}

function pp_set_tab(state, param) {
  if (state.pp_curr_depth < state.pp_max_boxes) {
    var elem = {
      elem_size: 0,
      token: /* Pp_stab */0,
      length: 0
    };
    return enqueue_advance(state, elem);
  } else {
    return 0;
  }
}

function pp_set_max_boxes(state, n) {
  if (n > 1) {
    state.pp_max_boxes = n;
    return /* () */0;
  } else {
    return 0;
  }
}

function pp_get_max_boxes(state, param) {
  return state.pp_max_boxes;
}

function pp_over_max_boxes(state, param) {
  return state.pp_curr_depth === state.pp_max_boxes;
}

function pp_set_ellipsis_text(state, s) {
  state.pp_ellipsis = s;
  return /* () */0;
}

function pp_get_ellipsis_text(state, param) {
  return state.pp_ellipsis;
}

function pp_limit(n) {
  if (n < 1000000010) {
    return n;
  } else {
    return 1000000009;
  }
}

function pp_set_max_indent(state, n) {
  var state$1 = state;
  var n$1 = state.pp_margin - n | 0;
  if (n$1 >= 1) {
    var n$2 = pp_limit(n$1);
    state$1.pp_min_space_left = n$2;
    state$1.pp_max_indent = state$1.pp_margin - state$1.pp_min_space_left | 0;
    return pp_rinit(state$1);
  } else {
    return 0;
  }
}

function pp_get_max_indent(state, param) {
  return state.pp_max_indent;
}

function pp_set_margin(state, n) {
  if (n >= 1) {
    var n$1 = pp_limit(n);
    state.pp_margin = n$1;
    var new_max_indent = state.pp_max_indent <= state.pp_margin ? state.pp_max_indent : caml_primitive.caml_int_max(caml_primitive.caml_int_max(state.pp_margin - state.pp_min_space_left | 0, state.pp_margin / 2 | 0), 1);
    return pp_set_max_indent(state, new_max_indent);
  } else {
    return 0;
  }
}

function pp_get_margin(state, param) {
  return state.pp_margin;
}

function pp_set_formatter_out_functions(state, param) {
  state.pp_out_string = param.out_string;
  state.pp_out_flush = param.out_flush;
  state.pp_out_newline = param.out_newline;
  state.pp_out_spaces = param.out_spaces;
  state.pp_out_indent = param.out_indent;
  return /* () */0;
}

function pp_get_formatter_out_functions(state, param) {
  return {
          out_string: state.pp_out_string,
          out_flush: state.pp_out_flush,
          out_newline: state.pp_out_newline,
          out_spaces: state.pp_out_spaces,
          out_indent: state.pp_out_indent
        };
}

function pp_set_formatter_output_functions(state, f, g) {
  state.pp_out_string = f;
  state.pp_out_flush = g;
  return /* () */0;
}

function pp_get_formatter_output_functions(state, param) {
  return /* tuple */[
          state.pp_out_string,
          state.pp_out_flush
        ];
}

function display_newline(state, param) {
  return curry._3(state.pp_out_string, "\n", 0, 1);
}

var blank_line = caml_bytes.bytes_to_string(bytes.make(80, /* " " */32));

function display_blanks(state, _n) {
  while(true) {
    var n = _n;
    if (n > 0) {
      if (n <= 80) {
        return curry._3(state.pp_out_string, blank_line, 0, n);
      } else {
        curry._3(state.pp_out_string, blank_line, 0, 80);
        _n = n - 80 | 0;
        continue ;
      }
    } else {
      return 0;
    }
  }}

function pp_set_formatter_out_channel(state, oc) {
  state.pp_out_string = (function (param, param$1, param$2) {
      return pervasives.output_substring(oc, param, param$1, param$2);
    });
  state.pp_out_flush = (function (param) {
      return caml_io.caml_ml_flush(oc);
    });
  state.pp_out_newline = (function (param) {
      return display_newline(state);
    });
  state.pp_out_spaces = (function (param) {
      return display_blanks(state, param);
    });
  state.pp_out_indent = (function (param) {
      return display_blanks(state, param);
    });
  return /* () */0;
}

function default_pp_mark_open_tag(s) {
  return "<" + (s + ">");
}

function default_pp_mark_close_tag(s) {
  return "</" + (s + ">");
}

function default_pp_print_open_tag(prim) {
  return /* () */0;
}

function default_pp_print_close_tag(prim) {
  return /* () */0;
}

function pp_make_formatter(f, g, h, i, j) {
  var pp_queue = {
    insert: /* Nil */0,
    body: /* Nil */0
  };
  var sys_tok = {
    elem_size: -1,
    token: /* Pp_begin */block.__(3, [
        0,
        /* Pp_hovbox */3
      ]),
    length: 0
  };
  add_queue(sys_tok, pp_queue);
  var sys_scan_stack_000 = /* Scan_elem */[
    1,
    sys_tok
  ];
  var sys_scan_stack = /* :: */[
    sys_scan_stack_000,
    scan_stack_bottom
  ];
  return {
          pp_scan_stack: sys_scan_stack,
          pp_format_stack: /* [] */0,
          pp_tbox_stack: /* [] */0,
          pp_tag_stack: /* [] */0,
          pp_mark_stack: /* [] */0,
          pp_margin: 78,
          pp_min_space_left: 10,
          pp_max_indent: 68,
          pp_space_left: 78,
          pp_current_indent: 0,
          pp_is_new_line: true,
          pp_left_total: 1,
          pp_right_total: 1,
          pp_curr_depth: 1,
          pp_max_boxes: pervasives.max_int,
          pp_ellipsis: ".",
          pp_out_string: f,
          pp_out_flush: g,
          pp_out_newline: h,
          pp_out_spaces: i,
          pp_out_indent: j,
          pp_print_tags: false,
          pp_mark_tags: false,
          pp_mark_open_tag: default_pp_mark_open_tag,
          pp_mark_close_tag: default_pp_mark_close_tag,
          pp_print_open_tag: default_pp_print_open_tag,
          pp_print_close_tag: default_pp_print_close_tag,
          pp_queue: pp_queue
        };
}

function formatter_of_out_functions(out_funs) {
  return pp_make_formatter(out_funs.out_string, out_funs.out_flush, out_funs.out_newline, out_funs.out_spaces, out_funs.out_indent);
}

function make_formatter(output, flush) {
  var ppf = pp_make_formatter(output, flush, (function (prim) {
          return /* () */0;
        }), (function (prim) {
          return /* () */0;
        }), (function (prim) {
          return /* () */0;
        }));
  ppf.pp_out_newline = (function (param) {
      return display_newline(ppf);
    });
  ppf.pp_out_spaces = (function (param) {
      return display_blanks(ppf, param);
    });
  ppf.pp_out_indent = (function (param) {
      return display_blanks(ppf, param);
    });
  return ppf;
}

function formatter_of_out_channel(oc) {
  return make_formatter((function (param, param$1, param$2) {
                return pervasives.output_substring(oc, param, param$1, param$2);
              }), (function (param) {
                return caml_io.caml_ml_flush(oc);
              }));
}

function formatter_of_buffer(b) {
  return make_formatter((function (param, param$1, param$2) {
                return buffer.add_substring(b, param, param$1, param$2);
              }), (function (prim) {
                return /* () */0;
              }));
}

var stdbuf = buffer.create(512);

var std_formatter = formatter_of_out_channel(pervasives.stdout);

var err_formatter = formatter_of_out_channel(pervasives.stderr);

var str_formatter = formatter_of_buffer(stdbuf);

function flush_buffer_formatter(buf, ppf) {
  pp_flush_queue(ppf, false);
  var s = buffer.contents(buf);
  buffer.reset(buf);
  return s;
}

function flush_str_formatter(param) {
  return flush_buffer_formatter(stdbuf, str_formatter);
}

function make_symbolic_output_buffer(param) {
  return {
          symbolic_output_contents: /* [] */0
        };
}

function clear_symbolic_output_buffer(sob) {
  sob.symbolic_output_contents = /* [] */0;
  return /* () */0;
}

function get_symbolic_output_buffer(sob) {
  return list.rev(sob.symbolic_output_contents);
}

function flush_symbolic_output_buffer(sob) {
  var items = list.rev(sob.symbolic_output_contents);
  sob.symbolic_output_contents = /* [] */0;
  return items;
}

function add_symbolic_output_item(sob, item) {
  sob.symbolic_output_contents = /* :: */[
    item,
    sob.symbolic_output_contents
  ];
  return /* () */0;
}

function formatter_of_symbolic_output_buffer(sob) {
  var f = function (param, param$1, param$2) {
    var sob$1 = sob;
    var s = param;
    var i = param$1;
    var n = param$2;
    return add_symbolic_output_item(sob$1, /* Output_string */block.__(0, [string.sub(s, i, n)]));
  };
  var g = function (param) {
    return add_symbolic_output_item(sob, /* Output_flush */0);
  };
  var h = function (param) {
    return add_symbolic_output_item(sob, /* Output_newline */1);
  };
  var i = function (param) {
    return add_symbolic_output_item(sob, /* Output_spaces */block.__(1, [param]));
  };
  var j = function (param) {
    return add_symbolic_output_item(sob, /* Output_indent */block.__(2, [param]));
  };
  return pp_make_formatter(f, g, h, i, j);
}

function open_hbox(param) {
  return pp_open_hbox(std_formatter);
}

function open_vbox(param) {
  return pp_open_vbox(std_formatter, param);
}

function open_hvbox(param) {
  return pp_open_hvbox(std_formatter, param);
}

function open_hovbox(param) {
  return pp_open_hovbox(std_formatter, param);
}

function open_box(param) {
  return pp_open_box(std_formatter, param);
}

function close_box(param) {
  return pp_close_box(std_formatter);
}

function open_tag(param) {
  return pp_open_tag(std_formatter, param);
}

function close_tag(param) {
  return pp_close_tag(std_formatter);
}

function print_as(param, param$1) {
  return pp_print_as(std_formatter, param, param$1);
}

function print_string$1(param) {
  return pp_print_string(std_formatter, param);
}

function print_int$1(param) {
  return pp_print_string(std_formatter, String(param));
}

function print_float$1(param) {
  return pp_print_string(std_formatter, pervasives.string_of_float(param));
}

function print_char$1(param) {
  return pp_print_char(std_formatter, param);
}

function print_bool(param) {
  return pp_print_string(std_formatter, param ? "true" : "false");
}

function print_break(param, param$1) {
  return pp_print_break(std_formatter, param, param$1);
}

function print_cut(param) {
  return pp_print_break(std_formatter, 0, 0);
}

function print_space(param) {
  return pp_print_break(std_formatter, 1, 0);
}

function force_newline(param) {
  return pp_force_newline(std_formatter);
}

function print_flush(param) {
  return pp_print_flush(std_formatter);
}

function print_newline$1(param) {
  return pp_print_newline(std_formatter);
}

function print_if_newline(param) {
  return pp_print_if_newline(std_formatter);
}

function open_tbox(param) {
  return pp_open_tbox(std_formatter);
}

function close_tbox(param) {
  return pp_close_tbox(std_formatter);
}

function print_tbreak(param, param$1) {
  return pp_print_tbreak(std_formatter, param, param$1);
}

function set_tab(param) {
  return pp_set_tab(std_formatter);
}

function print_tab(param) {
  return pp_print_tbreak(std_formatter, 0, 0);
}

function set_margin(param) {
  return pp_set_margin(std_formatter, param);
}

function get_margin(param) {
  return std_formatter.pp_margin;
}

function set_max_indent(param) {
  return pp_set_max_indent(std_formatter, param);
}

function get_max_indent(param) {
  return std_formatter.pp_max_indent;
}

function set_max_boxes(param) {
  return pp_set_max_boxes(std_formatter, param);
}

function get_max_boxes(param) {
  return std_formatter.pp_max_boxes;
}

function over_max_boxes(param) {
  return pp_over_max_boxes(std_formatter);
}

function set_ellipsis_text(param) {
  std_formatter.pp_ellipsis = param;
  return /* () */0;
}

function get_ellipsis_text(param) {
  return std_formatter.pp_ellipsis;
}

function set_formatter_out_channel(param) {
  return pp_set_formatter_out_channel(std_formatter, param);
}

function set_formatter_out_functions(param) {
  return pp_set_formatter_out_functions(std_formatter, param);
}

function get_formatter_out_functions(param) {
  return pp_get_formatter_out_functions(std_formatter);
}

function set_formatter_output_functions(param, param$1) {
  return pp_set_formatter_output_functions(std_formatter, param, param$1);
}

function get_formatter_output_functions(param) {
  return pp_get_formatter_output_functions(std_formatter);
}

function set_formatter_tag_functions(param) {
  return pp_set_formatter_tag_functions(std_formatter, param);
}

function get_formatter_tag_functions(param) {
  return pp_get_formatter_tag_functions(std_formatter);
}

function set_print_tags(param) {
  std_formatter.pp_print_tags = param;
  return /* () */0;
}

function get_print_tags(param) {
  return std_formatter.pp_print_tags;
}

function set_mark_tags(param) {
  std_formatter.pp_mark_tags = param;
  return /* () */0;
}

function get_mark_tags(param) {
  return std_formatter.pp_mark_tags;
}

function set_tags(param) {
  return pp_set_tags(std_formatter, param);
}

function pp_print_list(_$staropt$star, pp_v, ppf, _param) {
  while(true) {
    var param = _param;
    var $staropt$star = _$staropt$star;
    var pp_sep = $staropt$star !== undefined ? $staropt$star : pp_print_cut;
    if (param) {
      var vs = param[1];
      var v = param[0];
      if (vs) {
        curry._2(pp_v, ppf, v);
        curry._2(pp_sep, ppf, /* () */0);
        _param = vs;
        _$staropt$star = pp_sep;
        continue ;
      } else {
        return curry._2(pp_v, ppf, v);
      }
    } else {
      return /* () */0;
    }
  }}

function pp_print_text(ppf, s) {
  var len = s.length;
  var left = {
    contents: 0
  };
  var right = {
    contents: 0
  };
  var flush = function (param) {
    pp_print_string(ppf, string.sub(s, left.contents, right.contents - left.contents | 0));
    right.contents = right.contents + 1 | 0;
    left.contents = right.contents;
    return /* () */0;
  };
  while(right.contents !== len) {
    var match = caml_string.get(s, right.contents);
    if (match !== 10) {
      if (match !== 32) {
        right.contents = right.contents + 1 | 0;
      } else {
        flush();
        pp_print_break(ppf, 1, 0);
      }
    } else {
      flush();
      pp_force_newline(ppf);
    }
  }  if (left.contents !== len) {
    return flush();
  } else {
    return 0;
  }
}

function compute_tag(output, tag_acc) {
  var buf = buffer.create(16);
  var ppf = formatter_of_buffer(buf);
  curry._2(output, ppf, tag_acc);
  pp_print_flush(ppf);
  var len = buf.position;
  if (len < 2) {
    return buffer.contents(buf);
  } else {
    return buffer.sub(buf, 1, len - 2 | 0);
  }
}

function output_formatting_lit(ppf, fmting_lit) {
  if (typeof fmting_lit === "number") {
    switch (fmting_lit) {
      case /* Close_box */0 :
          return pp_close_box(ppf);
      case /* Close_tag */1 :
          return pp_close_tag(ppf);
      case /* FFlush */2 :
          return pp_print_flush(ppf);
      case /* Force_newline */3 :
          return pp_force_newline(ppf);
      case /* Flush_newline */4 :
          return pp_print_newline(ppf);
      case /* Escaped_at */5 :
          return pp_print_char(ppf, /* "@" */64);
      case /* Escaped_percent */6 :
          return pp_print_char(ppf, /* "%" */37);
      
    }
  } else {
    switch (fmting_lit.tag | 0) {
      case /* Break */0 :
          return pp_print_break(ppf, fmting_lit[1], fmting_lit[2]);
      case /* Magic_size */1 :
          return /* () */0;
      case /* Scan_indic */2 :
          pp_print_char(ppf, /* "@" */64);
          return pp_print_char(ppf, fmting_lit[0]);
      
    }
  }
}

function output_acc$1(ppf, acc) {
  var exit = 0;
  var p;
  var size;
  var s;
  var p$1;
  var size$1;
  var c;
  if (typeof acc === "number") {
    return /* () */0;
  } else {
    switch (acc.tag | 0) {
      case /* Acc_formatting_lit */0 :
          output_acc$1(ppf, acc[0]);
          return output_formatting_lit(ppf, acc[1]);
      case /* Acc_formatting_gen */1 :
          var match = acc[1];
          var p$2 = acc[0];
          output_acc$1(ppf, p$2);
          if (match.tag) {
            var match$1 = camlinternalFormat.open_box_of_string(compute_tag(output_acc$1, match[0]));
            return pp_open_box_gen(ppf, match$1[0], match$1[1]);
          } else {
            return pp_open_tag(ppf, compute_tag(output_acc$1, match[0]));
          }
      case /* Acc_string_literal */2 :
          var p$3 = acc[0];
          if (typeof p$3 !== "number" && !p$3.tag) {
            var match$2 = p$3[1];
            if (typeof match$2 !== "number" && match$2.tag === /* Magic_size */1) {
              p = p$3[0];
              size = match$2[1];
              s = acc[1];
              exit = 1;
            }
            
          }
          output_acc$1(ppf, p$3);
          return pp_print_string(ppf, acc[1]);
      case /* Acc_char_literal */3 :
          var p$4 = acc[0];
          if (typeof p$4 !== "number" && !p$4.tag) {
            var match$3 = p$4[1];
            if (typeof match$3 !== "number" && match$3.tag === /* Magic_size */1) {
              p$1 = p$4[0];
              size$1 = match$3[1];
              c = acc[1];
              exit = 2;
            }
            
          }
          output_acc$1(ppf, p$4);
          return pp_print_char(ppf, acc[1]);
      case /* Acc_data_string */4 :
          var p$5 = acc[0];
          if (typeof p$5 !== "number" && !p$5.tag) {
            var match$4 = p$5[1];
            if (typeof match$4 !== "number" && match$4.tag === /* Magic_size */1) {
              p = p$5[0];
              size = match$4[1];
              s = acc[1];
              exit = 1;
            }
            
          }
          output_acc$1(ppf, p$5);
          return pp_print_string(ppf, acc[1]);
      case /* Acc_data_char */5 :
          var p$6 = acc[0];
          if (typeof p$6 !== "number" && !p$6.tag) {
            var match$5 = p$6[1];
            if (typeof match$5 !== "number" && match$5.tag === /* Magic_size */1) {
              p$1 = p$6[0];
              size$1 = match$5[1];
              c = acc[1];
              exit = 2;
            }
            
          }
          output_acc$1(ppf, p$6);
          return pp_print_char(ppf, acc[1]);
      case /* Acc_delay */6 :
          output_acc$1(ppf, acc[0]);
          return curry._1(acc[1], ppf);
      case /* Acc_flush */7 :
          output_acc$1(ppf, acc[0]);
          return pp_print_flush(ppf);
      case /* Acc_invalid_arg */8 :
          output_acc$1(ppf, acc[0]);
          throw [
                caml_builtin_exceptions.invalid_argument,
                acc[1]
              ];
      
    }
  }
  switch (exit) {
    case 1 :
        output_acc$1(ppf, p);
        return pp_print_as_size(ppf, size, s);
    case 2 :
        output_acc$1(ppf, p$1);
        return pp_print_as_size(ppf, size$1, caml_bytes.bytes_to_string(bytes.make(1, c)));
    
  }
}

function strput_acc$1(ppf, acc) {
  var exit = 0;
  var p;
  var size;
  var s;
  var p$1;
  var size$1;
  var c;
  if (typeof acc === "number") {
    return /* () */0;
  } else {
    switch (acc.tag | 0) {
      case /* Acc_formatting_lit */0 :
          strput_acc$1(ppf, acc[0]);
          return output_formatting_lit(ppf, acc[1]);
      case /* Acc_formatting_gen */1 :
          var match = acc[1];
          var p$2 = acc[0];
          strput_acc$1(ppf, p$2);
          if (match.tag) {
            var match$1 = camlinternalFormat.open_box_of_string(compute_tag(strput_acc$1, match[0]));
            return pp_open_box_gen(ppf, match$1[0], match$1[1]);
          } else {
            return pp_open_tag(ppf, compute_tag(strput_acc$1, match[0]));
          }
      case /* Acc_string_literal */2 :
          var p$3 = acc[0];
          if (typeof p$3 !== "number" && !p$3.tag) {
            var match$2 = p$3[1];
            if (typeof match$2 !== "number" && match$2.tag === /* Magic_size */1) {
              p = p$3[0];
              size = match$2[1];
              s = acc[1];
              exit = 1;
            }
            
          }
          strput_acc$1(ppf, p$3);
          return pp_print_string(ppf, acc[1]);
      case /* Acc_char_literal */3 :
          var p$4 = acc[0];
          if (typeof p$4 !== "number" && !p$4.tag) {
            var match$3 = p$4[1];
            if (typeof match$3 !== "number" && match$3.tag === /* Magic_size */1) {
              p$1 = p$4[0];
              size$1 = match$3[1];
              c = acc[1];
              exit = 2;
            }
            
          }
          strput_acc$1(ppf, p$4);
          return pp_print_char(ppf, acc[1]);
      case /* Acc_data_string */4 :
          var p$5 = acc[0];
          if (typeof p$5 !== "number" && !p$5.tag) {
            var match$4 = p$5[1];
            if (typeof match$4 !== "number" && match$4.tag === /* Magic_size */1) {
              p = p$5[0];
              size = match$4[1];
              s = acc[1];
              exit = 1;
            }
            
          }
          strput_acc$1(ppf, p$5);
          return pp_print_string(ppf, acc[1]);
      case /* Acc_data_char */5 :
          var p$6 = acc[0];
          if (typeof p$6 !== "number" && !p$6.tag) {
            var match$5 = p$6[1];
            if (typeof match$5 !== "number" && match$5.tag === /* Magic_size */1) {
              p$1 = p$6[0];
              size$1 = match$5[1];
              c = acc[1];
              exit = 2;
            }
            
          }
          strput_acc$1(ppf, p$6);
          return pp_print_char(ppf, acc[1]);
      case /* Acc_delay */6 :
          var p$7 = acc[0];
          if (typeof p$7 !== "number" && !p$7.tag) {
            var match$6 = p$7[1];
            if (typeof match$6 !== "number" && match$6.tag === /* Magic_size */1) {
              strput_acc$1(ppf, p$7[0]);
              return pp_print_as_size(ppf, match$6[1], curry._1(acc[1], /* () */0));
            }
            
          }
          strput_acc$1(ppf, p$7);
          return pp_print_string(ppf, curry._1(acc[1], /* () */0));
      case /* Acc_flush */7 :
          strput_acc$1(ppf, acc[0]);
          return pp_print_flush(ppf);
      case /* Acc_invalid_arg */8 :
          strput_acc$1(ppf, acc[0]);
          throw [
                caml_builtin_exceptions.invalid_argument,
                acc[1]
              ];
      
    }
  }
  switch (exit) {
    case 1 :
        strput_acc$1(ppf, p);
        return pp_print_as_size(ppf, size, s);
    case 2 :
        strput_acc$1(ppf, p$1);
        return pp_print_as_size(ppf, size$1, caml_bytes.bytes_to_string(bytes.make(1, c)));
    
  }
}

function kfprintf$1(k, ppf, param) {
  return camlinternalFormat.make_printf((function (ppf, acc) {
                output_acc$1(ppf, acc);
                return curry._1(k, ppf);
              }), ppf, /* End_of_acc */0, param[0]);
}

function ikfprintf$1(k, ppf, param) {
  return camlinternalFormat.make_iprintf(k, ppf, param[0]);
}

function fprintf$1(ppf, fmt) {
  return kfprintf$1((function (prim) {
                return /* () */0;
              }), ppf, fmt);
}

function ifprintf$1(ppf, fmt) {
  return ikfprintf$1((function (prim) {
                return /* () */0;
              }), ppf, fmt);
}

function printf$1(fmt) {
  return fprintf$1(std_formatter, fmt);
}

function eprintf$1(fmt) {
  return fprintf$1(err_formatter, fmt);
}

function ksprintf$1(k, param) {
  var b = buffer.create(512);
  var ppf = formatter_of_buffer(b);
  var k$1 = function (param, acc) {
    strput_acc$1(ppf, acc);
    return curry._1(k, flush_buffer_formatter(b, ppf));
  };
  return camlinternalFormat.make_printf(k$1, /* () */0, /* End_of_acc */0, param[0]);
}

function sprintf$1(fmt) {
  return ksprintf$1((function (s) {
                return s;
              }), fmt);
}

function kasprintf(k, param) {
  var b = buffer.create(512);
  var ppf = formatter_of_buffer(b);
  var k$1 = function (ppf, acc) {
    output_acc$1(ppf, acc);
    return curry._1(k, flush_buffer_formatter(b, ppf));
  };
  return camlinternalFormat.make_printf(k$1, ppf, /* End_of_acc */0, param[0]);
}

function asprintf(fmt) {
  return kasprintf((function (s) {
                return s;
              }), fmt);
}

pervasives.at_exit(print_flush);

function pp_set_all_formatter_output_functions(state, f, g, h, i) {
  pp_set_formatter_output_functions(state, f, g);
  state.pp_out_newline = h;
  state.pp_out_spaces = i;
  return /* () */0;
}

function pp_get_all_formatter_output_functions(state, param) {
  return /* tuple */[
          state.pp_out_string,
          state.pp_out_flush,
          state.pp_out_newline,
          state.pp_out_spaces
        ];
}

function set_all_formatter_output_functions(param, param$1, param$2, param$3) {
  return pp_set_all_formatter_output_functions(std_formatter, param, param$1, param$2, param$3);
}

function get_all_formatter_output_functions(param) {
  return pp_get_all_formatter_output_functions(std_formatter);
}

function bprintf$1(b, param) {
  var k = function (ppf, acc) {
    output_acc$1(ppf, acc);
    return pp_flush_queue(ppf, false);
  };
  return camlinternalFormat.make_printf(k, formatter_of_buffer(b), /* End_of_acc */0, param[0]);
}

var kprintf$1 = ksprintf$1;

var pp_open_box_1 = pp_open_box;
var open_box_1 = open_box;
var pp_close_box_1 = pp_close_box;
var close_box_1 = close_box;
var pp_open_hbox_1 = pp_open_hbox;
var open_hbox_1 = open_hbox;
var pp_open_vbox_1 = pp_open_vbox;
var open_vbox_1 = open_vbox;
var pp_open_hvbox_1 = pp_open_hvbox;
var open_hvbox_1 = open_hvbox;
var pp_open_hovbox_1 = pp_open_hovbox;
var open_hovbox_1 = open_hovbox;
var pp_print_string_1 = pp_print_string;
var print_string_1$1 = print_string$1;
var pp_print_as_1 = pp_print_as;
var print_as_1 = print_as;
var pp_print_int_1 = pp_print_int;
var print_int_1$1 = print_int$1;
var pp_print_float_1 = pp_print_float;
var print_float_1$1 = print_float$1;
var pp_print_char_1 = pp_print_char;
var print_char_1$1 = print_char$1;
var pp_print_bool_1 = pp_print_bool;
var print_bool_1 = print_bool;
var pp_print_space_1 = pp_print_space;
var print_space_1 = print_space;
var pp_print_cut_1 = pp_print_cut;
var print_cut_1 = print_cut;
var pp_print_break_1 = pp_print_break;
var print_break_1 = print_break;
var pp_force_newline_1 = pp_force_newline;
var force_newline_1 = force_newline;
var pp_print_if_newline_1 = pp_print_if_newline;
var print_if_newline_1 = print_if_newline;
var pp_print_flush_1 = pp_print_flush;
var print_flush_1 = print_flush;
var pp_print_newline_1 = pp_print_newline;
var print_newline_1$1 = print_newline$1;
var pp_set_margin_1 = pp_set_margin;
var set_margin_1 = set_margin;
var pp_get_margin_1 = pp_get_margin;
var get_margin_1 = get_margin;
var pp_set_max_indent_1 = pp_set_max_indent;
var set_max_indent_1 = set_max_indent;
var pp_get_max_indent_1 = pp_get_max_indent;
var get_max_indent_1 = get_max_indent;
var pp_set_max_boxes_1 = pp_set_max_boxes;
var set_max_boxes_1 = set_max_boxes;
var pp_get_max_boxes_1 = pp_get_max_boxes;
var get_max_boxes_1 = get_max_boxes;
var pp_over_max_boxes_1 = pp_over_max_boxes;
var over_max_boxes_1 = over_max_boxes;
var pp_open_tbox_1 = pp_open_tbox;
var open_tbox_1 = open_tbox;
var pp_close_tbox_1 = pp_close_tbox;
var close_tbox_1 = close_tbox;
var pp_set_tab_1 = pp_set_tab;
var set_tab_1 = set_tab;
var pp_print_tab_1 = pp_print_tab;
var print_tab_1 = print_tab;
var pp_print_tbreak_1 = pp_print_tbreak;
var print_tbreak_1 = print_tbreak;
var pp_set_ellipsis_text_1 = pp_set_ellipsis_text;
var set_ellipsis_text_1 = set_ellipsis_text;
var pp_get_ellipsis_text_1 = pp_get_ellipsis_text;
var get_ellipsis_text_1 = get_ellipsis_text;
var pp_open_tag_1 = pp_open_tag;
var open_tag_1 = open_tag;
var pp_close_tag_1 = pp_close_tag;
var close_tag_1 = close_tag;
var pp_set_tags_1 = pp_set_tags;
var set_tags_1 = set_tags;
var pp_set_print_tags_1 = pp_set_print_tags;
var set_print_tags_1 = set_print_tags;
var pp_set_mark_tags_1 = pp_set_mark_tags;
var set_mark_tags_1 = set_mark_tags;
var pp_get_print_tags_1 = pp_get_print_tags;
var get_print_tags_1 = get_print_tags;
var pp_get_mark_tags_1 = pp_get_mark_tags;
var get_mark_tags_1 = get_mark_tags;
var pp_set_formatter_out_channel_1 = pp_set_formatter_out_channel;
var set_formatter_out_channel_1 = set_formatter_out_channel;
var pp_set_formatter_output_functions_1 = pp_set_formatter_output_functions;
var set_formatter_output_functions_1 = set_formatter_output_functions;
var pp_get_formatter_output_functions_1 = pp_get_formatter_output_functions;
var get_formatter_output_functions_1 = get_formatter_output_functions;
var pp_set_formatter_out_functions_1 = pp_set_formatter_out_functions;
var set_formatter_out_functions_1 = set_formatter_out_functions;
var pp_get_formatter_out_functions_1 = pp_get_formatter_out_functions;
var get_formatter_out_functions_1 = get_formatter_out_functions;
var pp_set_formatter_tag_functions_1 = pp_set_formatter_tag_functions;
var set_formatter_tag_functions_1 = set_formatter_tag_functions;
var pp_get_formatter_tag_functions_1 = pp_get_formatter_tag_functions;
var get_formatter_tag_functions_1 = get_formatter_tag_functions;
var formatter_of_out_channel_1 = formatter_of_out_channel;
var std_formatter_1 = std_formatter;
var err_formatter_1 = err_formatter;
var formatter_of_buffer_1 = formatter_of_buffer;
var stdbuf_1 = stdbuf;
var str_formatter_1 = str_formatter;
var flush_str_formatter_1 = flush_str_formatter;
var make_formatter_1 = make_formatter;
var formatter_of_out_functions_1 = formatter_of_out_functions;
var make_symbolic_output_buffer_1 = make_symbolic_output_buffer;
var clear_symbolic_output_buffer_1 = clear_symbolic_output_buffer;
var get_symbolic_output_buffer_1 = get_symbolic_output_buffer;
var flush_symbolic_output_buffer_1 = flush_symbolic_output_buffer;
var add_symbolic_output_item_1 = add_symbolic_output_item;
var formatter_of_symbolic_output_buffer_1 = formatter_of_symbolic_output_buffer;
var pp_print_list_1 = pp_print_list;
var pp_print_text_1 = pp_print_text;
var fprintf_1$1 = fprintf$1;
var printf_1$1 = printf$1;
var eprintf_1$1 = eprintf$1;
var sprintf_1$1 = sprintf$1;
var asprintf_1 = asprintf;
var ifprintf_1$1 = ifprintf$1;
var kfprintf_1$1 = kfprintf$1;
var ikfprintf_1$1 = ikfprintf$1;
var ksprintf_1$1 = ksprintf$1;
var kasprintf_1 = kasprintf;
var bprintf_1$1 = bprintf$1;
var kprintf_1$1 = kprintf$1;
var set_all_formatter_output_functions_1 = set_all_formatter_output_functions;
var get_all_formatter_output_functions_1 = get_all_formatter_output_functions;
var pp_set_all_formatter_output_functions_1 = pp_set_all_formatter_output_functions;
var pp_get_all_formatter_output_functions_1 = pp_get_all_formatter_output_functions;
/* blank_line Not a pure module */

var format = {
	pp_open_box: pp_open_box_1,
	open_box: open_box_1,
	pp_close_box: pp_close_box_1,
	close_box: close_box_1,
	pp_open_hbox: pp_open_hbox_1,
	open_hbox: open_hbox_1,
	pp_open_vbox: pp_open_vbox_1,
	open_vbox: open_vbox_1,
	pp_open_hvbox: pp_open_hvbox_1,
	open_hvbox: open_hvbox_1,
	pp_open_hovbox: pp_open_hovbox_1,
	open_hovbox: open_hovbox_1,
	pp_print_string: pp_print_string_1,
	print_string: print_string_1$1,
	pp_print_as: pp_print_as_1,
	print_as: print_as_1,
	pp_print_int: pp_print_int_1,
	print_int: print_int_1$1,
	pp_print_float: pp_print_float_1,
	print_float: print_float_1$1,
	pp_print_char: pp_print_char_1,
	print_char: print_char_1$1,
	pp_print_bool: pp_print_bool_1,
	print_bool: print_bool_1,
	pp_print_space: pp_print_space_1,
	print_space: print_space_1,
	pp_print_cut: pp_print_cut_1,
	print_cut: print_cut_1,
	pp_print_break: pp_print_break_1,
	print_break: print_break_1,
	pp_force_newline: pp_force_newline_1,
	force_newline: force_newline_1,
	pp_print_if_newline: pp_print_if_newline_1,
	print_if_newline: print_if_newline_1,
	pp_print_flush: pp_print_flush_1,
	print_flush: print_flush_1,
	pp_print_newline: pp_print_newline_1,
	print_newline: print_newline_1$1,
	pp_set_margin: pp_set_margin_1,
	set_margin: set_margin_1,
	pp_get_margin: pp_get_margin_1,
	get_margin: get_margin_1,
	pp_set_max_indent: pp_set_max_indent_1,
	set_max_indent: set_max_indent_1,
	pp_get_max_indent: pp_get_max_indent_1,
	get_max_indent: get_max_indent_1,
	pp_set_max_boxes: pp_set_max_boxes_1,
	set_max_boxes: set_max_boxes_1,
	pp_get_max_boxes: pp_get_max_boxes_1,
	get_max_boxes: get_max_boxes_1,
	pp_over_max_boxes: pp_over_max_boxes_1,
	over_max_boxes: over_max_boxes_1,
	pp_open_tbox: pp_open_tbox_1,
	open_tbox: open_tbox_1,
	pp_close_tbox: pp_close_tbox_1,
	close_tbox: close_tbox_1,
	pp_set_tab: pp_set_tab_1,
	set_tab: set_tab_1,
	pp_print_tab: pp_print_tab_1,
	print_tab: print_tab_1,
	pp_print_tbreak: pp_print_tbreak_1,
	print_tbreak: print_tbreak_1,
	pp_set_ellipsis_text: pp_set_ellipsis_text_1,
	set_ellipsis_text: set_ellipsis_text_1,
	pp_get_ellipsis_text: pp_get_ellipsis_text_1,
	get_ellipsis_text: get_ellipsis_text_1,
	pp_open_tag: pp_open_tag_1,
	open_tag: open_tag_1,
	pp_close_tag: pp_close_tag_1,
	close_tag: close_tag_1,
	pp_set_tags: pp_set_tags_1,
	set_tags: set_tags_1,
	pp_set_print_tags: pp_set_print_tags_1,
	set_print_tags: set_print_tags_1,
	pp_set_mark_tags: pp_set_mark_tags_1,
	set_mark_tags: set_mark_tags_1,
	pp_get_print_tags: pp_get_print_tags_1,
	get_print_tags: get_print_tags_1,
	pp_get_mark_tags: pp_get_mark_tags_1,
	get_mark_tags: get_mark_tags_1,
	pp_set_formatter_out_channel: pp_set_formatter_out_channel_1,
	set_formatter_out_channel: set_formatter_out_channel_1,
	pp_set_formatter_output_functions: pp_set_formatter_output_functions_1,
	set_formatter_output_functions: set_formatter_output_functions_1,
	pp_get_formatter_output_functions: pp_get_formatter_output_functions_1,
	get_formatter_output_functions: get_formatter_output_functions_1,
	pp_set_formatter_out_functions: pp_set_formatter_out_functions_1,
	set_formatter_out_functions: set_formatter_out_functions_1,
	pp_get_formatter_out_functions: pp_get_formatter_out_functions_1,
	get_formatter_out_functions: get_formatter_out_functions_1,
	pp_set_formatter_tag_functions: pp_set_formatter_tag_functions_1,
	set_formatter_tag_functions: set_formatter_tag_functions_1,
	pp_get_formatter_tag_functions: pp_get_formatter_tag_functions_1,
	get_formatter_tag_functions: get_formatter_tag_functions_1,
	formatter_of_out_channel: formatter_of_out_channel_1,
	std_formatter: std_formatter_1,
	err_formatter: err_formatter_1,
	formatter_of_buffer: formatter_of_buffer_1,
	stdbuf: stdbuf_1,
	str_formatter: str_formatter_1,
	flush_str_formatter: flush_str_formatter_1,
	make_formatter: make_formatter_1,
	formatter_of_out_functions: formatter_of_out_functions_1,
	make_symbolic_output_buffer: make_symbolic_output_buffer_1,
	clear_symbolic_output_buffer: clear_symbolic_output_buffer_1,
	get_symbolic_output_buffer: get_symbolic_output_buffer_1,
	flush_symbolic_output_buffer: flush_symbolic_output_buffer_1,
	add_symbolic_output_item: add_symbolic_output_item_1,
	formatter_of_symbolic_output_buffer: formatter_of_symbolic_output_buffer_1,
	pp_print_list: pp_print_list_1,
	pp_print_text: pp_print_text_1,
	fprintf: fprintf_1$1,
	printf: printf_1$1,
	eprintf: eprintf_1$1,
	sprintf: sprintf_1$1,
	asprintf: asprintf_1,
	ifprintf: ifprintf_1$1,
	kfprintf: kfprintf_1$1,
	ikfprintf: ikfprintf_1$1,
	ksprintf: ksprintf_1$1,
	kasprintf: kasprintf_1,
	bprintf: bprintf_1$1,
	kprintf: kprintf_1$1,
	set_all_formatter_output_functions: set_all_formatter_output_functions_1,
	get_all_formatter_output_functions: get_all_formatter_output_functions_1,
	pp_set_all_formatter_output_functions: pp_set_all_formatter_output_functions_1,
	pp_get_all_formatter_output_functions: pp_get_all_formatter_output_functions_1
};

function Make(funarg) {
  var height = function (param) {
    if (param) {
      return param[/* h */4];
    } else {
      return 0;
    }
  };
  var create = function (l, x, d, r) {
    var hl = height(l);
    var hr = height(r);
    return /* Node */[
            /* l */l,
            /* v */x,
            /* d */d,
            /* r */r,
            /* h */hl >= hr ? hl + 1 | 0 : hr + 1 | 0
          ];
  };
  var singleton = function (x, d) {
    return /* Node */[
            /* l : Empty */0,
            /* v */x,
            /* d */d,
            /* r : Empty */0,
            /* h */1
          ];
  };
  var bal = function (l, x, d, r) {
    var hl = l ? l[/* h */4] : 0;
    var hr = r ? r[/* h */4] : 0;
    if (hl > (hr + 2 | 0)) {
      if (l) {
        var lr = l[/* r */3];
        var ld = l[/* d */2];
        var lv = l[/* v */1];
        var ll = l[/* l */0];
        if (height(ll) >= height(lr)) {
          return create(ll, lv, ld, create(lr, x, d, r));
        } else if (lr) {
          return create(create(ll, lv, ld, lr[/* l */0]), lr[/* v */1], lr[/* d */2], create(lr[/* r */3], x, d, r));
        } else {
          throw [
                caml_builtin_exceptions.invalid_argument,
                "Map.bal"
              ];
        }
      } else {
        throw [
              caml_builtin_exceptions.invalid_argument,
              "Map.bal"
            ];
      }
    } else if (hr > (hl + 2 | 0)) {
      if (r) {
        var rr = r[/* r */3];
        var rd = r[/* d */2];
        var rv = r[/* v */1];
        var rl = r[/* l */0];
        if (height(rr) >= height(rl)) {
          return create(create(l, x, d, rl), rv, rd, rr);
        } else if (rl) {
          return create(create(l, x, d, rl[/* l */0]), rl[/* v */1], rl[/* d */2], create(rl[/* r */3], rv, rd, rr));
        } else {
          throw [
                caml_builtin_exceptions.invalid_argument,
                "Map.bal"
              ];
        }
      } else {
        throw [
              caml_builtin_exceptions.invalid_argument,
              "Map.bal"
            ];
      }
    } else {
      return /* Node */[
              /* l */l,
              /* v */x,
              /* d */d,
              /* r */r,
              /* h */hl >= hr ? hl + 1 | 0 : hr + 1 | 0
            ];
    }
  };
  var is_empty = function (param) {
    if (param) {
      return false;
    } else {
      return true;
    }
  };
  var add = function (x, data, m) {
    if (m) {
      var r = m[/* r */3];
      var d = m[/* d */2];
      var v = m[/* v */1];
      var l = m[/* l */0];
      var c = curry._2(funarg.compare, x, v);
      if (c === 0) {
        if (d === data) {
          return m;
        } else {
          return /* Node */[
                  /* l */l,
                  /* v */x,
                  /* d */data,
                  /* r */r,
                  /* h */m[/* h */4]
                ];
        }
      } else if (c < 0) {
        var ll = add(x, data, l);
        if (l === ll) {
          return m;
        } else {
          return bal(ll, v, d, r);
        }
      } else {
        var rr = add(x, data, r);
        if (r === rr) {
          return m;
        } else {
          return bal(l, v, d, rr);
        }
      }
    } else {
      return /* Node */[
              /* l : Empty */0,
              /* v */x,
              /* d */data,
              /* r : Empty */0,
              /* h */1
            ];
    }
  };
  var find = function (x, _param) {
    while(true) {
      var param = _param;
      if (param) {
        var c = curry._2(funarg.compare, x, param[/* v */1]);
        if (c === 0) {
          return param[/* d */2];
        } else {
          _param = c < 0 ? param[/* l */0] : param[/* r */3];
          continue ;
        }
      } else {
        throw caml_builtin_exceptions.not_found;
      }
    }  };
  var find_first = function (f, _param) {
    while(true) {
      var param = _param;
      if (param) {
        var v = param[/* v */1];
        if (curry._1(f, v)) {
          var _v0 = v;
          var _d0 = param[/* d */2];
          var f$1 = f;
          var _param$1 = param[/* l */0];
          while(true) {
            var param$1 = _param$1;
            var d0 = _d0;
            var v0 = _v0;
            if (param$1) {
              var v$1 = param$1[/* v */1];
              if (curry._1(f$1, v$1)) {
                _param$1 = param$1[/* l */0];
                _d0 = param$1[/* d */2];
                _v0 = v$1;
                continue ;
              } else {
                _param$1 = param$1[/* r */3];
                continue ;
              }
            } else {
              return /* tuple */[
                      v0,
                      d0
                    ];
            }
          }        } else {
          _param = param[/* r */3];
          continue ;
        }
      } else {
        throw caml_builtin_exceptions.not_found;
      }
    }  };
  var find_first_opt = function (f, _param) {
    while(true) {
      var param = _param;
      if (param) {
        var v = param[/* v */1];
        if (curry._1(f, v)) {
          var _v0 = v;
          var _d0 = param[/* d */2];
          var f$1 = f;
          var _param$1 = param[/* l */0];
          while(true) {
            var param$1 = _param$1;
            var d0 = _d0;
            var v0 = _v0;
            if (param$1) {
              var v$1 = param$1[/* v */1];
              if (curry._1(f$1, v$1)) {
                _param$1 = param$1[/* l */0];
                _d0 = param$1[/* d */2];
                _v0 = v$1;
                continue ;
              } else {
                _param$1 = param$1[/* r */3];
                continue ;
              }
            } else {
              return /* tuple */[
                      v0,
                      d0
                    ];
            }
          }        } else {
          _param = param[/* r */3];
          continue ;
        }
      } else {
        return ;
      }
    }  };
  var find_last = function (f, _param) {
    while(true) {
      var param = _param;
      if (param) {
        var v = param[/* v */1];
        if (curry._1(f, v)) {
          var _v0 = v;
          var _d0 = param[/* d */2];
          var f$1 = f;
          var _param$1 = param[/* r */3];
          while(true) {
            var param$1 = _param$1;
            var d0 = _d0;
            var v0 = _v0;
            if (param$1) {
              var v$1 = param$1[/* v */1];
              if (curry._1(f$1, v$1)) {
                _param$1 = param$1[/* r */3];
                _d0 = param$1[/* d */2];
                _v0 = v$1;
                continue ;
              } else {
                _param$1 = param$1[/* l */0];
                continue ;
              }
            } else {
              return /* tuple */[
                      v0,
                      d0
                    ];
            }
          }        } else {
          _param = param[/* l */0];
          continue ;
        }
      } else {
        throw caml_builtin_exceptions.not_found;
      }
    }  };
  var find_last_opt = function (f, _param) {
    while(true) {
      var param = _param;
      if (param) {
        var v = param[/* v */1];
        if (curry._1(f, v)) {
          var _v0 = v;
          var _d0 = param[/* d */2];
          var f$1 = f;
          var _param$1 = param[/* r */3];
          while(true) {
            var param$1 = _param$1;
            var d0 = _d0;
            var v0 = _v0;
            if (param$1) {
              var v$1 = param$1[/* v */1];
              if (curry._1(f$1, v$1)) {
                _param$1 = param$1[/* r */3];
                _d0 = param$1[/* d */2];
                _v0 = v$1;
                continue ;
              } else {
                _param$1 = param$1[/* l */0];
                continue ;
              }
            } else {
              return /* tuple */[
                      v0,
                      d0
                    ];
            }
          }        } else {
          _param = param[/* l */0];
          continue ;
        }
      } else {
        return ;
      }
    }  };
  var find_opt = function (x, _param) {
    while(true) {
      var param = _param;
      if (param) {
        var c = curry._2(funarg.compare, x, param[/* v */1]);
        if (c === 0) {
          return caml_option.some(param[/* d */2]);
        } else {
          _param = c < 0 ? param[/* l */0] : param[/* r */3];
          continue ;
        }
      } else {
        return ;
      }
    }  };
  var mem = function (x, _param) {
    while(true) {
      var param = _param;
      if (param) {
        var c = curry._2(funarg.compare, x, param[/* v */1]);
        if (c === 0) {
          return true;
        } else {
          _param = c < 0 ? param[/* l */0] : param[/* r */3];
          continue ;
        }
      } else {
        return false;
      }
    }  };
  var min_binding = function (_param) {
    while(true) {
      var param = _param;
      if (param) {
        var l = param[/* l */0];
        if (l) {
          _param = l;
          continue ;
        } else {
          return /* tuple */[
                  param[/* v */1],
                  param[/* d */2]
                ];
        }
      } else {
        throw caml_builtin_exceptions.not_found;
      }
    }  };
  var min_binding_opt = function (_param) {
    while(true) {
      var param = _param;
      if (param) {
        var l = param[/* l */0];
        if (l) {
          _param = l;
          continue ;
        } else {
          return /* tuple */[
                  param[/* v */1],
                  param[/* d */2]
                ];
        }
      } else {
        return ;
      }
    }  };
  var max_binding = function (_param) {
    while(true) {
      var param = _param;
      if (param) {
        var r = param[/* r */3];
        if (r) {
          _param = r;
          continue ;
        } else {
          return /* tuple */[
                  param[/* v */1],
                  param[/* d */2]
                ];
        }
      } else {
        throw caml_builtin_exceptions.not_found;
      }
    }  };
  var max_binding_opt = function (_param) {
    while(true) {
      var param = _param;
      if (param) {
        var r = param[/* r */3];
        if (r) {
          _param = r;
          continue ;
        } else {
          return /* tuple */[
                  param[/* v */1],
                  param[/* d */2]
                ];
        }
      } else {
        return ;
      }
    }  };
  var remove_min_binding = function (param) {
    if (param) {
      var l = param[/* l */0];
      if (l) {
        return bal(remove_min_binding(l), param[/* v */1], param[/* d */2], param[/* r */3]);
      } else {
        return param[/* r */3];
      }
    } else {
      throw [
            caml_builtin_exceptions.invalid_argument,
            "Map.remove_min_elt"
          ];
    }
  };
  var merge = function (t1, t2) {
    if (t1) {
      if (t2) {
        var match = min_binding(t2);
        return bal(t1, match[0], match[1], remove_min_binding(t2));
      } else {
        return t1;
      }
    } else {
      return t2;
    }
  };
  var remove = function (x, m) {
    if (m) {
      var r = m[/* r */3];
      var d = m[/* d */2];
      var v = m[/* v */1];
      var l = m[/* l */0];
      var c = curry._2(funarg.compare, x, v);
      if (c === 0) {
        return merge(l, r);
      } else if (c < 0) {
        var ll = remove(x, l);
        if (l === ll) {
          return m;
        } else {
          return bal(ll, v, d, r);
        }
      } else {
        var rr = remove(x, r);
        if (r === rr) {
          return m;
        } else {
          return bal(l, v, d, rr);
        }
      }
    } else {
      return /* Empty */0;
    }
  };
  var update = function (x, f, m) {
    if (m) {
      var r = m[/* r */3];
      var d = m[/* d */2];
      var v = m[/* v */1];
      var l = m[/* l */0];
      var c = curry._2(funarg.compare, x, v);
      if (c === 0) {
        var match = curry._1(f, caml_option.some(d));
        if (match !== undefined) {
          var data = caml_option.valFromOption(match);
          if (d === data) {
            return m;
          } else {
            return /* Node */[
                    /* l */l,
                    /* v */x,
                    /* d */data,
                    /* r */r,
                    /* h */m[/* h */4]
                  ];
          }
        } else {
          return merge(l, r);
        }
      } else if (c < 0) {
        var ll = update(x, f, l);
        if (l === ll) {
          return m;
        } else {
          return bal(ll, v, d, r);
        }
      } else {
        var rr = update(x, f, r);
        if (r === rr) {
          return m;
        } else {
          return bal(l, v, d, rr);
        }
      }
    } else {
      var match$1 = curry._1(f, undefined);
      if (match$1 !== undefined) {
        return /* Node */[
                /* l : Empty */0,
                /* v */x,
                /* d */caml_option.valFromOption(match$1),
                /* r : Empty */0,
                /* h */1
              ];
      } else {
        return /* Empty */0;
      }
    }
  };
  var iter = function (f, _param) {
    while(true) {
      var param = _param;
      if (param) {
        iter(f, param[/* l */0]);
        curry._2(f, param[/* v */1], param[/* d */2]);
        _param = param[/* r */3];
        continue ;
      } else {
        return /* () */0;
      }
    }  };
  var map = function (f, param) {
    if (param) {
      var l$prime = map(f, param[/* l */0]);
      var d$prime = curry._1(f, param[/* d */2]);
      var r$prime = map(f, param[/* r */3]);
      return /* Node */[
              /* l */l$prime,
              /* v */param[/* v */1],
              /* d */d$prime,
              /* r */r$prime,
              /* h */param[/* h */4]
            ];
    } else {
      return /* Empty */0;
    }
  };
  var mapi = function (f, param) {
    if (param) {
      var v = param[/* v */1];
      var l$prime = mapi(f, param[/* l */0]);
      var d$prime = curry._2(f, v, param[/* d */2]);
      var r$prime = mapi(f, param[/* r */3]);
      return /* Node */[
              /* l */l$prime,
              /* v */v,
              /* d */d$prime,
              /* r */r$prime,
              /* h */param[/* h */4]
            ];
    } else {
      return /* Empty */0;
    }
  };
  var fold = function (f, _m, _accu) {
    while(true) {
      var accu = _accu;
      var m = _m;
      if (m) {
        _accu = curry._3(f, m[/* v */1], m[/* d */2], fold(f, m[/* l */0], accu));
        _m = m[/* r */3];
        continue ;
      } else {
        return accu;
      }
    }  };
  var for_all = function (p, _param) {
    while(true) {
      var param = _param;
      if (param) {
        if (curry._2(p, param[/* v */1], param[/* d */2]) && for_all(p, param[/* l */0])) {
          _param = param[/* r */3];
          continue ;
        } else {
          return false;
        }
      } else {
        return true;
      }
    }  };
  var exists = function (p, _param) {
    while(true) {
      var param = _param;
      if (param) {
        if (curry._2(p, param[/* v */1], param[/* d */2]) || exists(p, param[/* l */0])) {
          return true;
        } else {
          _param = param[/* r */3];
          continue ;
        }
      } else {
        return false;
      }
    }  };
  var add_min_binding = function (k, x, param) {
    if (param) {
      return bal(add_min_binding(k, x, param[/* l */0]), param[/* v */1], param[/* d */2], param[/* r */3]);
    } else {
      return singleton(k, x);
    }
  };
  var add_max_binding = function (k, x, param) {
    if (param) {
      return bal(param[/* l */0], param[/* v */1], param[/* d */2], add_max_binding(k, x, param[/* r */3]));
    } else {
      return singleton(k, x);
    }
  };
  var join = function (l, v, d, r) {
    if (l) {
      if (r) {
        var rh = r[/* h */4];
        var lh = l[/* h */4];
        if (lh > (rh + 2 | 0)) {
          return bal(l[/* l */0], l[/* v */1], l[/* d */2], join(l[/* r */3], v, d, r));
        } else if (rh > (lh + 2 | 0)) {
          return bal(join(l, v, d, r[/* l */0]), r[/* v */1], r[/* d */2], r[/* r */3]);
        } else {
          return create(l, v, d, r);
        }
      } else {
        return add_max_binding(v, d, l);
      }
    } else {
      return add_min_binding(v, d, r);
    }
  };
  var concat = function (t1, t2) {
    if (t1) {
      if (t2) {
        var match = min_binding(t2);
        return join(t1, match[0], match[1], remove_min_binding(t2));
      } else {
        return t1;
      }
    } else {
      return t2;
    }
  };
  var concat_or_join = function (t1, v, d, t2) {
    if (d !== undefined) {
      return join(t1, v, caml_option.valFromOption(d), t2);
    } else {
      return concat(t1, t2);
    }
  };
  var split = function (x, param) {
    if (param) {
      var r = param[/* r */3];
      var d = param[/* d */2];
      var v = param[/* v */1];
      var l = param[/* l */0];
      var c = curry._2(funarg.compare, x, v);
      if (c === 0) {
        return /* tuple */[
                l,
                caml_option.some(d),
                r
              ];
      } else if (c < 0) {
        var match = split(x, l);
        return /* tuple */[
                match[0],
                match[1],
                join(match[2], v, d, r)
              ];
      } else {
        var match$1 = split(x, r);
        return /* tuple */[
                join(l, v, d, match$1[0]),
                match$1[1],
                match$1[2]
              ];
      }
    } else {
      return /* tuple */[
              /* Empty */0,
              undefined,
              /* Empty */0
            ];
    }
  };
  var merge$1 = function (f, s1, s2) {
    if (s1) {
      var v1 = s1[/* v */1];
      if (s1[/* h */4] >= height(s2)) {
        var match = split(v1, s2);
        return concat_or_join(merge$1(f, s1[/* l */0], match[0]), v1, curry._3(f, v1, caml_option.some(s1[/* d */2]), match[1]), merge$1(f, s1[/* r */3], match[2]));
      }
      
    } else if (!s2) {
      return /* Empty */0;
    }
    if (s2) {
      var v2 = s2[/* v */1];
      var match$1 = split(v2, s1);
      return concat_or_join(merge$1(f, match$1[0], s2[/* l */0]), v2, curry._3(f, v2, match$1[1], caml_option.some(s2[/* d */2])), merge$1(f, match$1[2], s2[/* r */3]));
    } else {
      throw [
            caml_builtin_exceptions.assert_failure,
            /* tuple */[
              "map.ml",
              393,
              10
            ]
          ];
    }
  };
  var union = function (f, s1, s2) {
    if (s1) {
      if (s2) {
        var d2 = s2[/* d */2];
        var v2 = s2[/* v */1];
        var d1 = s1[/* d */2];
        var v1 = s1[/* v */1];
        if (s1[/* h */4] >= s2[/* h */4]) {
          var match = split(v1, s2);
          var d2$1 = match[1];
          var l = union(f, s1[/* l */0], match[0]);
          var r = union(f, s1[/* r */3], match[2]);
          if (d2$1 !== undefined) {
            return concat_or_join(l, v1, curry._3(f, v1, d1, caml_option.valFromOption(d2$1)), r);
          } else {
            return join(l, v1, d1, r);
          }
        } else {
          var match$1 = split(v2, s1);
          var d1$1 = match$1[1];
          var l$1 = union(f, match$1[0], s2[/* l */0]);
          var r$1 = union(f, match$1[2], s2[/* r */3]);
          if (d1$1 !== undefined) {
            return concat_or_join(l$1, v2, curry._3(f, v2, caml_option.valFromOption(d1$1), d2), r$1);
          } else {
            return join(l$1, v2, d2, r$1);
          }
        }
      } else {
        return s1;
      }
    } else {
      return s2;
    }
  };
  var filter = function (p, m) {
    if (m) {
      var r = m[/* r */3];
      var d = m[/* d */2];
      var v = m[/* v */1];
      var l = m[/* l */0];
      var l$prime = filter(p, l);
      var pvd = curry._2(p, v, d);
      var r$prime = filter(p, r);
      if (pvd) {
        if (l === l$prime && r === r$prime) {
          return m;
        } else {
          return join(l$prime, v, d, r$prime);
        }
      } else {
        return concat(l$prime, r$prime);
      }
    } else {
      return /* Empty */0;
    }
  };
  var partition = function (p, param) {
    if (param) {
      var d = param[/* d */2];
      var v = param[/* v */1];
      var match = partition(p, param[/* l */0]);
      var lf = match[1];
      var lt = match[0];
      var pvd = curry._2(p, v, d);
      var match$1 = partition(p, param[/* r */3]);
      var rf = match$1[1];
      var rt = match$1[0];
      if (pvd) {
        return /* tuple */[
                join(lt, v, d, rt),
                concat(lf, rf)
              ];
      } else {
        return /* tuple */[
                concat(lt, rt),
                join(lf, v, d, rf)
              ];
      }
    } else {
      return /* tuple */[
              /* Empty */0,
              /* Empty */0
            ];
    }
  };
  var cons_enum = function (_m, _e) {
    while(true) {
      var e = _e;
      var m = _m;
      if (m) {
        _e = /* More */[
          m[/* v */1],
          m[/* d */2],
          m[/* r */3],
          e
        ];
        _m = m[/* l */0];
        continue ;
      } else {
        return e;
      }
    }  };
  var compare = function (cmp, m1, m2) {
    var _e1 = cons_enum(m1, /* End */0);
    var _e2 = cons_enum(m2, /* End */0);
    while(true) {
      var e2 = _e2;
      var e1 = _e1;
      if (e1) {
        if (e2) {
          var c = curry._2(funarg.compare, e1[0], e2[0]);
          if (c !== 0) {
            return c;
          } else {
            var c$1 = curry._2(cmp, e1[1], e2[1]);
            if (c$1 !== 0) {
              return c$1;
            } else {
              _e2 = cons_enum(e2[2], e2[3]);
              _e1 = cons_enum(e1[2], e1[3]);
              continue ;
            }
          }
        } else {
          return 1;
        }
      } else if (e2) {
        return -1;
      } else {
        return 0;
      }
    }  };
  var equal = function (cmp, m1, m2) {
    var _e1 = cons_enum(m1, /* End */0);
    var _e2 = cons_enum(m2, /* End */0);
    while(true) {
      var e2 = _e2;
      var e1 = _e1;
      if (e1) {
        if (e2 && curry._2(funarg.compare, e1[0], e2[0]) === 0 && curry._2(cmp, e1[1], e2[1])) {
          _e2 = cons_enum(e2[2], e2[3]);
          _e1 = cons_enum(e1[2], e1[3]);
          continue ;
        } else {
          return false;
        }
      } else if (e2) {
        return false;
      } else {
        return true;
      }
    }  };
  var cardinal = function (param) {
    if (param) {
      return (cardinal(param[/* l */0]) + 1 | 0) + cardinal(param[/* r */3]) | 0;
    } else {
      return 0;
    }
  };
  var bindings_aux = function (_accu, _param) {
    while(true) {
      var param = _param;
      var accu = _accu;
      if (param) {
        _param = param[/* l */0];
        _accu = /* :: */[
          /* tuple */[
            param[/* v */1],
            param[/* d */2]
          ],
          bindings_aux(accu, param[/* r */3])
        ];
        continue ;
      } else {
        return accu;
      }
    }  };
  var bindings = function (s) {
    return bindings_aux(/* [] */0, s);
  };
  return {
          empty: /* Empty */0,
          is_empty: is_empty,
          mem: mem,
          add: add,
          update: update,
          singleton: singleton,
          remove: remove,
          merge: merge$1,
          union: union,
          compare: compare,
          equal: equal,
          iter: iter,
          fold: fold,
          for_all: for_all,
          exists: exists,
          filter: filter,
          partition: partition,
          cardinal: cardinal,
          bindings: bindings,
          min_binding: min_binding,
          min_binding_opt: min_binding_opt,
          max_binding: max_binding,
          max_binding_opt: max_binding_opt,
          choose: min_binding,
          choose_opt: min_binding_opt,
          split: split,
          find: find,
          find_opt: find_opt,
          find_first: find_first,
          find_first_opt: find_first_opt,
          find_last: find_last,
          find_last_opt: find_last_opt,
          map: map,
          mapi: mapi
        };
}

var Make_1 = Make;
/* No side effect */

var map$8 = {
	Make: Make_1
};

var Cmap = map$8.Make({
      compare: char_1.compare
    });

var empty_succs = Cmap.empty;

var empty$1 = {
  v: /* Nil */1,
  succs: empty_succs
};

function is_empty(t) {
  return caml_obj.caml_equal(t, empty$1);
}

function add$1(t, k, d) {
  var loop = function (t, k, len, i, d, pre_d) {
    var match = i === len;
    if (match) {
      var t$prime_v = /* Key */block.__(1, [d]);
      var t$prime_succs = t.succs;
      var t$prime = {
        v: t$prime_v,
        succs: t$prime_succs
      };
      var match$1 = t.v;
      if (typeof match$1 === "number" || match$1.tag !== /* Key */1) {
        return /* `New */[
                3901504,
                t$prime
              ];
      } else {
        return /* `Replaced */[
                -238509616,
                /* tuple */[
                  match$1[0],
                  t$prime
                ]
              ];
      }
    } else {
      var v = t.v;
      var v$1;
      v$1 = typeof v === "number" ? (
          v === /* Amb */0 ? /* Amb */0 : pre_d
        ) : (
          v.tag ? v : /* Amb */0
        );
      var t$prime$1;
      try {
        t$prime$1 = curry._2(Cmap.find, caml_string.get(k, i), t.succs);
      }
      catch (exn){
        if (exn === caml_builtin_exceptions.not_found) {
          t$prime$1 = empty$1;
        } else {
          throw exn;
        }
      }
      var match$2 = loop(t$prime$1, k, len, i + 1 | 0, d, pre_d);
      if (match$2[0] >= 3901504) {
        return /* `New */[
                3901504,
                {
                  v: v$1,
                  succs: curry._3(Cmap.add, caml_string.get(k, i), match$2[1], t.succs)
                }
              ];
      } else {
        var match$3 = match$2[1];
        return /* `Replaced */[
                -238509616,
                /* tuple */[
                  match$3[0],
                  {
                    v: v$1,
                    succs: curry._3(Cmap.add, caml_string.get(k, i), match$3[1], t.succs)
                  }
                ]
              ];
      }
    }
  };
  return loop(t, k, k.length, 0, d, /* Pre */block.__(0, [d]));
}

function find_node(t, k) {
  var _t = t;
  var k$1 = k;
  var len = k.length;
  var _i = 0;
  while(true) {
    var i = _i;
    var t$1 = _t;
    if (i === len) {
      return t$1;
    } else {
      _i = i + 1 | 0;
      _t = curry._2(Cmap.find, caml_string.get(k$1, i), t$1.succs);
      continue ;
    }
  }}

function find$1(t, k) {
  try {
    var match = find_node(t, k).v;
    if (typeof match === "number") {
      if (match !== 0) {
        return /* Not_found */-358247754;
      } else {
        return /* Ambiguous */-328798100;
      }
    } else {
      return /* `Ok */[
              17724,
              match[0]
            ];
    }
  }
  catch (exn){
    if (exn === caml_builtin_exceptions.not_found) {
      return /* Not_found */-358247754;
    } else {
      throw exn;
    }
  }
}

function ambiguities(t, p) {
  try {
    var t$1 = find_node(t, p);
    var match = t$1.v;
    if (typeof match === "number" && match === 0) {
      var add_char = function (s, c) {
        return s + string.make(1, c);
      };
      var rem_char = function (s) {
        return string.sub(s, 0, s.length - 1 | 0);
      };
      var to_list = function (m) {
        return curry._3(Cmap.fold, (function (k, t, acc) {
                      return /* :: */[
                              /* tuple */[
                                k,
                                t
                              ],
                              acc
                            ];
                    }), m, /* [] */0);
      };
      var _acc = /* [] */0;
      var _p = p;
      var _param = /* :: */[
        to_list(t$1.succs),
        /* [] */0
      ];
      while(true) {
        var param = _param;
        var p$1 = _p;
        var acc = _acc;
        if (param) {
          var match$1 = param[0];
          if (match$1) {
            var match$2 = match$1[0];
            var t$2 = match$2[1];
            var p$prime = add_char(p$1, match$2[0]);
            var match$3 = t$2.v;
            var acc$prime;
            if (typeof match$3 === "number") {
              if (match$3 === /* Amb */0) {
                acc$prime = acc;
              } else {
                throw [
                      caml_builtin_exceptions.assert_failure,
                      /* tuple */[
                        "cmdliner_trie.ml",
                        69,
                        21
                      ]
                    ];
              }
            } else {
              acc$prime = match$3.tag ? /* :: */[
                  p$prime,
                  acc
                ] : acc;
            }
            _param = /* :: */[
              to_list(t$2.succs),
              /* :: */[
                match$1[1],
                param[1]
              ]
            ];
            _p = p$prime;
            _acc = acc$prime;
            continue ;
          } else {
            var rest = param[1];
            if (rest) {
              _param = rest;
              _p = rem_char(p$1);
              continue ;
            } else {
              return acc;
            }
          }
        } else {
          throw [
                caml_builtin_exceptions.assert_failure,
                /* tuple */[
                  "cmdliner_trie.ml",
                  74,
                  16
                ]
              ];
        }
      };
    } else {
      return /* [] */0;
    }
  }
  catch (exn){
    if (exn === caml_builtin_exceptions.not_found) {
      return /* [] */0;
    } else {
      throw exn;
    }
  }
}

function of_list$1(l) {
  var add$1$1 = function (t, param) {
    var match = add$1(t, param[0], param[1]);
    if (match[0] >= 3901504) {
      return match[1];
    } else {
      return match[1][1];
    }
  };
  return list.fold_left(add$1$1, empty$1, l);
}

var empty_1$1 = empty$1;
var is_empty_1 = is_empty;
var add_1$1 = add$1;
var find_1$1 = find$1;
var ambiguities_1 = ambiguities;
var of_list_1$1 = of_list$1;
/* Cmap Not a pure module */

var cmdliner_trie_bs = {
	empty: empty_1$1,
	is_empty: is_empty_1,
	add: add_1$1,
	find: find_1$1,
	ambiguities: ambiguities_1,
	of_list: of_list_1$1
};

var err_empty_list = "empty list";

function pp_lines(ppf, s) {
  var stop_at = function (sat, _start, max, s) {
    while(true) {
      var start = _start;
      if (start > max || curry._1(sat, caml_string.get(s, start))) {
        return start;
      } else {
        _start = start + 1 | 0;
        continue ;
      }
    }  };
  var sub = function (s, start, stop, max) {
    if (start === stop) {
      return "";
    } else if (start === 0 && stop > max) {
      return s;
    } else {
      return string.sub(s, start, stop - start | 0);
    }
  };
  var is_nl = function (c) {
    return c === /* "\n" */10;
  };
  var max = s.length - 1 | 0;
  var _start = 0;
  var s$1 = s;
  while(true) {
    var start = _start;
    var stop = stop_at(is_nl, start, max, s$1);
    if (stop > max) {
      return format.pp_print_string(ppf, sub(s$1, start, stop, max));
    } else {
      format.pp_print_string(ppf, sub(s$1, start, stop, max));
      format.pp_force_newline(ppf, /* () */0);
      _start = stop + 1 | 0;
      continue ;
    }
  }}

function pp_tokens(spaces, ppf, s) {
  var is_space = function (param) {
    var switcher = param - 9 | 0;
    if (switcher > 4 || switcher < 0) {
      return switcher === 23;
    } else {
      return !(switcher === 3 || switcher === 2);
    }
  };
  var i_max = s.length - 1 | 0;
  var flush = function (start, stop) {
    return format.pp_print_string(ppf, string.sub(s, start, (stop - start | 0) + 1 | 0));
  };
  var skip_white = function (_i) {
    while(true) {
      var i = _i;
      if (i > i_max || !is_space(caml_string.get(s, i))) {
        return i;
      } else {
        _i = i + 1 | 0;
        continue ;
      }
    }  };
  var _start = 0;
  var _i = 0;
  while(true) {
    var i = _i;
    var start = _start;
    if (i > i_max) {
      return flush(start, i_max);
    } else if (is_space(caml_string.get(s, i))) {
      var next_start = skip_white(i);
      flush(start, i - 1 | 0);
      if (spaces) {
        format.pp_print_space(ppf, /* () */0);
      } else {
        format.pp_print_char(ppf, /* " " */32);
      }
      if (next_start > i_max) {
        return /* () */0;
      } else {
        _i = next_start;
        _start = next_start;
        continue ;
      }
    } else {
      _i = i + 1 | 0;
      continue ;
    }
  }}

function quote$2(s) {
  return curry._1(printf_1.sprintf(/* Format */[
                  /* Char_literal */block.__(12, [
                      /* "`" */96,
                      /* String */block.__(2, [
                          /* No_padding */0,
                          /* Char_literal */block.__(12, [
                              /* "'" */39,
                              /* End_of_format */0
                            ])
                        ])
                    ]),
                  "`%s'"
                ]), s);
}

function alts_str($staropt$star, alts) {
  var quoted = $staropt$star !== undefined ? $staropt$star : true;
  var quote$1 = quoted ? quote$2 : (function (s) {
        return s;
      });
  if (alts) {
    var match = alts[1];
    var a = alts[0];
    if (match) {
      if (match[1]) {
        var rev_alts = list.rev(alts);
        return curry._2(printf_1.sprintf(/* Format */[
                        /* String_literal */block.__(11, [
                            "one of ",
                            /* String */block.__(2, [
                                /* No_padding */0,
                                /* String_literal */block.__(11, [
                                    " or ",
                                    /* String */block.__(2, [
                                        /* No_padding */0,
                                        /* End_of_format */0
                                      ])
                                  ])
                              ])
                          ]),
                        "one of %s or %s"
                      ]), string.concat(", ", list.rev_map(quote$1, list.tl(rev_alts))), curry._1(quote$1, list.hd(rev_alts)));
      } else {
        return curry._2(printf_1.sprintf(/* Format */[
                        /* String_literal */block.__(11, [
                            "either ",
                            /* String */block.__(2, [
                                /* No_padding */0,
                                /* String_literal */block.__(11, [
                                    " or ",
                                    /* String */block.__(2, [
                                        /* No_padding */0,
                                        /* End_of_format */0
                                      ])
                                  ])
                              ])
                          ]),
                        "either %s or %s"
                      ]), curry._1(quote$1, a), curry._1(quote$1, match[0]));
      }
    } else {
      return curry._1(quote$1, a);
    }
  } else {
    return pervasives.invalid_arg(err_empty_list);
  }
}

function err_multi_def(kind, name, doc, v, v$prime) {
  return curry._4(printf_1.sprintf(/* Format */[
                  /* String */block.__(2, [
                      /* No_padding */0,
                      /* Char_literal */block.__(12, [
                          /* " " */32,
                          /* String */block.__(2, [
                              /* No_padding */0,
                              /* String_literal */block.__(11, [
                                  " defined twice (doc strings are '",
                                  /* String */block.__(2, [
                                      /* No_padding */0,
                                      /* String_literal */block.__(11, [
                                          "' and '",
                                          /* String */block.__(2, [
                                              /* No_padding */0,
                                              /* String_literal */block.__(11, [
                                                  "')",
                                                  /* End_of_format */0
                                                ])
                                            ])
                                        ])
                                    ])
                                ])
                            ])
                        ])
                    ]),
                  "%s %s defined twice (doc strings are '%s' and '%s')"
                ]), kind, name, curry._1(doc, v), curry._1(doc, v$prime));
}

function err_ambiguous(kind, s, ambs) {
  return curry._3(printf_1.sprintf(/* Format */[
                  /* String */block.__(2, [
                      /* No_padding */0,
                      /* Char_literal */block.__(12, [
                          /* " " */32,
                          /* String */block.__(2, [
                              /* No_padding */0,
                              /* String_literal */block.__(11, [
                                  " ambiguous and could be ",
                                  /* String */block.__(2, [
                                      /* No_padding */0,
                                      /* End_of_format */0
                                    ])
                                ])
                            ])
                        ])
                    ]),
                  "%s %s ambiguous and could be %s"
                ]), kind, quote$2(s), alts_str(undefined, ambs));
}

function err_unknown($staropt$star, kind, v) {
  var hints = $staropt$star !== undefined ? $staropt$star : /* [] */0;
  var did_you_mean = function (s) {
    return curry._1(printf_1.sprintf(/* Format */[
                    /* String_literal */block.__(11, [
                        ", did you mean ",
                        /* String */block.__(2, [
                            /* No_padding */0,
                            /* String_literal */block.__(11, [
                                " ?",
                                /* End_of_format */0
                              ])
                          ])
                      ]),
                    ", did you mean %s ?"
                  ]), s);
  };
  var hints$1 = hints ? did_you_mean(alts_str(undefined, hints)) : ".";
  return curry._3(printf_1.sprintf(/* Format */[
                  /* String_literal */block.__(11, [
                      "unknown ",
                      /* String */block.__(2, [
                          /* No_padding */0,
                          /* Char_literal */block.__(12, [
                              /* " " */32,
                              /* String */block.__(2, [
                                  /* No_padding */0,
                                  /* String */block.__(2, [
                                      /* No_padding */0,
                                      /* End_of_format */0
                                    ])
                                ])
                            ])
                        ])
                    ]),
                  "unknown %s %s%s"
                ]), kind, quote$2(v), hints$1);
}

function err_no(kind, s) {
  return curry._2(printf_1.sprintf(/* Format */[
                  /* String_literal */block.__(11, [
                      "no ",
                      /* String */block.__(2, [
                          /* No_padding */0,
                          /* Char_literal */block.__(12, [
                              /* " " */32,
                              /* String */block.__(2, [
                                  /* No_padding */0,
                                  /* End_of_format */0
                                ])
                            ])
                        ])
                    ]),
                  "no %s %s"
                ]), quote$2(s), kind);
}

function err_not_dir(s) {
  return curry._1(printf_1.sprintf(/* Format */[
                  /* String */block.__(2, [
                      /* No_padding */0,
                      /* String_literal */block.__(11, [
                          " is not a directory",
                          /* End_of_format */0
                        ])
                    ]),
                  "%s is not a directory"
                ]), quote$2(s));
}

function err_is_dir(s) {
  return curry._1(printf_1.sprintf(/* Format */[
                  /* String */block.__(2, [
                      /* No_padding */0,
                      /* String_literal */block.__(11, [
                          " is a directory",
                          /* End_of_format */0
                        ])
                    ]),
                  "%s is a directory"
                ]), quote$2(s));
}

function err_element(kind, s, exp) {
  return curry._3(printf_1.sprintf(/* Format */[
                  /* String_literal */block.__(11, [
                      "invalid element in ",
                      /* String */block.__(2, [
                          /* No_padding */0,
                          /* String_literal */block.__(11, [
                              " (`",
                              /* String */block.__(2, [
                                  /* No_padding */0,
                                  /* String_literal */block.__(11, [
                                      "'): ",
                                      /* String */block.__(2, [
                                          /* No_padding */0,
                                          /* End_of_format */0
                                        ])
                                    ])
                                ])
                            ])
                        ])
                    ]),
                  "invalid element in %s (`%s'): %s"
                ]), kind, s, exp);
}

function err_invalid(kind, s, exp) {
  return curry._3(printf_1.sprintf(/* Format */[
                  /* String_literal */block.__(11, [
                      "invalid ",
                      /* String */block.__(2, [
                          /* No_padding */0,
                          /* Char_literal */block.__(12, [
                              /* " " */32,
                              /* String */block.__(2, [
                                  /* No_padding */0,
                                  /* String_literal */block.__(11, [
                                      ", ",
                                      /* String */block.__(2, [
                                          /* No_padding */0,
                                          /* End_of_format */0
                                        ])
                                    ])
                                ])
                            ])
                        ])
                    ]),
                  "invalid %s %s, %s"
                ]), kind, quote$2(s), exp);
}

function err_sep_miss(sep, s) {
  return err_invalid("value", s, curry._1(printf_1.sprintf(/* Format */[
                      /* String_literal */block.__(11, [
                          "missing a `",
                          /* Char */block.__(0, [/* String_literal */block.__(11, [
                                  "' separator",
                                  /* End_of_format */0
                                ])])
                        ]),
                      "missing a `%c' separator"
                    ]), sep));
}

function some$1($staropt$star, param) {
  var print = param[1];
  var parse = param[0];
  var none = $staropt$star !== undefined ? $staropt$star : "";
  var parse$1 = function (s) {
    var e = curry._1(parse, s);
    if (e[0] >= 106380200) {
      return e;
    } else {
      return /* `Ok */[
              17724,
              caml_option.some(e[1])
            ];
    }
  };
  var print$1 = function (ppf, v) {
    if (v !== undefined) {
      return curry._2(print, ppf, caml_option.valFromOption(v));
    } else {
      return format.pp_print_string(ppf, none);
    }
  };
  return /* tuple */[
          parse$1,
          print$1
        ];
}

function parse$2(s) {
  try {
    return /* `Ok */[
            17724,
            pervasives.bool_of_string(s)
          ];
  }
  catch (raw_exn){
    var exn = caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] === caml_builtin_exceptions.invalid_argument) {
      return /* `Error */[
              106380200,
              err_invalid("value", s, alts_str(undefined, /* :: */[
                        "true",
                        /* :: */[
                          "false",
                          /* [] */0
                        ]
                      ]))
            ];
    } else {
      throw exn;
    }
  }
}

var bool$3 = /* tuple */[
  parse$2,
  format.pp_print_bool
];

function parse$1$1(s) {
  var match = s.length === 1;
  if (match) {
    return /* `Ok */[
            17724,
            caml_string.get(s, 0)
          ];
  } else {
    return /* `Error */[
            106380200,
            err_invalid("value", s, "expected a character")
          ];
  }
}

var $$char$1 = /* tuple */[
  parse$1$1,
  format.pp_print_char
];

function parse_with(t_of_str, exp, s) {
  try {
    return /* `Ok */[
            17724,
            curry._1(t_of_str, s)
          ];
  }
  catch (raw_exn){
    var exn = caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] === caml_builtin_exceptions.failure) {
      return /* `Error */[
              106380200,
              err_invalid("value", s, exp)
            ];
    } else {
      throw exn;
    }
  }
}

function int_000(param) {
  return parse_with(caml_format.caml_int_of_string, "expected an integer", param);
}

var $$int$3 = /* tuple */[
  int_000,
  format.pp_print_int
];

function int32_000(param) {
  return parse_with(caml_format.caml_int32_of_string, "expected a 32-bit integer", param);
}

function int32_001(ppf) {
  return format.fprintf(ppf, /* Format */[
              /* Int32 */block.__(5, [
                  /* Int_d */0,
                  /* No_padding */0,
                  /* No_precision */0,
                  /* End_of_format */0
                ]),
              "%ld"
            ]);
}

var int32$2 = /* tuple */[
  int32_000,
  int32_001
];

function int64_000(param) {
  return parse_with(caml_format.caml_int64_of_string, "expected a 64-bit integer", param);
}

function int64_001(ppf) {
  return format.fprintf(ppf, /* Format */[
              /* Int64 */block.__(7, [
                  /* Int_d */0,
                  /* No_padding */0,
                  /* No_precision */0,
                  /* End_of_format */0
                ]),
              "%Ld"
            ]);
}

var int64$2 = /* tuple */[
  int64_000,
  int64_001
];

function nativeint_000(param) {
  return parse_with(caml_format.caml_nativeint_of_string, "expected a processor-native integer", param);
}

function nativeint_001(ppf) {
  return format.fprintf(ppf, /* Format */[
              /* Nativeint */block.__(6, [
                  /* Int_d */0,
                  /* No_padding */0,
                  /* No_precision */0,
                  /* End_of_format */0
                ]),
              "%nd"
            ]);
}

var nativeint$2 = /* tuple */[
  nativeint_000,
  nativeint_001
];

function float_000(param) {
  return parse_with(caml_format.caml_float_of_string, "expected a floating point number", param);
}

var $$float$3 = /* tuple */[
  float_000,
  format.pp_print_float
];

function string_000(s) {
  return /* `Ok */[
          17724,
          s
        ];
}

var string$3 = /* tuple */[
  string_000,
  format.pp_print_string
];

function $$enum(sl) {
  if (sl === /* [] */0) {
    return pervasives.invalid_arg(err_empty_list);
  } else {
    var t = cmdliner_trie_bs.of_list(sl);
    var parse = function (s) {
      var r = cmdliner_trie_bs.find(t, s);
      if (typeof r === "number") {
        if (r >= -328798100) {
          var ambs = list.sort(caml_primitive.caml_string_compare, cmdliner_trie_bs.ambiguities(t, s));
          return /* `Error */[
                  106380200,
                  err_ambiguous("enum value", s, ambs)
                ];
        } else {
          var alts = list.rev(list.rev_map((function (param) {
                      return param[0];
                    }), sl));
          return /* `Error */[
                  106380200,
                  err_invalid("value", s, "expected " + alts_str(undefined, alts))
                ];
        }
      } else {
        return r;
      }
    };
    var print = function (ppf, v) {
      var sl_inv = list.rev_map((function (param) {
              return /* tuple */[
                      param[1],
                      param[0]
                    ];
            }), sl);
      try {
        return format.pp_print_string(ppf, list.assoc(v, sl_inv));
      }
      catch (exn){
        if (exn === caml_builtin_exceptions.not_found) {
          return pervasives.invalid_arg("Incomplete enumeration for the type");
        } else {
          throw exn;
        }
      }
    };
    return /* tuple */[
            parse,
            print
          ];
  }
}

function parse$2$1(s) {
  var match = caml_external_polyfill.resolve("caml_sys_file_exists")(s);
  if (match) {
    return /* `Ok */[
            17724,
            s
          ];
  } else {
    return /* `Error */[
            106380200,
            err_no("file or directory", s)
          ];
  }
}

var file$1 = /* tuple */[
  parse$2$1,
  format.pp_print_string
];

function parse$3(s) {
  var match = caml_external_polyfill.resolve("caml_sys_file_exists")(s);
  if (match) {
    if (caml_sys.caml_sys_is_directory(s)) {
      return /* `Ok */[
              17724,
              s
            ];
    } else {
      return /* `Error */[
              106380200,
              err_not_dir(s)
            ];
    }
  } else {
    return /* `Error */[
            106380200,
            err_no("directory", s)
          ];
  }
}

var dir = /* tuple */[
  parse$3,
  format.pp_print_string
];

function parse$4(s) {
  var match = caml_external_polyfill.resolve("caml_sys_file_exists")(s);
  if (match) {
    if (caml_sys.caml_sys_is_directory(s)) {
      return /* `Error */[
              106380200,
              err_is_dir(s)
            ];
    } else {
      return /* `Ok */[
              17724,
              s
            ];
    }
  } else {
    return /* `Error */[
            106380200,
            err_no("file", s)
          ];
  }
}

var non_dir_file = /* tuple */[
  parse$4,
  format.pp_print_string
];

function split_and_parse(sep, parse, s) {
  var parse$1 = function (sub) {
    var match = curry._1(parse, sub);
    if (match[0] >= 106380200) {
      return pervasives.failwith(match[1]);
    } else {
      return match[1];
    }
  };
  var _accum = /* [] */0;
  var _j = s.length - 1 | 0;
  while(true) {
    var j = _j;
    var accum = _accum;
    var i;
    try {
      i = string.rindex_from(s, j, sep);
    }
    catch (exn){
      if (exn === caml_builtin_exceptions.not_found) {
        i = -1;
      } else {
        throw exn;
      }
    }
    if (i === -1) {
      var p = string.sub(s, 0, j + 1 | 0);
      if (p !== "") {
        return /* :: */[
                parse$1(p),
                accum
              ];
      } else {
        return accum;
      }
    } else {
      var p$1 = string.sub(s, i + 1 | 0, j - i | 0);
      var accum$prime = p$1 !== "" ? /* :: */[
          parse$1(p$1),
          accum
        ] : accum;
      _j = i - 1 | 0;
      _accum = accum$prime;
      continue ;
    }
  }}

function list$2($staropt$star, param) {
  var pp_e = param[1];
  var parse = param[0];
  var sep = $staropt$star !== undefined ? $staropt$star : /* "," */44;
  var parse$1 = function (s) {
    try {
      return /* `Ok */[
              17724,
              split_and_parse(sep, parse, s)
            ];
    }
    catch (raw_exn){
      var exn = caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn[0] === caml_builtin_exceptions.failure) {
        return /* `Error */[
                106380200,
                err_element("list", s, exn[1])
              ];
      } else {
        throw exn;
      }
    }
  };
  var print = function (ppf, _param) {
    while(true) {
      var param = _param;
      if (param) {
        var l = param[1];
        curry._2(pp_e, ppf, param[0]);
        if (l !== /* [] */0) {
          format.pp_print_char(ppf, sep);
          _param = l;
          continue ;
        } else {
          return 0;
        }
      } else {
        return /* () */0;
      }
    }  };
  return /* tuple */[
          parse$1,
          print
        ];
}

function array$2($staropt$star, param) {
  var pp_e = param[1];
  var parse = param[0];
  var sep = $staropt$star !== undefined ? $staropt$star : /* "," */44;
  var parse$1 = function (s) {
    try {
      return /* `Ok */[
              17724,
              array.of_list(split_and_parse(sep, parse, s))
            ];
    }
    catch (raw_exn){
      var exn = caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn[0] === caml_builtin_exceptions.failure) {
        return /* `Error */[
                106380200,
                err_element("array", s, exn[1])
              ];
      } else {
        throw exn;
      }
    }
  };
  var print = function (ppf, v) {
    var max = v.length - 1 | 0;
    for(var i = 0; i <= max; ++i){
      curry._2(pp_e, ppf, caml_array.caml_array_get(v, i));
      if (i !== max) {
        format.pp_print_char(ppf, sep);
      }
      
    }
    return /* () */0;
  };
  return /* tuple */[
          parse$1,
          print
        ];
}

function split_left(sep, s) {
  try {
    var i = string.index(s, sep);
    var len = s.length;
    return /* tuple */[
            string.sub(s, 0, i),
            string.sub(s, i + 1 | 0, (len - i | 0) - 1 | 0)
          ];
  }
  catch (exn){
    if (exn === caml_builtin_exceptions.not_found) {
      return ;
    } else {
      throw exn;
    }
  }
}

function pair$1($staropt$star, param, param$1) {
  var pr1 = param$1[1];
  var pa1 = param$1[0];
  var pr0 = param[1];
  var pa0 = param[0];
  var sep = $staropt$star !== undefined ? $staropt$star : /* "," */44;
  var parser = function (s) {
    var match = split_left(sep, s);
    if (match !== undefined) {
      var match$1 = match;
      var match$2 = curry._1(pa0, match$1[0]);
      var match$3 = curry._1(pa1, match$1[1]);
      if (match$2[0] >= 106380200) {
        return /* `Error */[
                106380200,
                err_element("pair", s, match$2[1])
              ];
      } else if (typeof match$3 !== "number" && match$3[0] === 17724) {
        return /* `Ok */[
                17724,
                /* tuple */[
                  match$2[1],
                  match$3[1]
                ]
              ];
      }
      return /* `Error */[
              106380200,
              err_element("pair", s, match$3[1])
            ];
    } else {
      return /* `Error */[
              106380200,
              err_sep_miss(sep, s)
            ];
    }
  };
  var printer = function (ppf, param) {
    return curry._5(format.fprintf(ppf, /* Format */[
                    /* Alpha */block.__(15, [/* Char */block.__(0, [/* Alpha */block.__(15, [/* End_of_format */0])])]),
                    "%a%c%a"
                  ]), pr0, param[0], sep, pr1, param[1]);
  };
  return /* tuple */[
          parser,
          printer
        ];
}

function t3($staropt$star, param, param$1, param$2) {
  var pr2 = param$2[1];
  var pa2 = param$2[0];
  var pr1 = param$1[1];
  var pa1 = param$1[0];
  var pr0 = param[1];
  var pa0 = param[0];
  var sep = $staropt$star !== undefined ? $staropt$star : /* "," */44;
  var parse = function (s) {
    var match = split_left(sep, s);
    if (match !== undefined) {
      var match$1 = match;
      var s$1 = match$1[1];
      var match$2 = split_left(sep, s$1);
      if (match$2 !== undefined) {
        var match$3 = match$2;
        var match$4 = curry._1(pa0, match$1[0]);
        var match$5 = curry._1(pa1, match$3[0]);
        var match$6 = curry._1(pa2, match$3[1]);
        var e;
        var exit = 0;
        if (match$4[0] >= 106380200) {
          e = match$4[1];
        } else if (typeof match$5 === "number" || match$5[0] !== 17724) {
          exit = 2;
        } else if (typeof match$6 === "number" || match$6[0] !== 17724) {
          e = match$6[1];
        } else {
          return /* `Ok */[
                  17724,
                  /* tuple */[
                    match$4[1],
                    match$5[1],
                    match$6[1]
                  ]
                ];
        }
        if (exit === 2) {
          e = typeof match$5 === "number" || match$5[0] !== 106380200 ? match$6[1] : match$5[1];
        }
        return /* `Error */[
                106380200,
                err_element("triple", s$1, e)
              ];
      } else {
        return /* `Error */[
                106380200,
                err_sep_miss(sep, s$1)
              ];
      }
    } else {
      return /* `Error */[
              106380200,
              err_sep_miss(sep, s)
            ];
    }
  };
  var print = function (ppf, param) {
    return curry._8(format.fprintf(ppf, /* Format */[
                    /* Alpha */block.__(15, [/* Char */block.__(0, [/* Alpha */block.__(15, [/* Char */block.__(0, [/* Alpha */block.__(15, [/* End_of_format */0])])])])]),
                    "%a%c%a%c%a"
                  ]), pr0, param[0], sep, pr1, param[1], sep, pr2, param[2]);
  };
  return /* tuple */[
          parse,
          print
        ];
}

function t4($staropt$star, param, param$1, param$2, param$3) {
  var pr3 = param$3[1];
  var pa3 = param$3[0];
  var pr2 = param$2[1];
  var pa2 = param$2[0];
  var pr1 = param$1[1];
  var pa1 = param$1[0];
  var pr0 = param[1];
  var pa0 = param[0];
  var sep = $staropt$star !== undefined ? $staropt$star : /* "," */44;
  var parse = function (s) {
    var match = split_left(sep, s);
    if (match !== undefined) {
      var match$1 = match;
      var s$1 = match$1[1];
      var match$2 = split_left(sep, s$1);
      if (match$2 !== undefined) {
        var match$3 = match$2;
        var s$2 = match$3[1];
        var match$4 = split_left(sep, s$2);
        if (match$4 !== undefined) {
          var match$5 = match$4;
          var match$6 = curry._1(pa0, match$1[0]);
          var match$7 = curry._1(pa1, match$3[0]);
          var match$8 = curry._1(pa2, match$5[0]);
          var match$9 = curry._1(pa3, match$5[1]);
          var e;
          var exit = 0;
          var exit$1 = 0;
          if (match$6[0] >= 106380200) {
            e = match$6[1];
          } else if (typeof match$7 === "number" || match$7[0] !== 17724) {
            exit$1 = 3;
          } else if (typeof match$8 === "number" || match$8[0] !== 17724) {
            exit = 2;
          } else if (typeof match$9 === "number" || match$9[0] !== 17724) {
            e = match$9[1];
          } else {
            return /* `Ok */[
                    17724,
                    /* tuple */[
                      match$6[1],
                      match$7[1],
                      match$8[1],
                      match$9[1]
                    ]
                  ];
          }
          if (exit$1 === 3) {
            if (typeof match$7 === "number" || match$7[0] !== 106380200) {
              exit = 2;
            } else {
              e = match$7[1];
            }
          }
          if (exit === 2) {
            e = typeof match$8 === "number" || match$8[0] !== 106380200 ? match$9[1] : match$8[1];
          }
          return /* `Error */[
                  106380200,
                  err_element("quadruple", s$2, e)
                ];
        } else {
          return /* `Error */[
                  106380200,
                  err_sep_miss(sep, s$2)
                ];
        }
      } else {
        return /* `Error */[
                106380200,
                err_sep_miss(sep, s$1)
              ];
      }
    } else {
      return /* `Error */[
              106380200,
              err_sep_miss(sep, s)
            ];
    }
  };
  var print = function (ppf, param) {
    return curry.app(format.fprintf(ppf, /* Format */[
                    /* Alpha */block.__(15, [/* Char */block.__(0, [/* Alpha */block.__(15, [/* Char */block.__(0, [/* Alpha */block.__(15, [/* Char */block.__(0, [/* Alpha */block.__(15, [/* End_of_format */0])])])])])])]),
                    "%a%c%a%c%a%c%a"
                  ]), [
                pr0,
                param[0],
                sep,
                pr1,
                param[1],
                sep,
                pr2,
                param[2],
                sep,
                pr3,
                param[3]
              ]);
  };
  return /* tuple */[
          parse,
          print
        ];
}

function env_bool_parse(s) {
  var s$1 = string.lowercase_ascii(s);
  switch (s$1) {
    case "" :
    case "0" :
    case "false" :
    case "n" :
    case "no" :
        return /* `Ok */[
                17724,
                false
              ];
    case "1" :
    case "true" :
    case "y" :
    case "yes" :
        return /* `Ok */[
                17724,
                true
              ];
    default:
      return /* `Error */[
              106380200,
              err_invalid("value", s$1, alts_str(undefined, /* :: */[
                        "true",
                        /* :: */[
                          "yes",
                          /* :: */[
                            "false",
                            /* :: */[
                              "no",
                              /* [] */0
                            ]
                          ]
                        ]
                      ]))
            ];
  }
}

var pp_text = format.pp_print_text;

var t2 = pair$1;

var pp_text_1 = pp_text;
var pp_lines_1 = pp_lines;
var pp_tokens_1 = pp_tokens;
var quote_1$1 = quote$2;
var alts_str_1 = alts_str;
var err_ambiguous_1 = err_ambiguous;
var err_unknown_1 = err_unknown;
var err_multi_def_1 = err_multi_def;
var some_1$1 = some$1;
var bool_1$2 = bool$3;
var $$char_1$1 = $$char$1;
var $$int_1$2 = $$int$3;
var nativeint_1$1 = nativeint$2;
var int32_1$1 = int32$2;
var int64_1$1 = int64$2;
var $$float_1$2 = $$float$3;
var string_1$2 = string$3;
var $$enum_1 = $$enum;
var file_1$1 = file$1;
var dir_1 = dir;
var non_dir_file_1 = non_dir_file;
var list_1$1 = list$2;
var array_1$1 = array$2;
var pair_1$1 = pair$1;
var t2_1 = t2;
var t3_1 = t3;
var t4_1 = t4;
var env_bool_parse_1 = env_bool_parse;
/* Format Not a pure module */

var cmdliner_base_bs = {
	pp_text: pp_text_1,
	pp_lines: pp_lines_1,
	pp_tokens: pp_tokens_1,
	quote: quote_1$1,
	alts_str: alts_str_1,
	err_ambiguous: err_ambiguous_1,
	err_unknown: err_unknown_1,
	err_multi_def: err_multi_def_1,
	some: some_1$1,
	bool: bool_1$2,
	$$char: $$char_1$1,
	$$int: $$int_1$2,
	nativeint: nativeint_1$1,
	int32: int32_1$1,
	int64: int64_1$1,
	$$float: $$float_1$2,
	string: string_1$2,
	$$enum: $$enum_1,
	file: file_1$1,
	dir: dir_1,
	non_dir_file: non_dir_file_1,
	list: list_1$1,
	array: array_1$1,
	pair: pair_1$1,
	t2: t2_1,
	t3: t3_1,
	t4: t4_1,
	env_bool_parse: env_bool_parse_1
};

function Make$1(funarg) {
  var height = function (param) {
    if (param) {
      return param[/* h */3];
    } else {
      return 0;
    }
  };
  var create = function (l, v, r) {
    var hl = l ? l[/* h */3] : 0;
    var hr = r ? r[/* h */3] : 0;
    return /* Node */[
            /* l */l,
            /* v */v,
            /* r */r,
            /* h */hl >= hr ? hl + 1 | 0 : hr + 1 | 0
          ];
  };
  var bal = function (l, v, r) {
    var hl = l ? l[/* h */3] : 0;
    var hr = r ? r[/* h */3] : 0;
    if (hl > (hr + 2 | 0)) {
      if (l) {
        var lr = l[/* r */2];
        var lv = l[/* v */1];
        var ll = l[/* l */0];
        if (height(ll) >= height(lr)) {
          return create(ll, lv, create(lr, v, r));
        } else if (lr) {
          return create(create(ll, lv, lr[/* l */0]), lr[/* v */1], create(lr[/* r */2], v, r));
        } else {
          throw [
                caml_builtin_exceptions.invalid_argument,
                "Set.bal"
              ];
        }
      } else {
        throw [
              caml_builtin_exceptions.invalid_argument,
              "Set.bal"
            ];
      }
    } else if (hr > (hl + 2 | 0)) {
      if (r) {
        var rr = r[/* r */2];
        var rv = r[/* v */1];
        var rl = r[/* l */0];
        if (height(rr) >= height(rl)) {
          return create(create(l, v, rl), rv, rr);
        } else if (rl) {
          return create(create(l, v, rl[/* l */0]), rl[/* v */1], create(rl[/* r */2], rv, rr));
        } else {
          throw [
                caml_builtin_exceptions.invalid_argument,
                "Set.bal"
              ];
        }
      } else {
        throw [
              caml_builtin_exceptions.invalid_argument,
              "Set.bal"
            ];
      }
    } else {
      return /* Node */[
              /* l */l,
              /* v */v,
              /* r */r,
              /* h */hl >= hr ? hl + 1 | 0 : hr + 1 | 0
            ];
    }
  };
  var add = function (x, t) {
    if (t) {
      var r = t[/* r */2];
      var v = t[/* v */1];
      var l = t[/* l */0];
      var c = curry._2(funarg.compare, x, v);
      if (c === 0) {
        return t;
      } else if (c < 0) {
        var ll = add(x, l);
        if (l === ll) {
          return t;
        } else {
          return bal(ll, v, r);
        }
      } else {
        var rr = add(x, r);
        if (r === rr) {
          return t;
        } else {
          return bal(l, v, rr);
        }
      }
    } else {
      return /* Node */[
              /* l : Empty */0,
              /* v */x,
              /* r : Empty */0,
              /* h */1
            ];
    }
  };
  var singleton = function (x) {
    return /* Node */[
            /* l : Empty */0,
            /* v */x,
            /* r : Empty */0,
            /* h */1
          ];
  };
  var add_min_element = function (x, param) {
    if (param) {
      return bal(add_min_element(x, param[/* l */0]), param[/* v */1], param[/* r */2]);
    } else {
      return singleton(x);
    }
  };
  var add_max_element = function (x, param) {
    if (param) {
      return bal(param[/* l */0], param[/* v */1], add_max_element(x, param[/* r */2]));
    } else {
      return singleton(x);
    }
  };
  var join = function (l, v, r) {
    if (l) {
      if (r) {
        var rh = r[/* h */3];
        var lh = l[/* h */3];
        if (lh > (rh + 2 | 0)) {
          return bal(l[/* l */0], l[/* v */1], join(l[/* r */2], v, r));
        } else if (rh > (lh + 2 | 0)) {
          return bal(join(l, v, r[/* l */0]), r[/* v */1], r[/* r */2]);
        } else {
          return create(l, v, r);
        }
      } else {
        return add_max_element(v, l);
      }
    } else {
      return add_min_element(v, r);
    }
  };
  var min_elt = function (_param) {
    while(true) {
      var param = _param;
      if (param) {
        var l = param[/* l */0];
        if (l) {
          _param = l;
          continue ;
        } else {
          return param[/* v */1];
        }
      } else {
        throw caml_builtin_exceptions.not_found;
      }
    }  };
  var min_elt_opt = function (_param) {
    while(true) {
      var param = _param;
      if (param) {
        var l = param[/* l */0];
        if (l) {
          _param = l;
          continue ;
        } else {
          return caml_option.some(param[/* v */1]);
        }
      } else {
        return ;
      }
    }  };
  var max_elt = function (_param) {
    while(true) {
      var param = _param;
      if (param) {
        var r = param[/* r */2];
        if (r) {
          _param = r;
          continue ;
        } else {
          return param[/* v */1];
        }
      } else {
        throw caml_builtin_exceptions.not_found;
      }
    }  };
  var max_elt_opt = function (_param) {
    while(true) {
      var param = _param;
      if (param) {
        var r = param[/* r */2];
        if (r) {
          _param = r;
          continue ;
        } else {
          return caml_option.some(param[/* v */1]);
        }
      } else {
        return ;
      }
    }  };
  var remove_min_elt = function (param) {
    if (param) {
      var l = param[/* l */0];
      if (l) {
        return bal(remove_min_elt(l), param[/* v */1], param[/* r */2]);
      } else {
        return param[/* r */2];
      }
    } else {
      throw [
            caml_builtin_exceptions.invalid_argument,
            "Set.remove_min_elt"
          ];
    }
  };
  var concat = function (t1, t2) {
    if (t1) {
      if (t2) {
        return join(t1, min_elt(t2), remove_min_elt(t2));
      } else {
        return t1;
      }
    } else {
      return t2;
    }
  };
  var split = function (x, param) {
    if (param) {
      var r = param[/* r */2];
      var v = param[/* v */1];
      var l = param[/* l */0];
      var c = curry._2(funarg.compare, x, v);
      if (c === 0) {
        return /* tuple */[
                l,
                true,
                r
              ];
      } else if (c < 0) {
        var match = split(x, l);
        return /* tuple */[
                match[0],
                match[1],
                join(match[2], v, r)
              ];
      } else {
        var match$1 = split(x, r);
        return /* tuple */[
                join(l, v, match$1[0]),
                match$1[1],
                match$1[2]
              ];
      }
    } else {
      return /* tuple */[
              /* Empty */0,
              false,
              /* Empty */0
            ];
    }
  };
  var is_empty = function (param) {
    if (param) {
      return false;
    } else {
      return true;
    }
  };
  var mem = function (x, _param) {
    while(true) {
      var param = _param;
      if (param) {
        var c = curry._2(funarg.compare, x, param[/* v */1]);
        if (c === 0) {
          return true;
        } else {
          _param = c < 0 ? param[/* l */0] : param[/* r */2];
          continue ;
        }
      } else {
        return false;
      }
    }  };
  var remove = function (x, t) {
    if (t) {
      var r = t[/* r */2];
      var v = t[/* v */1];
      var l = t[/* l */0];
      var c = curry._2(funarg.compare, x, v);
      if (c === 0) {
        var t1 = l;
        var t2 = r;
        if (t1) {
          if (t2) {
            return bal(t1, min_elt(t2), remove_min_elt(t2));
          } else {
            return t1;
          }
        } else {
          return t2;
        }
      } else if (c < 0) {
        var ll = remove(x, l);
        if (l === ll) {
          return t;
        } else {
          return bal(ll, v, r);
        }
      } else {
        var rr = remove(x, r);
        if (r === rr) {
          return t;
        } else {
          return bal(l, v, rr);
        }
      }
    } else {
      return /* Empty */0;
    }
  };
  var union = function (s1, s2) {
    if (s1) {
      if (s2) {
        var h2 = s2[/* h */3];
        var v2 = s2[/* v */1];
        var h1 = s1[/* h */3];
        var v1 = s1[/* v */1];
        if (h1 >= h2) {
          if (h2 === 1) {
            return add(v2, s1);
          } else {
            var match = split(v1, s2);
            return join(union(s1[/* l */0], match[0]), v1, union(s1[/* r */2], match[2]));
          }
        } else if (h1 === 1) {
          return add(v1, s2);
        } else {
          var match$1 = split(v2, s1);
          return join(union(match$1[0], s2[/* l */0]), v2, union(match$1[2], s2[/* r */2]));
        }
      } else {
        return s1;
      }
    } else {
      return s2;
    }
  };
  var inter = function (s1, s2) {
    if (s1 && s2) {
      var r1 = s1[/* r */2];
      var v1 = s1[/* v */1];
      var l1 = s1[/* l */0];
      var match = split(v1, s2);
      var l2 = match[0];
      if (match[1]) {
        return join(inter(l1, l2), v1, inter(r1, match[2]));
      } else {
        return concat(inter(l1, l2), inter(r1, match[2]));
      }
    } else {
      return /* Empty */0;
    }
  };
  var diff = function (s1, s2) {
    if (s1) {
      if (s2) {
        var r1 = s1[/* r */2];
        var v1 = s1[/* v */1];
        var l1 = s1[/* l */0];
        var match = split(v1, s2);
        var l2 = match[0];
        if (match[1]) {
          return concat(diff(l1, l2), diff(r1, match[2]));
        } else {
          return join(diff(l1, l2), v1, diff(r1, match[2]));
        }
      } else {
        return s1;
      }
    } else {
      return /* Empty */0;
    }
  };
  var cons_enum = function (_s, _e) {
    while(true) {
      var e = _e;
      var s = _s;
      if (s) {
        _e = /* More */[
          s[/* v */1],
          s[/* r */2],
          e
        ];
        _s = s[/* l */0];
        continue ;
      } else {
        return e;
      }
    }  };
  var compare = function (s1, s2) {
    var _e1 = cons_enum(s1, /* End */0);
    var _e2 = cons_enum(s2, /* End */0);
    while(true) {
      var e2 = _e2;
      var e1 = _e1;
      if (e1) {
        if (e2) {
          var c = curry._2(funarg.compare, e1[0], e2[0]);
          if (c !== 0) {
            return c;
          } else {
            _e2 = cons_enum(e2[1], e2[2]);
            _e1 = cons_enum(e1[1], e1[2]);
            continue ;
          }
        } else {
          return 1;
        }
      } else if (e2) {
        return -1;
      } else {
        return 0;
      }
    }  };
  var equal = function (s1, s2) {
    return compare(s1, s2) === 0;
  };
  var subset = function (_s1, _s2) {
    while(true) {
      var s2 = _s2;
      var s1 = _s1;
      if (s1) {
        if (s2) {
          var r2 = s2[/* r */2];
          var l2 = s2[/* l */0];
          var r1 = s1[/* r */2];
          var v1 = s1[/* v */1];
          var l1 = s1[/* l */0];
          var c = curry._2(funarg.compare, v1, s2[/* v */1]);
          if (c === 0) {
            if (subset(l1, l2)) {
              _s2 = r2;
              _s1 = r1;
              continue ;
            } else {
              return false;
            }
          } else if (c < 0) {
            if (subset(/* Node */[
                    /* l */l1,
                    /* v */v1,
                    /* r : Empty */0,
                    /* h */0
                  ], l2)) {
              _s1 = r1;
              continue ;
            } else {
              return false;
            }
          } else if (subset(/* Node */[
                  /* l : Empty */0,
                  /* v */v1,
                  /* r */r1,
                  /* h */0
                ], r2)) {
            _s1 = l1;
            continue ;
          } else {
            return false;
          }
        } else {
          return false;
        }
      } else {
        return true;
      }
    }  };
  var iter = function (f, _param) {
    while(true) {
      var param = _param;
      if (param) {
        iter(f, param[/* l */0]);
        curry._1(f, param[/* v */1]);
        _param = param[/* r */2];
        continue ;
      } else {
        return /* () */0;
      }
    }  };
  var fold = function (f, _s, _accu) {
    while(true) {
      var accu = _accu;
      var s = _s;
      if (s) {
        _accu = curry._2(f, s[/* v */1], fold(f, s[/* l */0], accu));
        _s = s[/* r */2];
        continue ;
      } else {
        return accu;
      }
    }  };
  var for_all = function (p, _param) {
    while(true) {
      var param = _param;
      if (param) {
        if (curry._1(p, param[/* v */1]) && for_all(p, param[/* l */0])) {
          _param = param[/* r */2];
          continue ;
        } else {
          return false;
        }
      } else {
        return true;
      }
    }  };
  var exists = function (p, _param) {
    while(true) {
      var param = _param;
      if (param) {
        if (curry._1(p, param[/* v */1]) || exists(p, param[/* l */0])) {
          return true;
        } else {
          _param = param[/* r */2];
          continue ;
        }
      } else {
        return false;
      }
    }  };
  var filter = function (p, t) {
    if (t) {
      var r = t[/* r */2];
      var v = t[/* v */1];
      var l = t[/* l */0];
      var l$prime = filter(p, l);
      var pv = curry._1(p, v);
      var r$prime = filter(p, r);
      if (pv) {
        if (l === l$prime && r === r$prime) {
          return t;
        } else {
          return join(l$prime, v, r$prime);
        }
      } else {
        return concat(l$prime, r$prime);
      }
    } else {
      return /* Empty */0;
    }
  };
  var partition = function (p, param) {
    if (param) {
      var v = param[/* v */1];
      var match = partition(p, param[/* l */0]);
      var lf = match[1];
      var lt = match[0];
      var pv = curry._1(p, v);
      var match$1 = partition(p, param[/* r */2]);
      var rf = match$1[1];
      var rt = match$1[0];
      if (pv) {
        return /* tuple */[
                join(lt, v, rt),
                concat(lf, rf)
              ];
      } else {
        return /* tuple */[
                concat(lt, rt),
                join(lf, v, rf)
              ];
      }
    } else {
      return /* tuple */[
              /* Empty */0,
              /* Empty */0
            ];
    }
  };
  var cardinal = function (param) {
    if (param) {
      return (cardinal(param[/* l */0]) + 1 | 0) + cardinal(param[/* r */2]) | 0;
    } else {
      return 0;
    }
  };
  var elements_aux = function (_accu, _param) {
    while(true) {
      var param = _param;
      var accu = _accu;
      if (param) {
        _param = param[/* l */0];
        _accu = /* :: */[
          param[/* v */1],
          elements_aux(accu, param[/* r */2])
        ];
        continue ;
      } else {
        return accu;
      }
    }  };
  var elements = function (s) {
    return elements_aux(/* [] */0, s);
  };
  var find = function (x, _param) {
    while(true) {
      var param = _param;
      if (param) {
        var v = param[/* v */1];
        var c = curry._2(funarg.compare, x, v);
        if (c === 0) {
          return v;
        } else {
          _param = c < 0 ? param[/* l */0] : param[/* r */2];
          continue ;
        }
      } else {
        throw caml_builtin_exceptions.not_found;
      }
    }  };
  var find_first = function (f, _param) {
    while(true) {
      var param = _param;
      if (param) {
        var v = param[/* v */1];
        if (curry._1(f, v)) {
          var _v0 = v;
          var f$1 = f;
          var _param$1 = param[/* l */0];
          while(true) {
            var param$1 = _param$1;
            var v0 = _v0;
            if (param$1) {
              var v$1 = param$1[/* v */1];
              if (curry._1(f$1, v$1)) {
                _param$1 = param$1[/* l */0];
                _v0 = v$1;
                continue ;
              } else {
                _param$1 = param$1[/* r */2];
                continue ;
              }
            } else {
              return v0;
            }
          }        } else {
          _param = param[/* r */2];
          continue ;
        }
      } else {
        throw caml_builtin_exceptions.not_found;
      }
    }  };
  var find_first_opt = function (f, _param) {
    while(true) {
      var param = _param;
      if (param) {
        var v = param[/* v */1];
        if (curry._1(f, v)) {
          var _v0 = v;
          var f$1 = f;
          var _param$1 = param[/* l */0];
          while(true) {
            var param$1 = _param$1;
            var v0 = _v0;
            if (param$1) {
              var v$1 = param$1[/* v */1];
              if (curry._1(f$1, v$1)) {
                _param$1 = param$1[/* l */0];
                _v0 = v$1;
                continue ;
              } else {
                _param$1 = param$1[/* r */2];
                continue ;
              }
            } else {
              return caml_option.some(v0);
            }
          }        } else {
          _param = param[/* r */2];
          continue ;
        }
      } else {
        return ;
      }
    }  };
  var find_last = function (f, _param) {
    while(true) {
      var param = _param;
      if (param) {
        var v = param[/* v */1];
        if (curry._1(f, v)) {
          var _v0 = v;
          var f$1 = f;
          var _param$1 = param[/* r */2];
          while(true) {
            var param$1 = _param$1;
            var v0 = _v0;
            if (param$1) {
              var v$1 = param$1[/* v */1];
              if (curry._1(f$1, v$1)) {
                _param$1 = param$1[/* r */2];
                _v0 = v$1;
                continue ;
              } else {
                _param$1 = param$1[/* l */0];
                continue ;
              }
            } else {
              return v0;
            }
          }        } else {
          _param = param[/* l */0];
          continue ;
        }
      } else {
        throw caml_builtin_exceptions.not_found;
      }
    }  };
  var find_last_opt = function (f, _param) {
    while(true) {
      var param = _param;
      if (param) {
        var v = param[/* v */1];
        if (curry._1(f, v)) {
          var _v0 = v;
          var f$1 = f;
          var _param$1 = param[/* r */2];
          while(true) {
            var param$1 = _param$1;
            var v0 = _v0;
            if (param$1) {
              var v$1 = param$1[/* v */1];
              if (curry._1(f$1, v$1)) {
                _param$1 = param$1[/* r */2];
                _v0 = v$1;
                continue ;
              } else {
                _param$1 = param$1[/* l */0];
                continue ;
              }
            } else {
              return caml_option.some(v0);
            }
          }        } else {
          _param = param[/* l */0];
          continue ;
        }
      } else {
        return ;
      }
    }  };
  var find_opt = function (x, _param) {
    while(true) {
      var param = _param;
      if (param) {
        var v = param[/* v */1];
        var c = curry._2(funarg.compare, x, v);
        if (c === 0) {
          return caml_option.some(v);
        } else {
          _param = c < 0 ? param[/* l */0] : param[/* r */2];
          continue ;
        }
      } else {
        return ;
      }
    }  };
  var map = function (f, t) {
    if (t) {
      var r = t[/* r */2];
      var v = t[/* v */1];
      var l = t[/* l */0];
      var l$prime = map(f, l);
      var v$prime = curry._1(f, v);
      var r$prime = map(f, r);
      if (l === l$prime && v === v$prime && r === r$prime) {
        return t;
      } else {
        var l$1 = l$prime;
        var v$1 = v$prime;
        var r$1 = r$prime;
        if ((l$1 === /* Empty */0 || curry._2(funarg.compare, max_elt(l$1), v$1) < 0) && (r$1 === /* Empty */0 || curry._2(funarg.compare, v$1, min_elt(r$1)) < 0)) {
          return join(l$1, v$1, r$1);
        } else {
          return union(l$1, add(v$1, r$1));
        }
      }
    } else {
      return /* Empty */0;
    }
  };
  var of_list = function (l) {
    if (l) {
      var match = l[1];
      var x0 = l[0];
      if (match) {
        var match$1 = match[1];
        var x1 = match[0];
        if (match$1) {
          var match$2 = match$1[1];
          var x2 = match$1[0];
          if (match$2) {
            var match$3 = match$2[1];
            var x3 = match$2[0];
            if (match$3) {
              if (match$3[1]) {
                var l$1 = list.sort_uniq(funarg.compare, l);
                var sub = function (n, l) {
                  switch (n) {
                    case 0 :
                        return /* tuple */[
                                /* Empty */0,
                                l
                              ];
                    case 1 :
                        if (l) {
                          return /* tuple */[
                                  /* Node */[
                                    /* l : Empty */0,
                                    /* v */l[0],
                                    /* r : Empty */0,
                                    /* h */1
                                  ],
                                  l[1]
                                ];
                        }
                        break;
                    case 2 :
                        if (l) {
                          var match = l[1];
                          if (match) {
                            return /* tuple */[
                                    /* Node */[
                                      /* l : Node */[
                                        /* l : Empty */0,
                                        /* v */l[0],
                                        /* r : Empty */0,
                                        /* h */1
                                      ],
                                      /* v */match[0],
                                      /* r : Empty */0,
                                      /* h */2
                                    ],
                                    match[1]
                                  ];
                          }
                          
                        }
                        break;
                    case 3 :
                        if (l) {
                          var match$1 = l[1];
                          if (match$1) {
                            var match$2 = match$1[1];
                            if (match$2) {
                              return /* tuple */[
                                      /* Node */[
                                        /* l : Node */[
                                          /* l : Empty */0,
                                          /* v */l[0],
                                          /* r : Empty */0,
                                          /* h */1
                                        ],
                                        /* v */match$1[0],
                                        /* r : Node */[
                                          /* l : Empty */0,
                                          /* v */match$2[0],
                                          /* r : Empty */0,
                                          /* h */1
                                        ],
                                        /* h */2
                                      ],
                                      match$2[1]
                                    ];
                            }
                            
                          }
                          
                        }
                        break;
                      
                  }
                  var nl = n / 2 | 0;
                  var match$3 = sub(nl, l);
                  var l$1 = match$3[1];
                  if (l$1) {
                    var match$4 = sub((n - nl | 0) - 1 | 0, l$1[1]);
                    return /* tuple */[
                            create(match$3[0], l$1[0], match$4[0]),
                            match$4[1]
                          ];
                  } else {
                    throw [
                          caml_builtin_exceptions.assert_failure,
                          /* tuple */[
                            "set.ml",
                            510,
                            18
                          ]
                        ];
                  }
                };
                return sub(list.length(l$1), l$1)[0];
              } else {
                return add(match$3[0], add(x3, add(x2, add(x1, singleton(x0)))));
              }
            } else {
              return add(x3, add(x2, add(x1, singleton(x0))));
            }
          } else {
            return add(x2, add(x1, singleton(x0)));
          }
        } else {
          return add(x1, singleton(x0));
        }
      } else {
        return singleton(x0);
      }
    } else {
      return /* Empty */0;
    }
  };
  return {
          empty: /* Empty */0,
          is_empty: is_empty,
          mem: mem,
          add: add,
          singleton: singleton,
          remove: remove,
          union: union,
          inter: inter,
          diff: diff,
          compare: compare,
          equal: equal,
          subset: subset,
          iter: iter,
          map: map,
          fold: fold,
          for_all: for_all,
          exists: exists,
          filter: filter,
          partition: partition,
          cardinal: cardinal,
          elements: elements,
          min_elt: min_elt,
          min_elt_opt: min_elt_opt,
          max_elt: max_elt,
          max_elt_opt: max_elt_opt,
          choose: min_elt,
          choose_opt: min_elt_opt,
          split: split,
          find: find,
          find_opt: find_opt,
          find_first: find_first,
          find_first_opt: find_first_opt,
          find_last: find_last,
          find_last_opt: find_last_opt,
          of_list: of_list
        };
}

var Make_1$1 = Make$1;
/* No side effect */

var set = {
	Make: Make_1$1
};

var s_name = "NAME";

var s_synopsis = "SYNOPSIS";

var s_description = "DESCRIPTION";

var s_commands = "COMMANDS";

var s_arguments = "ARGUMENTS";

var s_options = "OPTIONS";

var s_common_options = "COMMON OPTIONS";

var s_exit_status = "EXIT STATUS";

var s_environment = "ENVIRONMENT";

var s_files = "FILES";

var s_examples = "EXAMPLES";

var s_bugs = "BUGS";

var s_authors = "AUTHORS";

var s_see_also = "SEE ALSO";

var order = /* array */[
  s_name,
  s_synopsis,
  s_description,
  "",
  s_commands,
  s_arguments,
  s_options,
  s_common_options,
  s_exit_status,
  s_environment,
  s_files,
  s_examples,
  s_bugs,
  s_authors,
  s_see_also
];

function section_to_order(on_unknown, s) {
  var max = order.length - 1 | 0;
  var _i = 0;
  while(true) {
    var i = _i;
    var match = i > max;
    if (match) {
      return on_unknown;
    } else if (caml_array.caml_array_get(order, i) === s) {
      return i;
    } else {
      _i = i + 1 | 0;
      continue ;
    }
  }}

function smap_of_blocks(bs) {
  var loop = function (_s, _s_o, _rbs, _smap, _param) {
    while(true) {
      var param = _param;
      var smap = _smap;
      var rbs = _rbs;
      var s_o = _s_o;
      var s = _s;
      if (param) {
        var c = param[0];
        if (typeof c !== "number") {
          var variant = c[0];
          if (variant !== 83) {
            if (variant < -595680601) {
              var match = loop(s, s_o, rbs, smap, c[1]);
              _param = param[1];
              _smap = match[3];
              _rbs = match[2];
              _s_o = match[1];
              _s = match[0];
              continue ;
            }
            
          } else {
            var new_sec = c[1];
            var new_o = section_to_order(s_o, new_sec);
            _param = param[1];
            _smap = /* :: */[
              /* tuple */[
                s,
                /* tuple */[
                  s_o,
                  rbs
                ]
              ],
              smap
            ];
            _rbs = /* [] */0;
            _s_o = new_o;
            _s = new_sec;
            continue ;
          }
        }
        _param = param[1];
        _rbs = /* :: */[
          c,
          rbs
        ];
        continue ;
      } else {
        return /* tuple */[
                s,
                s_o,
                rbs,
                smap
              ];
      }
    }  };
  var match;
  if (bs) {
    var match$1 = bs[0];
    if (typeof match$1 === "number") {
      match = /* tuple */[
        "",
        bs
      ];
    } else {
      var variant = match$1[0];
      if (variant !== -595680602) {
        match = variant !== 83 ? /* tuple */[
            "",
            bs
          ] : /* tuple */[
            match$1[1],
            bs[1]
          ];
      } else {
        var match$2 = match$1[1];
        if (match$2) {
          var match$3 = match$2[0];
          match = typeof match$3 === "number" || match$3[0] !== 83 ? /* tuple */[
              "",
              bs
            ] : /* tuple */[
              match$3[1],
              /* :: */[
                /* `Blocks */[
                  -595680602,
                  match$2[1]
                ],
                bs[1]
              ]
            ];
        } else {
          match = /* tuple */[
            "",
            bs
          ];
        }
      }
    }
  } else {
    match = /* tuple */[
      "",
      bs
    ];
  }
  var first = match[0];
  var first_o = section_to_order(1, first);
  var match$4 = loop(first, first_o, /* [] */0, /* [] */0, match[1]);
  return /* :: */[
          /* tuple */[
            match$4[0],
            /* tuple */[
              match$4[1],
              match$4[2]
            ]
          ],
          match$4[3]
        ];
}

function smap_to_blocks(smap) {
  if (smap) {
    var match = smap[0];
    var _acc = /* [] */0;
    var _smap = smap[1];
    var _s = match[0];
    var _param = match[1][1];
    while(true) {
      var param = _param;
      var s = _s;
      var smap$1 = _smap;
      var acc = _acc;
      if (param) {
        _param = param[1];
        _acc = /* :: */[
          param[0],
          acc
        ];
        continue ;
      } else {
        var acc$1 = s === "" ? acc : /* :: */[
            /* `S */[
              83,
              s
            ],
            acc
          ];
        if (smap$1) {
          var match$1 = smap$1[0];
          _param = match$1[1][1];
          _s = match$1[0];
          _smap = smap$1[1];
          _acc = acc$1;
          continue ;
        } else {
          return acc$1;
        }
      }
    }  } else {
    return /* [] */0;
  }
}

function smap_has_section(smap, sec) {
  return list.exists((function (param) {
                return caml_obj.caml_equal(sec, param[0]);
              }), smap);
}

function smap_append_block(smap, sec, b) {
  var o = section_to_order(3, sec);
  var loop = function (_max_lt_o, _left, _param) {
    while(true) {
      var param = _param;
      var left = _left;
      var max_lt_o = _max_lt_o;
      if (param) {
        var right = param[1];
        var s = param[0];
        var match = s[1];
        var o$1 = match[0];
        if (s[0] === sec) {
          return /* Ok */block.__(0, [list.rev_append(/* :: */[
                          /* tuple */[
                            sec,
                            /* tuple */[
                              o$1,
                              /* :: */[
                                b,
                                match[1]
                              ]
                            ]
                          ],
                          left
                        ], right)]);
        } else {
          var max_lt_o$1 = o$1 < o && o$1 > max_lt_o ? o$1 : max_lt_o;
          _param = right;
          _left = /* :: */[
            s,
            left
          ];
          _max_lt_o = max_lt_o$1;
          continue ;
        }
      } else if (max_lt_o !== -1) {
        return /* Error */block.__(1, [max_lt_o]);
      } else {
        return /* Ok */block.__(0, [list.rev(/* :: */[
                        /* tuple */[
                          sec,
                          /* tuple */[
                            o,
                            /* :: */[
                              b,
                              /* [] */0
                            ]
                          ]
                        ],
                        left
                      ])]);
      }
    }  };
  var try_insert = loop(-1, /* [] */0, smap);
  if (try_insert.tag) {
    var insert_before = try_insert[0];
    var _left = /* [] */0;
    var _right = smap;
    while(true) {
      var right = _right;
      var left = _left;
      if (right) {
        var s = right[0];
        if (s[1][0] === insert_before) {
          return list.rev_append(/* :: */[
                      /* tuple */[
                        sec,
                        /* tuple */[
                          o,
                          /* :: */[
                            b,
                            /* [] */0
                          ]
                        ]
                      ],
                      left
                    ], right);
        } else {
          _right = right[1];
          _left = /* :: */[
            s,
            left
          ];
          continue ;
        }
      } else {
        throw [
              caml_builtin_exceptions.assert_failure,
              /* tuple */[
                "cmdliner_manpage.ml",
                129,
                14
              ]
            ];
      }
    }  } else {
    return try_insert[0];
  }
}

function pp_indent(ppf, c) {
  for(var i = 1; i <= c; ++i){
    format.pp_print_char(ppf, /* " " */32);
  }
  return /* () */0;
}

function err(e, fmt) {
  return format.fprintf(e, pervasives.$caret$caret(/* Format */[
                  /* String_literal */block.__(11, [
                      "cmdliner error: ",
                      /* End_of_format */0
                    ]),
                  "cmdliner error: "
                ], pervasives.$caret$caret(fmt, /* Format */[
                      /* Formatting_lit */block.__(17, [
                          /* Flush_newline */4,
                          /* End_of_format */0
                        ]),
                      "@."
                    ])));
}

function err_unescaped(errs, c, s) {
  return curry._2(err(errs, /* Format */[
                  /* String_literal */block.__(11, [
                      "unescaped ",
                      /* Caml_char */block.__(1, [/* String_literal */block.__(11, [
                              " in ",
                              /* Caml_string */block.__(3, [
                                  /* No_padding */0,
                                  /* End_of_format */0
                                ])
                            ])])
                    ]),
                  "unescaped %C in %S"
                ]), c, s);
}

function err_malformed(errs, s) {
  return curry._1(err(errs, /* Format */[
                  /* String_literal */block.__(11, [
                      "Malformed $(...) in ",
                      /* Caml_string */block.__(3, [
                          /* No_padding */0,
                          /* End_of_format */0
                        ])
                    ]),
                  "Malformed $(...) in %S"
                ]), s);
}

function err_unclosed(errs, s) {
  return curry._1(err(errs, /* Format */[
                  /* String_literal */block.__(11, [
                      "Unclosed $(...) in ",
                      /* Caml_string */block.__(3, [
                          /* No_padding */0,
                          /* End_of_format */0
                        ])
                    ]),
                  "Unclosed $(...) in %S"
                ]), s);
}

function err_undef(errs, id, s) {
  return curry._2(err(errs, /* Format */[
                  /* String_literal */block.__(11, [
                      "Undefined variable $(",
                      /* String */block.__(2, [
                          /* No_padding */0,
                          /* String_literal */block.__(11, [
                              ") in ",
                              /* Caml_string */block.__(3, [
                                  /* No_padding */0,
                                  /* End_of_format */0
                                ])
                            ])
                        ])
                    ]),
                  "Undefined variable $(%s) in %S"
                ]), id, s);
}

function err_illegal_esc(errs, c, s) {
  return curry._2(err(errs, /* Format */[
                  /* String_literal */block.__(11, [
                      "Illegal escape char ",
                      /* Caml_char */block.__(1, [/* String_literal */block.__(11, [
                              " in ",
                              /* Caml_string */block.__(3, [
                                  /* No_padding */0,
                                  /* End_of_format */0
                                ])
                            ])])
                    ]),
                  "Illegal escape char %C in %S"
                ]), c, s);
}

function err_markup(errs, dir, s) {
  return curry._2(err(errs, /* Format */[
                  /* String_literal */block.__(11, [
                      "Unknown cmdliner markup $(",
                      /* Char */block.__(0, [/* String_literal */block.__(11, [
                              ",...) in ",
                              /* Caml_string */block.__(3, [
                                  /* No_padding */0,
                                  /* End_of_format */0
                                ])
                            ])])
                    ]),
                  "Unknown cmdliner markup $(%c,...) in %S"
                ]), dir, s);
}

function is_markup_dir(param) {
  if (param !== 98) {
    return param === 105;
  } else {
    return true;
  }
}

function is_markup_esc(param) {
  var switcher = param - 36 | 0;
  if (switcher > 5 || switcher < 0) {
    return switcher === 56;
  } else {
    return switcher > 3 || switcher < 1;
  }
}

function markup_need_esc(param) {
  if (param !== 36) {
    return param === 92;
  } else {
    return true;
  }
}

function markup_text_need_esc(param) {
  var switcher = param - 36 | 0;
  if (switcher > 5 || switcher < 0) {
    return switcher === 56;
  } else {
    return switcher > 4 || switcher < 1;
  }
}

function $$escape(s) {
  var max_i = s.length - 1 | 0;
  var escaped_len = function (_i, _l) {
    while(true) {
      var l = _l;
      var i = _i;
      if (i > max_i) {
        return l;
      } else if (markup_text_need_esc(caml_string.get(s, i))) {
        _l = l + 2 | 0;
        _i = i + 1 | 0;
        continue ;
      } else {
        _l = l + 1 | 0;
        _i = i + 1 | 0;
        continue ;
      }
    }  };
  var escaped_len$1 = escaped_len(0, 0);
  if (escaped_len$1 === s.length) {
    return s;
  } else {
    var b = caml_bytes.caml_create_bytes(escaped_len$1);
    var _i = 0;
    var _k = 0;
    while(true) {
      var k = _k;
      var i = _i;
      if (i > max_i) {
        return bytes.unsafe_to_string(b);
      } else {
        var c = s.charCodeAt(i);
        if (markup_text_need_esc(c)) {
          b[k] = /* "\\" */92;
          b[k + 1 | 0] = c;
          _k = k + 2 | 0;
          _i = i + 1 | 0;
          continue ;
        } else {
          b[k] = c;
          _k = k + 1 | 0;
          _i = i + 1 | 0;
          continue ;
        }
      }
    }  }
}

function subst_vars(errs, subst, b, s) {
  var max_i = s.length - 1 | 0;
  var flush = function (start, stop) {
    var match = start > max_i;
    if (match) {
      return /* () */0;
    } else {
      return buffer.add_substring(b, s, start, (stop - start | 0) + 1 | 0);
    }
  };
  var skip_escape = function (k, start, i) {
    if (i > max_i) {
      return err_unescaped(errs, /* "\\" */92, s);
    } else {
      return curry._2(k, start, i + 1 | 0);
    }
  };
  var skip_markup = function (k, start, _i) {
    while(true) {
      var i = _i;
      if (i > max_i) {
        err_unclosed(errs, s);
        return curry._2(k, start, i);
      } else {
        var c = caml_string.get(s, i);
        if (c !== 41) {
          if (c !== 92) {
            _i = i + 1 | 0;
            continue ;
          } else {
            return skip_escape((function (param, param$1) {
                          return skip_markup(k, param, param$1);
                        }), start, i + 1 | 0);
          }
        } else {
          return curry._2(k, start, i + 1 | 0);
        }
      }
    }  };
  var loop = function (start, _i) {
    while(true) {
      var i = _i;
      if (i > max_i) {
        return flush(start, max_i);
      } else {
        var next = i + 1 | 0;
        var c = caml_string.get(s, i);
        if (c !== 36) {
          if (c !== 92) {
            _i = next;
            continue ;
          } else {
            return skip_escape(loop, start, next);
          }
        } else if (next > max_i) {
          return err_unescaped(errs, /* "$" */36, s);
        } else {
          var match = caml_string.get(s, next);
          if (match !== 40) {
            err_unescaped(errs, /* "$" */36, s);
            _i = next;
            continue ;
          } else {
            var min = next + 2 | 0;
            if (min > max_i) {
              err_unclosed(errs, s);
              _i = next;
              continue ;
            } else {
              var match$1 = caml_string.get(s, min);
              if (match$1 !== 44) {
                var start_id = next + 1 | 0;
                flush(start, i - 1 | 0);
                var start$1 = start_id;
                var _i$1 = start_id;
                while(true) {
                  var i$1 = _i$1;
                  if (i$1 > max_i) {
                    err_unclosed(errs, s);
                    return loop(start$1, i$1);
                  } else if (caml_string.get(s, i$1) !== /* ")" */41) {
                    _i$1 = i$1 + 1 | 0;
                    continue ;
                  } else {
                    var id = string.sub(s, start$1, i$1 - start$1 | 0);
                    var next$1 = i$1 + 1 | 0;
                    var match$2 = curry._1(subst, id);
                    if (match$2 !== undefined) {
                      buffer.add_string(b, match$2);
                    } else {
                      err_undef(errs, id, s);
                      buffer.add_string(b, "undefined");
                    }
                    return loop(next$1, next$1);
                  }
                }              } else {
                return skip_markup(loop, start, min + 1 | 0);
              }
            }
          }
        }
      }
    }  };
  buffer.clear(b);
  loop(0, 0);
  return buffer.contents(b);
}

function add_markup_esc(errs, k, b, s, start, next, target_need_escape, target_escape) {
  var max_i = s.length - 1 | 0;
  if (next > max_i) {
    return err_unescaped(errs, /* "\\" */92, s);
  } else {
    var c = caml_string.get(s, next);
    if (is_markup_esc(caml_string.get(s, next))) {
      if (curry._1(target_need_escape, c)) {
        curry._2(target_escape, b, c);
      } else {
        buffer.add_char(b, c);
      }
      return curry._2(k, next + 1 | 0, next + 1 | 0);
    } else {
      err_illegal_esc(errs, c, s);
      return curry._2(k, next + 1 | 0, next + 1 | 0);
    }
  }
}

function add_markup_text(errs, k, b, s, start, target_need_escape, target_escape) {
  var max_i = s.length - 1 | 0;
  var flush = function (start, stop) {
    var match = start > max_i;
    if (match) {
      return /* () */0;
    } else {
      return buffer.add_substring(b, s, start, (stop - start | 0) + 1 | 0);
    }
  };
  var loop = function (_start, _i) {
    while(true) {
      var i = _i;
      var start = _start;
      if (i > max_i) {
        err_unclosed(errs, s);
        return flush(start, max_i);
      } else {
        var next = i + 1 | 0;
        var c = caml_string.get(s, i);
        if (c !== 41) {
          if (c !== 92) {
            if (markup_text_need_esc(c)) {
              err_unescaped(errs, c, s);
              flush(start, i - 1 | 0);
              _i = next;
              _start = next;
              continue ;
            } else if (curry._1(target_need_escape, c)) {
              flush(start, i - 1 | 0);
              curry._2(target_escape, b, c);
              _i = next;
              _start = next;
              continue ;
            } else {
              _i = next;
              continue ;
            }
          } else {
            flush(start, i - 1 | 0);
            return add_markup_esc(errs, loop, b, s, start, next, target_need_escape, target_escape);
          }
        } else {
          flush(start, i - 1 | 0);
          return curry._2(k, next, next);
        }
      }
    }  };
  return loop(start, start);
}

function doc_to_plain(errs, subst, b, s) {
  var errs$1 = errs;
  var b$1 = b;
  var s$1 = subst_vars(errs, subst, b, s);
  var max_i = s$1.length - 1 | 0;
  var flush = function (start, stop) {
    var match = start > max_i;
    if (match) {
      return /* () */0;
    } else {
      return buffer.add_substring(b$1, s$1, start, (stop - start | 0) + 1 | 0);
    }
  };
  var need_escape = function (param) {
    return false;
  };
  var $$escape = function (param, param$1) {
    throw [
          caml_builtin_exceptions.assert_failure,
          /* tuple */[
            "cmdliner_manpage.ml",
            271,
            19
          ]
        ];
  };
  var loop = function (_start, _i) {
    while(true) {
      var i = _i;
      var start = _start;
      if (i > max_i) {
        return flush(start, max_i);
      } else {
        var next = i + 1 | 0;
        var c = caml_string.get(s$1, i);
        if (c !== 36) {
          if (c !== 92) {
            if (markup_need_esc(c)) {
              err_unescaped(errs$1, c, s$1);
              flush(start, i - 1 | 0);
              _i = next;
              _start = next;
              continue ;
            } else {
              _i = next;
              continue ;
            }
          } else {
            flush(start, i - 1 | 0);
            return add_markup_esc(errs$1, loop, b$1, s$1, start, next, need_escape, $$escape);
          }
        } else if (next > max_i) {
          return err_unescaped(errs$1, /* "$" */36, s$1);
        } else {
          var match = caml_string.get(s$1, next);
          if (match !== 40) {
            err_unescaped(errs$1, /* "$" */36, s$1);
            _i = next;
            continue ;
          } else {
            var min = next + 2 | 0;
            if (min > max_i) {
              err_unclosed(errs$1, s$1);
              _i = next;
              continue ;
            } else {
              var match$1 = caml_string.get(s$1, min);
              if (match$1 !== 44) {
                err_malformed(errs$1, s$1);
                _i = next;
                continue ;
              } else {
                var markup = caml_string.get(s$1, min - 1 | 0);
                if (is_markup_dir(markup)) {
                  var start_data = min + 1 | 0;
                  flush(start, i - 1 | 0);
                  return add_markup_text(errs$1, loop, b$1, s$1, start_data, need_escape, $$escape);
                } else {
                  err_markup(errs$1, markup, s$1);
                  _i = next;
                  continue ;
                }
              }
            }
          }
        }
      }
    }  };
  buffer.clear(b$1);
  loop(0, 0);
  return buffer.contents(b$1);
}

function pp_to_temp_file(pp_v, v) {
  try {
    var exec = curry._1(filename.basename, caml_array.caml_array_get(sys.argv, 0));
    var match = filename.open_temp_file(undefined, undefined, undefined, exec, "out");
    var oc = match[1];
    var file = match[0];
    var ppf = format.formatter_of_out_channel(oc);
    curry._2(pp_v, ppf, v);
    format.pp_print_flush(ppf, /* () */0);
    pervasives.close_out(oc);
    pervasives.at_exit((function (param) {
            try {
              return caml_external_polyfill.resolve("caml_sys_remove")(file);
            }
            catch (raw_exn){
              var exn = caml_js_exceptions.internalToOCamlException(raw_exn);
              if (exn[0] === caml_builtin_exceptions.sys_error) {
                return /* () */0;
              } else {
                throw exn;
              }
            }
          }));
    return file;
  }
  catch (raw_exn){
    var exn = caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] === caml_builtin_exceptions.sys_error) {
      return ;
    } else {
      throw exn;
    }
  }
}

function find_cmd(cmds) {
  var match = /* tuple */[
    "type",
    "/dev/null"
  ];
  var $$null = match[1];
  var test = match[0];
  var cmd = function (c) {
    return caml_sys.caml_sys_system_command(curry._4(printf_1.sprintf(/* Format */[
                        /* String */block.__(2, [
                            /* No_padding */0,
                            /* Char_literal */block.__(12, [
                                /* " " */32,
                                /* String */block.__(2, [
                                    /* No_padding */0,
                                    /* String_literal */block.__(11, [
                                        " 1>",
                                        /* String */block.__(2, [
                                            /* No_padding */0,
                                            /* String_literal */block.__(11, [
                                                " 2>",
                                                /* String */block.__(2, [
                                                    /* No_padding */0,
                                                    /* End_of_format */0
                                                  ])
                                              ])
                                          ])
                                      ])
                                  ])
                              ])
                          ]),
                        "%s %s 1>%s 2>%s"
                      ]), test, c, $$null, $$null)) === 0;
  };
  try {
    return list.find(cmd, cmds);
  }
  catch (exn){
    if (exn === caml_builtin_exceptions.not_found) {
      return ;
    } else {
      throw exn;
    }
  }
}

function print$1(_$staropt$star, _$staropt$star$1, _fmt, ppf, page) {
  while(true) {
    var fmt = _fmt;
    var $staropt$star = _$staropt$star$1;
    var $staropt$star$1 = _$staropt$star;
    var errs = $staropt$star$1 !== undefined ? caml_option.valFromOption($staropt$star$1) : format.err_formatter;
    var subst = $staropt$star !== undefined ? $staropt$star : (function (x) {
          return ;
        });
    if (fmt >= 726666127) {
      if (fmt >= 757208580) {
        var errs$1 = errs;
        var subst$1 = subst;
        var ppf$1 = ppf;
        var param = page;
        var match = param[0];
        return curry._7(format.fprintf(ppf$1, /* Format */[
                        /* String_literal */block.__(11, [
                            ".\\\" Pipe this output to groff -Tutf8 | less",
                            /* Formatting_lit */block.__(17, [
                                /* Force_newline */3,
                                /* String_literal */block.__(11, [
                                    ".\\\"",
                                    /* Formatting_lit */block.__(17, [
                                        /* Force_newline */3,
                                        /* String_literal */block.__(11, [
                                            ".mso an.tmac",
                                            /* Formatting_lit */block.__(17, [
                                                /* Force_newline */3,
                                                /* String_literal */block.__(11, [
                                                    ".TH \"",
                                                    /* String */block.__(2, [
                                                        /* No_padding */0,
                                                        /* String_literal */block.__(11, [
                                                            "\" ",
                                                            /* Int */block.__(4, [
                                                                /* Int_d */0,
                                                                /* No_padding */0,
                                                                /* No_precision */0,
                                                                /* String_literal */block.__(11, [
                                                                    " \"",
                                                                    /* String */block.__(2, [
                                                                        /* No_padding */0,
                                                                        /* String_literal */block.__(11, [
                                                                            "\" \"",
                                                                            /* String */block.__(2, [
                                                                                /* No_padding */0,
                                                                                /* String_literal */block.__(11, [
                                                                                    "\" \"",
                                                                                    /* String */block.__(2, [
                                                                                        /* No_padding */0,
                                                                                        /* Char_literal */block.__(12, [
                                                                                            /* "\"" */34,
                                                                                            /* Formatting_lit */block.__(17, [
                                                                                                /* Force_newline */3,
                                                                                                /* String_literal */block.__(11, [
                                                                                                    ".\\\" Disable hyphenation and ragged-right",
                                                                                                    /* Formatting_lit */block.__(17, [
                                                                                                        /* Force_newline */3,
                                                                                                        /* String_literal */block.__(11, [
                                                                                                            ".nh",
                                                                                                            /* Formatting_lit */block.__(17, [
                                                                                                                /* Force_newline */3,
                                                                                                                /* String_literal */block.__(11, [
                                                                                                                    ".ad l",
                                                                                                                    /* Alpha */block.__(15, [/* Formatting_lit */block.__(17, [
                                                                                                                            /* FFlush */2,
                                                                                                                            /* End_of_format */0
                                                                                                                          ])])
                                                                                                                  ])
                                                                                                              ])
                                                                                                          ])
                                                                                                      ])
                                                                                                  ])
                                                                                              ])
                                                                                          ])
                                                                                      ])
                                                                                  ])
                                                                              ])
                                                                          ])
                                                                      ])
                                                                  ])
                                                              ])
                                                          ])
                                                      ])
                                                  ])
                                              ])
                                          ])
                                      ])
                                  ])
                              ])
                          ]),
                        ".\\\" Pipe this output to groff -Tutf8 | less@\n.\\\"@\n.mso an.tmac@\n.TH \"%s\" %d \"%s\" \"%s\" \"%s\"@\n.\\\" Disable hyphenation and ragged-right@\n.nh@\n.ad l%a@?"
                      ]), match[0], match[1], match[2], match[3], match[4], (function(errs$1,subst$1){
                  return function (param, param$1) {
                    var errs$2 = errs$1;
                    var subst$2 = subst$1;
                    var ppf = param;
                    var text = param$1;
                    var buf = buffer.create(1024);
                    var markup = function (t) {
                      var errs$3 = errs$2;
                      var subst$3 = subst$2;
                      var b = buf;
                      var s = t;
                      var errs$4 = errs$3;
                      var b$1 = b;
                      var s$1 = subst_vars(errs$3, subst$3, b, s);
                      var max_i = s$1.length - 1 | 0;
                      var flush = function (start, stop) {
                        var match = start > max_i;
                        if (match) {
                          return /* () */0;
                        } else {
                          return buffer.add_substring(b$1, s$1, start, (stop - start | 0) + 1 | 0);
                        }
                      };
                      var need_escape = function (param) {
                        var switcher = param - 39 | 0;
                        if (switcher > 7 || switcher < 0) {
                          return switcher === 53;
                        } else {
                          return switcher > 5 || switcher < 1;
                        }
                      };
                      var $$escape = function (b, c) {
                        return curry._1(printf_1.bprintf(b, /* Format */[
                                        /* String_literal */block.__(11, [
                                            "\\N'",
                                            /* Int */block.__(4, [
                                                /* Int_d */0,
                                                /* No_padding */0,
                                                /* No_precision */0,
                                                /* Char_literal */block.__(12, [
                                                    /* "'" */39,
                                                    /* End_of_format */0
                                                  ])
                                              ])
                                          ]),
                                        "\\N'%d'"
                                      ]), c);
                      };
                      var end_text = function (start, i) {
                        buffer.add_string(b$1, "\\fR");
                        return loop(start, i);
                      };
                      var loop = function (_start, _i) {
                        while(true) {
                          var i = _i;
                          var start = _start;
                          if (i > max_i) {
                            return flush(start, max_i);
                          } else {
                            var next = i + 1 | 0;
                            var c = caml_string.get(s$1, i);
                            if (c !== 36) {
                              if (c !== 92) {
                                if (markup_need_esc(c)) {
                                  err_unescaped(errs$4, c, s$1);
                                  flush(start, i - 1 | 0);
                                  _i = next;
                                  _start = next;
                                  continue ;
                                } else if (need_escape(c)) {
                                  flush(start, i - 1 | 0);
                                  $$escape(b$1, c);
                                  _i = next;
                                  _start = next;
                                  continue ;
                                } else {
                                  _i = next;
                                  continue ;
                                }
                              } else {
                                flush(start, i - 1 | 0);
                                return add_markup_esc(errs$4, loop, b$1, s$1, start, next, need_escape, $$escape);
                              }
                            } else if (next > max_i) {
                              return err_unescaped(errs$4, /* "$" */36, s$1);
                            } else {
                              var match = caml_string.get(s$1, next);
                              if (match !== 40) {
                                err_unescaped(errs$4, /* "$" */36, s$1);
                                flush(start, i - 1 | 0);
                                _i = next;
                                _start = next;
                                continue ;
                              } else {
                                var min = next + 2 | 0;
                                if (min > max_i) {
                                  err_unclosed(errs$4, s$1);
                                  _i = next;
                                  continue ;
                                } else {
                                  var match$1 = caml_string.get(s$1, min);
                                  if (match$1 !== 44) {
                                    err_malformed(errs$4, s$1);
                                    _i = next;
                                    continue ;
                                  } else {
                                    var start_data = min + 1 | 0;
                                    flush(start, i - 1 | 0);
                                    var markup = caml_string.get(s$1, min - 1 | 0);
                                    if (markup !== 98) {
                                      if (markup !== 105) {
                                        err_markup(errs$4, markup, s$1);
                                      } else {
                                        buffer.add_string(b$1, "\\fI");
                                      }
                                    } else {
                                      buffer.add_string(b$1, "\\fB");
                                    }
                                    return add_markup_text(errs$4, end_text, b$1, s$1, start_data, need_escape, $$escape);
                                  }
                                }
                              }
                            }
                          }
                        }                      };
                      buffer.clear(b$1);
                      loop(0, 0);
                      return buffer.contents(b$1);
                    };
                    var pp_tokens = function (ppf, t) {
                      return cmdliner_base_bs.pp_tokens(false, ppf, t);
                    };
                    var pp_block = function (param) {
                      if (typeof param === "number") {
                        return format.fprintf(ppf, /* Format */[
                                    /* Formatting_lit */block.__(17, [
                                        /* Force_newline */3,
                                        /* String_literal */block.__(11, [
                                            ".sp -1",
                                            /* End_of_format */0
                                          ])
                                      ]),
                                    "@\n.sp -1"
                                  ]);
                      } else {
                        var variant = param[0];
                        if (variant !== 73) {
                          if (variant >= 83) {
                            if (variant >= 4003843) {
                              return curry._2(format.fprintf(ppf, /* Format */[
                                              /* Formatting_lit */block.__(17, [
                                                  /* Force_newline */3,
                                                  /* String_literal */block.__(11, [
                                                      ".P",
                                                      /* Formatting_lit */block.__(17, [
                                                          /* Force_newline */3,
                                                          /* String_literal */block.__(11, [
                                                              ".nf",
                                                              /* Formatting_lit */block.__(17, [
                                                                  /* Force_newline */3,
                                                                  /* Alpha */block.__(15, [/* Formatting_lit */block.__(17, [
                                                                          /* Force_newline */3,
                                                                          /* String_literal */block.__(11, [
                                                                              ".fi",
                                                                              /* End_of_format */0
                                                                            ])
                                                                        ])])
                                                                ])
                                                            ])
                                                        ])
                                                    ])
                                                ]),
                                              "@\n.P@\n.nf@\n%a@\n.fi"
                                            ]), cmdliner_base_bs.pp_lines, markup(param[1]));
                            } else {
                              return curry._2(format.fprintf(ppf, /* Format */[
                                              /* Formatting_lit */block.__(17, [
                                                  /* Force_newline */3,
                                                  /* String_literal */block.__(11, [
                                                      ".SH ",
                                                      /* Alpha */block.__(15, [/* End_of_format */0])
                                                    ])
                                                ]),
                                              "@\n.SH %a"
                                            ]), pp_tokens, markup(param[1]));
                            }
                          } else if (variant >= 80) {
                            return curry._2(format.fprintf(ppf, /* Format */[
                                            /* Formatting_lit */block.__(17, [
                                                /* Force_newline */3,
                                                /* String_literal */block.__(11, [
                                                    ".P",
                                                    /* Formatting_lit */block.__(17, [
                                                        /* Force_newline */3,
                                                        /* Alpha */block.__(15, [/* End_of_format */0])
                                                      ])
                                                  ])
                                              ]),
                                            "@\n.P@\n%a"
                                          ]), pp_tokens, markup(param[1]));
                          } else {
                            return list.iter(pp_block, param[1]);
                          }
                        } else {
                          var match = param[1];
                          return curry._4(format.fprintf(ppf, /* Format */[
                                          /* Formatting_lit */block.__(17, [
                                              /* Force_newline */3,
                                              /* String_literal */block.__(11, [
                                                  ".TP 4",
                                                  /* Formatting_lit */block.__(17, [
                                                      /* Force_newline */3,
                                                      /* Alpha */block.__(15, [/* Formatting_lit */block.__(17, [
                                                              /* Force_newline */3,
                                                              /* Alpha */block.__(15, [/* End_of_format */0])
                                                            ])])
                                                    ])
                                                ])
                                            ]),
                                          "@\n.TP 4@\n%a@\n%a"
                                        ]), pp_tokens, markup(match[0]), pp_tokens, markup(match[1]));
                        }
                      }
                    };
                    return list.iter(pp_block, text);
                  }
                  }(errs$1,subst$1)), param[1]);
      } else {
        var match$1;
        try {
          match$1 = caml_sys.caml_sys_getenv("TERM");
        }
        catch (exn){
          if (exn === caml_builtin_exceptions.not_found) {
            match$1 = undefined;
          } else {
            throw exn;
          }
        }
        if (match$1 !== undefined && match$1 !== "dumb") {
          _fmt = /* Pager */-797271261;
          _$staropt$star$1 = subst;
          _$staropt$star = caml_option.some(errs);
          continue ;
        }
        _fmt = /* Plain */-675583510;
        _$staropt$star$1 = subst;
        _$staropt$star = caml_option.some(errs);
        continue ;
      }
    } else if (fmt >= -675583510) {
      var errs$2 = errs;
      var subst$2 = subst;
      var ppf$2 = ppf;
      var param$1 = page;
      return curry._2(format.fprintf(ppf$2, /* Format */[
                      /* Formatting_gen */block.__(18, [
                          /* Open_box */block.__(1, [/* Format */[
                                /* String_literal */block.__(11, [
                                    "<v>",
                                    /* End_of_format */0
                                  ]),
                                "<v>"
                              ]]),
                          /* Alpha */block.__(15, [/* Formatting_lit */block.__(17, [
                                  /* Close_box */0,
                                  /* End_of_format */0
                                ])])
                        ]),
                      "@[<v>%a@]"
                    ]), (function(errs$2,subst$2){
                return function (param, param$1) {
                  var errs$3 = errs$2;
                  var subst$3 = subst$2;
                  var ppf = param;
                  var ts = param$1;
                  var b = buffer.create(1024);
                  var markup = function (t) {
                    return doc_to_plain(errs$3, subst$3, b, t);
                  };
                  var pp_tokens = function (ppf, t) {
                    return cmdliner_base_bs.pp_tokens(true, ppf, t);
                  };
                  var loop = function (_param) {
                    while(true) {
                      var param = _param;
                      if (param) {
                        var ts = param[1];
                        var t = param[0];
                        if (typeof t !== "number") {
                          var variant = t[0];
                          if (variant !== 73) {
                            if (variant >= 83) {
                              if (variant >= 4003843) {
                                curry._4(format.fprintf(ppf, /* Format */[
                                          /* Alpha */block.__(15, [/* Formatting_gen */block.__(18, [
                                                  /* Open_box */block.__(1, [/* Format */[
                                                        /* End_of_format */0,
                                                        ""
                                                      ]]),
                                                  /* Alpha */block.__(15, [/* Formatting_lit */block.__(17, [
                                                          /* Close_box */0,
                                                          /* Formatting_lit */block.__(17, [
                                                              /* Break */block.__(0, [
                                                                  "@,",
                                                                  0,
                                                                  0
                                                                ]),
                                                              /* End_of_format */0
                                                            ])
                                                        ])])
                                                ])]),
                                          "%a@[%a@]@,"
                                        ]), pp_indent, 7, cmdliner_base_bs.pp_lines, markup(t[1]));
                              } else {
                                curry._2(format.fprintf(ppf, /* Format */[
                                          /* Formatting_gen */block.__(18, [
                                              /* Open_box */block.__(1, [/* Format */[
                                                    /* End_of_format */0,
                                                    ""
                                                  ]]),
                                              /* Alpha */block.__(15, [/* Formatting_lit */block.__(17, [
                                                      /* Close_box */0,
                                                      /* End_of_format */0
                                                    ])])
                                            ]),
                                          "@[%a@]"
                                        ]), pp_tokens, markup(t[1]));
                              }
                            } else if (variant >= 80) {
                              curry._4(format.fprintf(ppf, /* Format */[
                                        /* Alpha */block.__(15, [/* Formatting_gen */block.__(18, [
                                                /* Open_box */block.__(1, [/* Format */[
                                                      /* End_of_format */0,
                                                      ""
                                                    ]]),
                                                /* Alpha */block.__(15, [/* Formatting_lit */block.__(17, [
                                                        /* Close_box */0,
                                                        /* Formatting_lit */block.__(17, [
                                                            /* Break */block.__(0, [
                                                                "@,",
                                                                0,
                                                                0
                                                              ]),
                                                            /* End_of_format */0
                                                          ])
                                                      ])])
                                              ])]),
                                        "%a@[%a@]@,"
                                      ]), pp_indent, 7, pp_tokens, markup(t[1]));
                            } else {
                              loop(t[1]);
                            }
                          } else {
                            var match = t[1];
                            var label = markup(match[0]);
                            var s = markup(match[1]);
                            curry._4(format.fprintf(ppf, /* Format */[
                                      /* Formatting_gen */block.__(18, [
                                          /* Open_box */block.__(1, [/* Format */[
                                                /* End_of_format */0,
                                                ""
                                              ]]),
                                          /* Alpha */block.__(15, [/* Formatting_gen */block.__(18, [
                                                  /* Open_box */block.__(1, [/* Format */[
                                                        /* End_of_format */0,
                                                        ""
                                                      ]]),
                                                  /* Alpha */block.__(15, [/* Formatting_lit */block.__(17, [
                                                          /* Close_box */0,
                                                          /* End_of_format */0
                                                        ])])
                                                ])])
                                        ]),
                                      "@[%a@[%a@]"
                                    ]), pp_indent, 7, pp_tokens, label);
                            if (s === "") {
                              format.fprintf(ppf, /* Format */[
                                    /* Formatting_lit */block.__(17, [
                                        /* Close_box */0,
                                        /* Formatting_lit */block.__(17, [
                                            /* Break */block.__(0, [
                                                "@,",
                                                0,
                                                0
                                              ]),
                                            /* End_of_format */0
                                          ])
                                      ]),
                                    "@]@,"
                                  ]);
                            } else {
                              var ll = label.length;
                              var match$1 = ll < 4;
                              if (match$1) {
                                curry._4(format.fprintf(ppf, /* Format */[
                                          /* Alpha */block.__(15, [/* Formatting_gen */block.__(18, [
                                                  /* Open_box */block.__(1, [/* Format */[
                                                        /* End_of_format */0,
                                                        ""
                                                      ]]),
                                                  /* Alpha */block.__(15, [/* Formatting_lit */block.__(17, [
                                                          /* Close_box */0,
                                                          /* Formatting_lit */block.__(17, [
                                                              /* Close_box */0,
                                                              /* End_of_format */0
                                                            ])
                                                        ])])
                                                ])]),
                                          "%a@[%a@]@]"
                                        ]), pp_indent, 4 - ll | 0, pp_tokens, s);
                              } else {
                                curry._4(format.fprintf(ppf, /* Format */[
                                          /* Formatting_lit */block.__(17, [
                                              /* Force_newline */3,
                                              /* Alpha */block.__(15, [/* Formatting_gen */block.__(18, [
                                                      /* Open_box */block.__(1, [/* Format */[
                                                            /* End_of_format */0,
                                                            ""
                                                          ]]),
                                                      /* Alpha */block.__(15, [/* Formatting_lit */block.__(17, [
                                                              /* Close_box */0,
                                                              /* Formatting_lit */block.__(17, [
                                                                  /* Close_box */0,
                                                                  /* End_of_format */0
                                                                ])
                                                            ])])
                                                    ])])
                                            ]),
                                          "@\n%a@[%a@]@]"
                                        ]), pp_indent, 11, pp_tokens, s);
                              }
                              if (ts) {
                                var match$2 = ts[0];
                                if (typeof match$2 !== "number") {
                                  if (match$2[0] !== 73) ; else {
                                    format.fprintf(ppf, /* Format */[
                                          /* Formatting_lit */block.__(17, [
                                              /* Break */block.__(0, [
                                                  "@,",
                                                  0,
                                                  0
                                                ]),
                                              /* End_of_format */0
                                            ]),
                                          "@,"
                                        ]);
                                  }
                                }
                                
                              }
                              
                            }
                          }
                        }
                        if (ts) {
                          if (ts[0] !== -1038541997) {
                            format.pp_print_cut(ppf, /* () */0);
                            _param = ts;
                            continue ;
                          } else {
                            _param = ts[1];
                            continue ;
                          }
                        } else {
                          format.pp_print_cut(ppf, /* () */0);
                          _param = ts;
                          continue ;
                        }
                      } else {
                        return /* () */0;
                      }
                    }                  };
                  return loop(ts);
                }
                }(errs$2,subst$2)), param$1[1]);
    } else {
      var partial_arg = subst;
      var partial_arg$1 = caml_option.some(errs);
      var print$1$1 = (function(partial_arg,partial_arg$1){
      return function print$1$1(param, param$1, param$2) {
        return print$1(partial_arg$1, partial_arg, param, param$1, param$2);
      }
      }(partial_arg,partial_arg$1));
      var ppf$3 = ppf;
      var v = page;
      var cmds = /* :: */[
        "less",
        /* :: */[
          "more",
          /* [] */0
        ]
      ];
      var cmds$1;
      try {
        cmds$1 = /* :: */[
          caml_sys.caml_sys_getenv("PAGER"),
          cmds
        ];
      }
      catch (exn$1){
        if (exn$1 === caml_builtin_exceptions.not_found) {
          cmds$1 = cmds;
        } else {
          throw exn$1;
        }
      }
      var cmds$2;
      try {
        cmds$2 = /* :: */[
          caml_sys.caml_sys_getenv("MANPAGER"),
          cmds$1
        ];
      }
      catch (exn$2){
        if (exn$2 === caml_builtin_exceptions.not_found) {
          cmds$2 = cmds$1;
        } else {
          throw exn$2;
        }
      }
      var pager = find_cmd(cmds$2);
      if (pager !== undefined) {
        var pager$1 = pager;
        var match$2 = find_cmd(/* :: */[
              "groff",
              /* :: */[
                "nroff",
                /* [] */0
              ]
            ]);
        var cmd;
        if (match$2 !== undefined) {
          var c = match$2;
          var match$3 = pp_to_temp_file(curry._1(print$1$1, /* Groff */757208580), v);
          if (match$3 !== undefined) {
            var xroff = c === "groff" ? c + " -Tascii -P-c" : c;
            cmd = curry._3(printf_1.sprintf(/* Format */[
                      /* String */block.__(2, [
                          /* No_padding */0,
                          /* String_literal */block.__(11, [
                              " < ",
                              /* String */block.__(2, [
                                  /* No_padding */0,
                                  /* String_literal */block.__(11, [
                                      " | ",
                                      /* String */block.__(2, [
                                          /* No_padding */0,
                                          /* End_of_format */0
                                        ])
                                    ])
                                ])
                            ])
                        ]),
                      "%s < %s | %s"
                    ]), xroff, match$3, pager$1);
          } else {
            cmd = undefined;
          }
        } else {
          var match$4 = pp_to_temp_file(curry._1(print$1$1, /* Plain */-675583510), v);
          cmd = match$4 !== undefined ? curry._2(printf_1.sprintf(/* Format */[
                      /* String */block.__(2, [
                          /* No_padding */0,
                          /* String_literal */block.__(11, [
                              " < ",
                              /* String */block.__(2, [
                                  /* No_padding */0,
                                  /* End_of_format */0
                                ])
                            ])
                        ]),
                      "%s < %s"
                    ]), pager$1, match$4) : undefined;
        }
        if (cmd !== undefined && caml_sys.caml_sys_system_command(cmd) === 0) {
          return 0;
        } else {
          return curry._3(print$1$1, /* Plain */-675583510, ppf$3, v);
        }
      } else {
        return curry._3(print$1$1, /* Plain */-675583510, ppf$3, v);
      }
    }
  }}

var s_exit_status_intro = /* `P */[
  80,
  "$(tname) exits with the following status:"
];

var s_environment_intro = /* `P */[
  80,
  "These environment variables affect the execution of $(tname):"
];

var $$escape_1 = $$escape;
var s_name_1 = s_name;
var s_synopsis_1 = s_synopsis;
var s_description_1 = s_description;
var s_commands_1 = s_commands;
var s_arguments_1 = s_arguments;
var s_options_1 = s_options;
var s_common_options_1 = s_common_options;
var s_exit_status_1 = s_exit_status;
var s_environment_1 = s_environment;
var s_files_1 = s_files;
var s_bugs_1 = s_bugs;
var s_examples_1 = s_examples;
var s_authors_1 = s_authors;
var s_see_also_1 = s_see_also;
var smap_of_blocks_1 = smap_of_blocks;
var smap_to_blocks_1 = smap_to_blocks;
var smap_has_section_1 = smap_has_section;
var smap_append_block_1 = smap_append_block;
var s_exit_status_intro_1 = s_exit_status_intro;
var s_environment_intro_1 = s_environment_intro;
var print_1$1 = print$1;
var subst_vars_1 = subst_vars;
var doc_to_plain_1 = doc_to_plain;
/* Format Not a pure module */

var cmdliner_manpage_bs = {
	$$escape: $$escape_1,
	s_name: s_name_1,
	s_synopsis: s_synopsis_1,
	s_description: s_description_1,
	s_commands: s_commands_1,
	s_arguments: s_arguments_1,
	s_options: s_options_1,
	s_common_options: s_common_options_1,
	s_exit_status: s_exit_status_1,
	s_environment: s_environment_1,
	s_files: s_files_1,
	s_bugs: s_bugs_1,
	s_examples: s_examples_1,
	s_authors: s_authors_1,
	s_see_also: s_see_also_1,
	smap_of_blocks: smap_of_blocks_1,
	smap_to_blocks: smap_to_blocks_1,
	smap_has_section: smap_has_section_1,
	smap_append_block: smap_append_block_1,
	s_exit_status_intro: s_exit_status_intro_1,
	s_environment_intro: s_environment_intro_1,
	print: print_1$1,
	subst_vars: subst_vars_1,
	doc_to_plain: doc_to_plain_1
};

var c = {
  contents: 0
};

function new_id(param) {
  var id = c.contents;
  c.contents = c.contents + 1 | 0;
  if (id > c.contents) {
    throw [
          caml_builtin_exceptions.assert_failure,
          /* tuple */[
            "cmdliner_info.ml",
            12,
            28
          ]
        ];
  }
  return id;
}

function env($staropt$star, $staropt$star$1, env_var) {
  var env_docs = $staropt$star !== undefined ? $staropt$star : cmdliner_manpage_bs.s_environment;
  var env_doc = $staropt$star$1 !== undefined ? $staropt$star$1 : "See option $(opt).";
  return {
          env_id: new_id(),
          env_var: env_var,
          env_doc: env_doc,
          env_docs: env_docs
        };
}

function env_var(e) {
  return e.env_var;
}

function env_doc(e) {
  return e.env_doc;
}

function env_docs(e) {
  return e.env_docs;
}

function compare$7(a0, a1) {
  return caml_primitive.caml_int_compare(a0.env_id, a1.env_id);
}

var Env = {
  compare: compare$7
};

var Envs = set.Make(Env);

function pos(pos_rev, pos_start, pos_len) {
  return {
          pos_rev: pos_rev,
          pos_start: pos_start,
          pos_len: pos_len
        };
}

function pos_rev(p) {
  return p.pos_rev;
}

function pos_start(p) {
  return p.pos_start;
}

function pos_len(p) {
  return p.pos_len;
}

var dumb_pos = {
  pos_rev: false,
  pos_start: -1,
  pos_len: undefined
};

function arg(docs, $staropt$star, $staropt$star$1, env, names) {
  var docv = $staropt$star !== undefined ? $staropt$star : "";
  var doc = $staropt$star$1 !== undefined ? $staropt$star$1 : "";
  var dash = function (n) {
    if (n.length === 1) {
      return "-" + n;
    } else {
      return "--" + n;
    }
  };
  var opt_names = list.map(dash, names);
  var docs$1 = docs !== undefined ? docs : (
      names ? cmdliner_manpage_bs.s_options : cmdliner_manpage_bs.s_arguments
    );
  return {
          id: new_id(),
          absent: /* Val */[""],
          env: env,
          doc: doc,
          docv: docv,
          docs: docs$1,
          pos: dumb_pos,
          opt_kind: /* Flag */0,
          opt_names: opt_names,
          opt_all: false
        };
}

function arg_id(a) {
  return a.id;
}

function arg_absent(a) {
  return a.absent;
}

function arg_env(a) {
  return a.env;
}

function arg_doc(a) {
  return a.doc;
}

function arg_docv(a) {
  return a.docv;
}

function arg_docs(a) {
  return a.docs;
}

function arg_pos(a) {
  return a.pos;
}

function arg_opt_kind(a) {
  return a.opt_kind;
}

function arg_opt_names(a) {
  return a.opt_names;
}

function arg_opt_name_sample(a) {
  var _param = a.opt_names;
  while(true) {
    var param = _param;
    if (param) {
      var n = param[0];
      if (n.length > 2) {
        return n;
      } else {
        _param = param[1];
        continue ;
      }
    } else {
      return list.hd(a.opt_names);
    }
  }}

function arg_make_req(a) {
  return {
          id: a.id,
          absent: /* Err */0,
          env: a.env,
          doc: a.doc,
          docv: a.docv,
          docs: a.docs,
          pos: a.pos,
          opt_kind: a.opt_kind,
          opt_names: a.opt_names,
          opt_all: a.opt_all
        };
}

function arg_make_all_opts(a) {
  return {
          id: a.id,
          absent: a.absent,
          env: a.env,
          doc: a.doc,
          docv: a.docv,
          docs: a.docs,
          pos: a.pos,
          opt_kind: a.opt_kind,
          opt_names: a.opt_names,
          opt_all: true
        };
}

function arg_make_opt(absent, opt_kind, a) {
  return {
          id: a.id,
          absent: absent,
          env: a.env,
          doc: a.doc,
          docv: a.docv,
          docs: a.docs,
          pos: a.pos,
          opt_kind: opt_kind,
          opt_names: a.opt_names,
          opt_all: a.opt_all
        };
}

function arg_make_opt_all(absent, opt_kind, a) {
  return {
          id: a.id,
          absent: absent,
          env: a.env,
          doc: a.doc,
          docv: a.docv,
          docs: a.docs,
          pos: a.pos,
          opt_kind: opt_kind,
          opt_names: a.opt_names,
          opt_all: true
        };
}

function arg_make_pos(pos, a) {
  return {
          id: a.id,
          absent: a.absent,
          env: a.env,
          doc: a.doc,
          docv: a.docv,
          docs: a.docs,
          pos: pos,
          opt_kind: a.opt_kind,
          opt_names: a.opt_names,
          opt_all: a.opt_all
        };
}

function arg_make_pos_abs(absent, pos, a) {
  return {
          id: a.id,
          absent: absent,
          env: a.env,
          doc: a.doc,
          docv: a.docv,
          docs: a.docs,
          pos: pos,
          opt_kind: a.opt_kind,
          opt_names: a.opt_names,
          opt_all: a.opt_all
        };
}

function arg_is_opt(a) {
  return a.opt_names !== /* [] */0;
}

function arg_is_pos(a) {
  return a.opt_names === /* [] */0;
}

function arg_is_req(a) {
  return a.absent === /* Err */0;
}

function arg_pos_cli_order(a0, a1) {
  var c = caml_primitive.caml_bool_compare(a0.pos.pos_rev, a1.pos.pos_rev);
  if (c !== 0) {
    return c;
  } else if (a0.pos.pos_rev) {
    return caml_primitive.caml_int_compare(a1.pos.pos_start, a0.pos.pos_start);
  } else {
    return caml_primitive.caml_int_compare(a0.pos.pos_start, a1.pos.pos_start);
  }
}

function rev_arg_pos_cli_order(a0, a1) {
  return arg_pos_cli_order(a1, a0);
}

function compare$1$1(a0, a1) {
  return caml_primitive.caml_int_compare(a0.id, a1.id);
}

var Arg = {
  compare: compare$1$1
};

var Args = set.Make(Arg);

function exit$1($staropt$star, $staropt$star$1, max, min) {
  var exit_docs = $staropt$star !== undefined ? $staropt$star : cmdliner_manpage_bs.s_exit_status;
  var exit_doc = $staropt$star$1 !== undefined ? $staropt$star$1 : "undocumented";
  var max$1 = max !== undefined ? max : min;
  return {
          exit_statuses: /* tuple */[
            min,
            max$1
          ],
          exit_doc: exit_doc,
          exit_docs: exit_docs
        };
}

function exit_statuses(e) {
  return e.exit_statuses;
}

function exit_doc(e) {
  return e.exit_doc;
}

function exit_docs(e) {
  return e.exit_docs;
}

function exit_order(e0, e1) {
  return caml_obj.caml_compare(e0.exit_statuses, e1.exit_statuses);
}

function term($staropt$star, $staropt$star$1, $staropt$star$2, $staropt$star$3, $staropt$star$4, $staropt$star$5, $staropt$star$6, $staropt$star$7, term_version, term_name) {
  var term_args = $staropt$star !== undefined ? caml_option.valFromOption($staropt$star) : Args.empty;
  var term_man_xrefs = $staropt$star$1 !== undefined ? $staropt$star$1 : /* [] */0;
  var term_man = $staropt$star$2 !== undefined ? $staropt$star$2 : /* [] */0;
  var term_envs = $staropt$star$3 !== undefined ? $staropt$star$3 : /* [] */0;
  var term_exits = $staropt$star$4 !== undefined ? $staropt$star$4 : /* [] */0;
  var term_sdocs = $staropt$star$5 !== undefined ? $staropt$star$5 : cmdliner_manpage_bs.s_options;
  var term_docs = $staropt$star$6 !== undefined ? $staropt$star$6 : "COMMANDS";
  var term_doc = $staropt$star$7 !== undefined ? $staropt$star$7 : "";
  var term_info = {
    term_name: term_name,
    term_version: term_version,
    term_doc: term_doc,
    term_docs: term_docs,
    term_sdocs: term_sdocs,
    term_exits: term_exits,
    term_envs: term_envs,
    term_man: term_man,
    term_man_xrefs: term_man_xrefs
  };
  return {
          term_info: term_info,
          term_args: term_args
        };
}

function term_name(t) {
  return t.term_info.term_name;
}

function term_version(t) {
  return t.term_info.term_version;
}

function term_doc(t) {
  return t.term_info.term_doc;
}

function term_docs(t) {
  return t.term_info.term_docs;
}

function term_stdopts_docs(t) {
  return t.term_info.term_sdocs;
}

function term_exits(t) {
  return t.term_info.term_exits;
}

function term_envs(t) {
  return t.term_info.term_envs;
}

function term_man(t) {
  return t.term_info.term_man;
}

function term_man_xrefs(t) {
  return t.term_info.term_man_xrefs;
}

function term_args(t) {
  return t.term_args;
}

function term_add_args(t, args) {
  return {
          term_info: t.term_info,
          term_args: curry._2(Args.union, args, t.term_args)
        };
}

function $$eval(term, main, choices, env) {
  return {
          term: term,
          main: main,
          choices: choices,
          env: env
        };
}

function eval_term(e) {
  return e.term;
}

function eval_main(e) {
  return e.main;
}

function eval_choices(e) {
  return e.choices;
}

function eval_env_var(e, v) {
  return curry._1(e.env, v);
}

function eval_kind(ei) {
  if (ei.choices === /* [] */0) {
    return /* Simple */-317491118;
  } else if (ei.term.term_info.term_name === ei.main.term_info.term_name) {
    return /* Multiple_main */-91404312;
  } else {
    return /* Multiple_sub */491021489;
  }
}

function eval_with_term(ei, term) {
  return {
          term: term,
          main: ei.main,
          choices: ei.choices,
          env: ei.env
        };
}

function eval_has_choice(e, cmd) {
  var is_cmd = function (t) {
    return t.term_info.term_name === cmd;
  };
  return list.exists(is_cmd, e.choices);
}

var env_1 = env;
var env_var_1 = env_var;
var env_doc_1 = env_doc;
var env_docs_1 = env_docs;
var Env_1 = Env;
var Envs_1 = Envs;
var pos_1 = pos;
var pos_rev_1 = pos_rev;
var pos_start_1 = pos_start;
var pos_len_1 = pos_len;
var arg_1 = arg;
var arg_id_1 = arg_id;
var arg_absent_1 = arg_absent;
var arg_env_1 = arg_env;
var arg_doc_1 = arg_doc;
var arg_docv_1 = arg_docv;
var arg_docs_1 = arg_docs;
var arg_opt_names_1 = arg_opt_names;
var arg_opt_name_sample_1 = arg_opt_name_sample;
var arg_opt_kind_1 = arg_opt_kind;
var arg_pos_1 = arg_pos;
var arg_make_req_1 = arg_make_req;
var arg_make_all_opts_1 = arg_make_all_opts;
var arg_make_opt_1 = arg_make_opt;
var arg_make_opt_all_1 = arg_make_opt_all;
var arg_make_pos_1 = arg_make_pos;
var arg_make_pos_abs_1 = arg_make_pos_abs;
var arg_is_opt_1 = arg_is_opt;
var arg_is_pos_1 = arg_is_pos;
var arg_is_req_1 = arg_is_req;
var arg_pos_cli_order_1 = arg_pos_cli_order;
var rev_arg_pos_cli_order_1 = rev_arg_pos_cli_order;
var Arg_1 = Arg;
var Args_1 = Args;
var exit_1$1 = exit$1;
var exit_statuses_1 = exit_statuses;
var exit_doc_1 = exit_doc;
var exit_docs_1 = exit_docs;
var exit_order_1 = exit_order;
var term_1 = term;
var term_name_1 = term_name;
var term_version_1 = term_version;
var term_doc_1 = term_doc;
var term_docs_1 = term_docs;
var term_stdopts_docs_1 = term_stdopts_docs;
var term_exits_1 = term_exits;
var term_envs_1 = term_envs;
var term_man_1 = term_man;
var term_man_xrefs_1 = term_man_xrefs;
var term_args_1 = term_args;
var term_add_args_1 = term_add_args;
var $$eval_1 = $$eval;
var eval_term_1 = eval_term;
var eval_main_1 = eval_main;
var eval_choices_1 = eval_choices;
var eval_env_var_1 = eval_env_var;
var eval_kind_1 = eval_kind;
var eval_with_term_1 = eval_with_term;
var eval_has_choice_1 = eval_has_choice;
/* Envs Not a pure module */

var cmdliner_info_bs = {
	env: env_1,
	env_var: env_var_1,
	env_doc: env_doc_1,
	env_docs: env_docs_1,
	Env: Env_1,
	Envs: Envs_1,
	pos: pos_1,
	pos_rev: pos_rev_1,
	pos_start: pos_start_1,
	pos_len: pos_len_1,
	arg: arg_1,
	arg_id: arg_id_1,
	arg_absent: arg_absent_1,
	arg_env: arg_env_1,
	arg_doc: arg_doc_1,
	arg_docv: arg_docv_1,
	arg_docs: arg_docs_1,
	arg_opt_names: arg_opt_names_1,
	arg_opt_name_sample: arg_opt_name_sample_1,
	arg_opt_kind: arg_opt_kind_1,
	arg_pos: arg_pos_1,
	arg_make_req: arg_make_req_1,
	arg_make_all_opts: arg_make_all_opts_1,
	arg_make_opt: arg_make_opt_1,
	arg_make_opt_all: arg_make_opt_all_1,
	arg_make_pos: arg_make_pos_1,
	arg_make_pos_abs: arg_make_pos_abs_1,
	arg_is_opt: arg_is_opt_1,
	arg_is_pos: arg_is_pos_1,
	arg_is_req: arg_is_req_1,
	arg_pos_cli_order: arg_pos_cli_order_1,
	rev_arg_pos_cli_order: rev_arg_pos_cli_order_1,
	Arg: Arg_1,
	Args: Args_1,
	exit: exit_1$1,
	exit_statuses: exit_statuses_1,
	exit_doc: exit_doc_1,
	exit_docs: exit_docs_1,
	exit_order: exit_order_1,
	term: term_1,
	term_name: term_name_1,
	term_version: term_version_1,
	term_doc: term_doc_1,
	term_docs: term_docs_1,
	term_stdopts_docs: term_stdopts_docs_1,
	term_exits: term_exits_1,
	term_envs: term_envs_1,
	term_man: term_man_1,
	term_man_xrefs: term_man_xrefs_1,
	term_args: term_args_1,
	term_add_args: term_add_args_1,
	$$eval: $$eval_1,
	eval_term: eval_term_1,
	eval_main: eval_main_1,
	eval_choices: eval_choices_1,
	eval_env_var: eval_env_var_1,
	eval_kind: eval_kind_1,
	eval_with_term: eval_with_term_1,
	eval_has_choice: eval_has_choice_1
};

function rev_compare(n0, n1) {
  return caml_obj.caml_compare(n1, n0);
}

function sorted_items_to_blocks(b, items) {
  var boilerplate = b !== undefined ? b : (function (param) {
        return ;
      });
  var mk_block = function (sec, acc) {
    var match = curry._1(boilerplate, sec);
    if (match !== undefined) {
      return /* tuple */[
              sec,
              /* `Blocks */[
                -595680602,
                /* :: */[
                  caml_option.valFromOption(match),
                  acc
                ]
              ]
            ];
    } else {
      return /* tuple */[
              sec,
              /* `Blocks */[
                -595680602,
                acc
              ]
            ];
    }
  };
  if (items) {
    var match = items[0];
    var _secs = /* [] */0;
    var _sec = match[0];
    var _acc = /* :: */[
      match[1],
      /* [] */0
    ];
    var _param = items[1];
    while(true) {
      var param = _param;
      var acc = _acc;
      var sec = _sec;
      var secs = _secs;
      if (param) {
        var its = param[1];
        var match$1 = param[0];
        var it = match$1[1];
        var sec$prime = match$1[0];
        if (caml_obj.caml_equal(sec$prime, sec)) {
          _param = its;
          _acc = /* :: */[
            it,
            acc
          ];
          continue ;
        } else {
          _param = its;
          _acc = /* :: */[
            it,
            /* [] */0
          ];
          _sec = sec$prime;
          _secs = /* :: */[
            mk_block(sec, acc),
            secs
          ];
          continue ;
        }
      } else {
        return /* :: */[
                mk_block(sec, acc),
                secs
              ];
      }
    }  } else {
    return /* [] */0;
  }
}

function env_info_subst(subst, e, id) {
  if (id === "env") {
    return curry._1(printf_1.sprintf(/* Format */[
                    /* String_literal */block.__(11, [
                        "$(b,",
                        /* String */block.__(2, [
                            /* No_padding */0,
                            /* Char_literal */block.__(12, [
                                /* ")" */41,
                                /* End_of_format */0
                              ])
                          ])
                      ]),
                    "$(b,%s)"
                  ]), cmdliner_manpage_bs.$$escape(cmdliner_info_bs.env_var(e)));
  } else {
    return curry._1(subst, id);
  }
}

function arg_info_subst(subst, a, id) {
  switch (id) {
    case "docv" :
        return curry._1(printf_1.sprintf(/* Format */[
                        /* String_literal */block.__(11, [
                            "$(i,",
                            /* String */block.__(2, [
                                /* No_padding */0,
                                /* Char_literal */block.__(12, [
                                    /* ")" */41,
                                    /* End_of_format */0
                                  ])
                              ])
                          ]),
                        "$(i,%s)"
                      ]), cmdliner_manpage_bs.$$escape(cmdliner_info_bs.arg_docv(a)));
    case "env" :
        var match = cmdliner_info_bs.arg_env(a);
        if (match !== undefined) {
          return env_info_subst(subst, caml_option.valFromOption(match), id);
        } else {
          return curry._1(subst, id);
        }
    case "opt" :
        if (cmdliner_info_bs.arg_is_opt(a)) {
          return curry._1(printf_1.sprintf(/* Format */[
                          /* String_literal */block.__(11, [
                              "$(b,",
                              /* String */block.__(2, [
                                  /* No_padding */0,
                                  /* Char_literal */block.__(12, [
                                      /* ")" */41,
                                      /* End_of_format */0
                                    ])
                                ])
                            ]),
                          "$(b,%s)"
                        ]), cmdliner_manpage_bs.$$escape(cmdliner_info_bs.arg_opt_name_sample(a)));
        } else {
          return curry._1(subst, id);
        }
    default:
      return curry._1(subst, id);
  }
}

function term_info_subst(ei, param) {
  switch (param) {
    case "mname" :
        var t = cmdliner_info_bs.eval_main(ei);
        return curry._1(printf_1.sprintf(/* Format */[
                        /* String_literal */block.__(11, [
                            "$(b,",
                            /* String */block.__(2, [
                                /* No_padding */0,
                                /* Char_literal */block.__(12, [
                                    /* ")" */41,
                                    /* End_of_format */0
                                  ])
                              ])
                          ]),
                        "$(b,%s)"
                      ]), cmdliner_manpage_bs.$$escape(cmdliner_info_bs.term_name(t)));
    case "tname" :
        var t$1 = cmdliner_info_bs.eval_term(ei);
        return curry._1(printf_1.sprintf(/* Format */[
                        /* String_literal */block.__(11, [
                            "$(b,",
                            /* String */block.__(2, [
                                /* No_padding */0,
                                /* Char_literal */block.__(12, [
                                    /* ")" */41,
                                    /* End_of_format */0
                                  ])
                              ])
                          ]),
                        "$(b,%s)"
                      ]), cmdliner_manpage_bs.$$escape(cmdliner_info_bs.term_name(t$1)));
    default:
      return ;
  }
}

function invocation($staropt$star, ei) {
  var sep = $staropt$star !== undefined ? $staropt$star : /* " " */32;
  var match = cmdliner_info_bs.eval_kind(ei);
  if (match >= 491021489) {
    return curry._3(printf_1.sprintf(/* Format */[
                    /* String */block.__(2, [
                        /* No_padding */0,
                        /* Char */block.__(0, [/* String */block.__(2, [
                                /* No_padding */0,
                                /* End_of_format */0
                              ])])
                      ]),
                    "%s%c%s"
                  ]), cmdliner_info_bs.term_name(cmdliner_info_bs.eval_main(ei)), sep, cmdliner_info_bs.term_name(cmdliner_info_bs.eval_term(ei)));
  } else {
    var t = cmdliner_info_bs.eval_main(ei);
    return cmdliner_manpage_bs.$$escape(cmdliner_info_bs.term_name(t));
  }
}

function plain_invocation(ei) {
  return invocation(undefined, ei);
}

function synopsis_pos_arg(a) {
  var v = cmdliner_info_bs.arg_docv(a);
  var v$1 = v === "" ? "ARG" : v;
  var v$2 = curry._1(printf_1.sprintf(/* Format */[
            /* String_literal */block.__(11, [
                "$(i,",
                /* String */block.__(2, [
                    /* No_padding */0,
                    /* Char_literal */block.__(12, [
                        /* ")" */41,
                        /* End_of_format */0
                      ])
                  ])
              ]),
            "$(i,%s)"
          ]), cmdliner_manpage_bs.$$escape(v$1));
  var v$3 = curry._1(cmdliner_info_bs.arg_is_req(a) ? printf_1.sprintf(/* Format */[
              /* String */block.__(2, [
                  /* No_padding */0,
                  /* End_of_format */0
                ]),
              "%s"
            ]) : printf_1.sprintf(/* Format */[
              /* Char_literal */block.__(12, [
                  /* "[" */91,
                  /* String */block.__(2, [
                      /* No_padding */0,
                      /* Char_literal */block.__(12, [
                          /* "]" */93,
                          /* End_of_format */0
                        ])
                    ])
                ]),
              "[%s]"
            ]), v$2);
  var match = cmdliner_info_bs.pos_len(cmdliner_info_bs.arg_pos(a));
  if (match !== undefined) {
    var n = match;
    if (n !== 1) {
      var loop = function (_n, _acc) {
        while(true) {
          var acc = _acc;
          var n = _n;
          if (n <= 0) {
            return acc;
          } else {
            _acc = /* :: */[
              v$3,
              acc
            ];
            _n = n - 1 | 0;
            continue ;
          }
        }      };
      return string.concat(" ", loop(n, /* [] */0));
    } else {
      return v$3;
    }
  } else {
    return v$3 + "...";
  }
}

function synopsis(ei) {
  var match = cmdliner_info_bs.eval_kind(ei);
  if (match !== -91404312) {
    var rev_cli_order = function (param, param$1) {
      return cmdliner_info_bs.rev_arg_pos_cli_order(param[0], param$1[0]);
    };
    var add_pos = function (a, acc) {
      var match = cmdliner_info_bs.arg_is_opt(a);
      if (match) {
        return acc;
      } else {
        return /* :: */[
                /* tuple */[
                  a,
                  synopsis_pos_arg(a)
                ],
                acc
              ];
      }
    };
    var args = cmdliner_info_bs.term_args(cmdliner_info_bs.eval_term(ei));
    var pargs = curry._3(cmdliner_info_bs.Args.fold, add_pos, args, /* [] */0);
    var pargs$1 = list.sort(rev_cli_order, pargs);
    var pargs$2 = string.concat(" ", list.rev_map((function (prim) {
                return prim[1];
              }), pargs$1));
    return curry._2(printf_1.sprintf(/* Format */[
                    /* String_literal */block.__(11, [
                        "$(b,",
                        /* String */block.__(2, [
                            /* No_padding */0,
                            /* String_literal */block.__(11, [
                                ") [$(i,OPTION)]... ",
                                /* String */block.__(2, [
                                    /* No_padding */0,
                                    /* End_of_format */0
                                  ])
                              ])
                          ])
                      ]),
                    "$(b,%s) [$(i,OPTION)]... %s"
                  ]), cmdliner_manpage_bs.$$escape(invocation(undefined, ei)), pargs$2);
  } else {
    return curry._1(printf_1.sprintf(/* Format */[
                    /* String_literal */block.__(11, [
                        "$(b,",
                        /* String */block.__(2, [
                            /* No_padding */0,
                            /* String_literal */block.__(11, [
                                ") $(i,COMMAND) ...",
                                /* End_of_format */0
                              ])
                          ])
                      ]),
                    "$(b,%s) $(i,COMMAND) ..."
                  ]), cmdliner_manpage_bs.$$escape(invocation(undefined, ei)));
  }
}

function cmd_docs(ei) {
  var match = cmdliner_info_bs.eval_kind(ei);
  if (match !== -91404312) {
    return /* [] */0;
  } else {
    var add_cmd = function (acc, t) {
      var cmd = curry._1(printf_1.sprintf(/* Format */[
                /* String_literal */block.__(11, [
                    "$(b,",
                    /* String */block.__(2, [
                        /* No_padding */0,
                        /* Char_literal */block.__(12, [
                            /* ")" */41,
                            /* End_of_format */0
                          ])
                      ])
                  ]),
                "$(b,%s)"
              ]), cmdliner_manpage_bs.$$escape(cmdliner_info_bs.term_name(t)));
      return /* :: */[
              /* tuple */[
                cmdliner_info_bs.term_docs(t),
                /* `I */[
                  73,
                  /* tuple */[
                    cmd,
                    cmdliner_info_bs.term_doc(t)
                  ]
                ]
              ],
              acc
            ];
    };
    var by_sec_by_rev_name = function (param, param$1) {
      var c = caml_obj.caml_compare(param[0], param$1[0]);
      if (c !== 0) {
        return c;
      } else {
        return caml_obj.caml_compare(param$1[1][1][0], param[1][1][0]);
      }
    };
    var cmds = list.fold_left(add_cmd, /* [] */0, cmdliner_info_bs.eval_choices(ei));
    var cmds$1 = list.sort(by_sec_by_rev_name, cmds);
    return sorted_items_to_blocks(undefined, cmds$1);
  }
}

function arg_man_item_label(a) {
  if (cmdliner_info_bs.arg_is_pos(a)) {
    return curry._1(printf_1.sprintf(/* Format */[
                    /* String_literal */block.__(11, [
                        "$(i,",
                        /* String */block.__(2, [
                            /* No_padding */0,
                            /* Char_literal */block.__(12, [
                                /* ")" */41,
                                /* End_of_format */0
                              ])
                          ])
                      ]),
                    "$(i,%s)"
                  ]), cmdliner_manpage_bs.$$escape(cmdliner_info_bs.arg_docv(a)));
  } else {
    var fmt_name = function ($$var) {
      var match = cmdliner_info_bs.arg_opt_kind(a);
      if (typeof match === "number") {
        if (match !== 0) {
          return (function (n) {
              if (n.length > 2) {
                return curry._2(printf_1.sprintf(/* Format */[
                                /* String_literal */block.__(11, [
                                    "$(b,",
                                    /* String */block.__(2, [
                                        /* No_padding */0,
                                        /* String_literal */block.__(11, [
                                            ")=$(i,",
                                            /* String */block.__(2, [
                                                /* No_padding */0,
                                                /* Char_literal */block.__(12, [
                                                    /* ")" */41,
                                                    /* End_of_format */0
                                                  ])
                                              ])
                                          ])
                                      ])
                                  ]),
                                "$(b,%s)=$(i,%s)"
                              ]), cmdliner_manpage_bs.$$escape(n), cmdliner_manpage_bs.$$escape($$var));
              } else {
                return curry._2(printf_1.sprintf(/* Format */[
                                /* String_literal */block.__(11, [
                                    "$(b,",
                                    /* String */block.__(2, [
                                        /* No_padding */0,
                                        /* String_literal */block.__(11, [
                                            ") $(i,",
                                            /* String */block.__(2, [
                                                /* No_padding */0,
                                                /* Char_literal */block.__(12, [
                                                    /* ")" */41,
                                                    /* End_of_format */0
                                                  ])
                                              ])
                                          ])
                                      ])
                                  ]),
                                "$(b,%s) $(i,%s)"
                              ]), cmdliner_manpage_bs.$$escape(n), cmdliner_manpage_bs.$$escape($$var));
              }
            });
        } else {
          return (function (n) {
              return curry._1(printf_1.sprintf(/* Format */[
                              /* String_literal */block.__(11, [
                                  "$(b,",
                                  /* String */block.__(2, [
                                      /* No_padding */0,
                                      /* Char_literal */block.__(12, [
                                          /* ")" */41,
                                          /* End_of_format */0
                                        ])
                                    ])
                                ]),
                              "$(b,%s)"
                            ]), cmdliner_manpage_bs.$$escape(n));
            });
        }
      } else {
        return (function (n) {
            if (n.length > 2) {
              return curry._2(printf_1.sprintf(/* Format */[
                              /* String_literal */block.__(11, [
                                  "$(b,",
                                  /* String */block.__(2, [
                                      /* No_padding */0,
                                      /* String_literal */block.__(11, [
                                          ")[=$(i,",
                                          /* String */block.__(2, [
                                              /* No_padding */0,
                                              /* String_literal */block.__(11, [
                                                  ")]",
                                                  /* End_of_format */0
                                                ])
                                            ])
                                        ])
                                    ])
                                ]),
                              "$(b,%s)[=$(i,%s)]"
                            ]), cmdliner_manpage_bs.$$escape(n), cmdliner_manpage_bs.$$escape($$var));
            } else {
              return curry._2(printf_1.sprintf(/* Format */[
                              /* String_literal */block.__(11, [
                                  "$(b,",
                                  /* String */block.__(2, [
                                      /* No_padding */0,
                                      /* String_literal */block.__(11, [
                                          ") [$(i,",
                                          /* String */block.__(2, [
                                              /* No_padding */0,
                                              /* String_literal */block.__(11, [
                                                  ")]",
                                                  /* End_of_format */0
                                                ])
                                            ])
                                        ])
                                    ])
                                ]),
                              "$(b,%s) [$(i,%s)]"
                            ]), cmdliner_manpage_bs.$$escape(n), cmdliner_manpage_bs.$$escape($$var));
            }
          });
      }
    };
    var v = cmdliner_info_bs.arg_docv(a);
    var $$var = v === "" ? "VAL" : v;
    var names = list.sort(caml_primitive.caml_string_compare, cmdliner_info_bs.arg_opt_names(a));
    return string.concat(", ", list.rev_map(fmt_name($$var), names));
  }
}

function arg_docs$1(errs, subst, buf, ei) {
  var by_sec_by_arg = function (a0, a1) {
    var c = caml_primitive.caml_string_compare(cmdliner_info_bs.arg_docs(a0), cmdliner_info_bs.arg_docs(a1));
    if (c !== 0) {
      return c;
    } else {
      var match = cmdliner_info_bs.arg_is_opt(a0);
      var match$1 = cmdliner_info_bs.arg_is_opt(a1);
      if (match) {
        if (match$1) {
          var key = function (names) {
            var k = list.hd(list.sort(rev_compare, names));
            var k$1 = string.lowercase_ascii(k);
            if (caml_string.get(k$1, 1) === /* "-" */45) {
              return string.sub(k$1, 1, k$1.length - 1 | 0);
            } else {
              return k$1;
            }
          };
          return caml_primitive.caml_string_compare(key(cmdliner_info_bs.arg_opt_names(a0)), key(cmdliner_info_bs.arg_opt_names(a1)));
        } else {
          return -1;
        }
      } else if (match$1) {
        return 1;
      } else {
        return caml_primitive.caml_string_compare(string.lowercase_ascii(cmdliner_info_bs.arg_docv(a0)), string.lowercase_ascii(cmdliner_info_bs.arg_docv(a1)));
      }
    }
  };
  var keep_arg = function (a, acc) {
    if (cmdliner_info_bs.arg_is_pos(a) && (cmdliner_info_bs.arg_docv(a) === "" || cmdliner_info_bs.arg_doc(a) === "")) {
      return acc;
    } else {
      return /* :: */[
              a,
              acc
            ];
    }
  };
  var args = cmdliner_info_bs.term_args(cmdliner_info_bs.eval_term(ei));
  var args$1 = curry._3(cmdliner_info_bs.Args.fold, keep_arg, args, /* [] */0);
  var args$2 = list.sort(by_sec_by_arg, args$1);
  var args$3 = list.rev_map((function (param) {
          var errs$1 = errs;
          var subst$1 = subst;
          var buf$1 = buf;
          var a = param;
          var or_env = function (value, a) {
            var match = cmdliner_info_bs.arg_env(a);
            if (match !== undefined) {
              var value$1 = value ? " or" : "absent ";
              return curry._2(printf_1.sprintf(/* Format */[
                              /* String */block.__(2, [
                                  /* No_padding */0,
                                  /* String_literal */block.__(11, [
                                      " $(b,",
                                      /* String */block.__(2, [
                                          /* No_padding */0,
                                          /* String_literal */block.__(11, [
                                              ") env",
                                              /* End_of_format */0
                                            ])
                                        ])
                                    ])
                                ]),
                              "%s $(b,%s) env"
                            ]), value$1, cmdliner_manpage_bs.$$escape(cmdliner_info_bs.env_var(caml_option.valFromOption(match))));
            } else {
              return "";
            }
          };
          var match = cmdliner_info_bs.arg_absent(a);
          var absent;
          if (match) {
            var v = camlinternalLazy.force(match[0]);
            absent = v === "" ? curry._1(printf_1.sprintf(/* Format */[
                        /* String */block.__(2, [
                            /* No_padding */0,
                            /* End_of_format */0
                          ]),
                        "%s"
                      ]), or_env(false, a)) : curry._2(printf_1.sprintf(/* Format */[
                        /* String_literal */block.__(11, [
                            "absent=",
                            /* String */block.__(2, [
                                /* No_padding */0,
                                /* String */block.__(2, [
                                    /* No_padding */0,
                                    /* End_of_format */0
                                  ])
                              ])
                          ]),
                        "absent=%s%s"
                      ]), cmdliner_manpage_bs.$$escape(v), or_env(true, a));
          } else {
            absent = "required";
          }
          var match$1 = cmdliner_info_bs.arg_opt_kind(a);
          var optvopt = typeof match$1 === "number" ? "" : curry._1(printf_1.sprintf(/* Format */[
                      /* String_literal */block.__(11, [
                          "default=",
                          /* String */block.__(2, [
                              /* No_padding */0,
                              /* End_of_format */0
                            ])
                        ]),
                      "default=%s"
                    ]), match$1[0]);
          var argvdoc;
          var exit = 0;
          var s;
          var exit$1 = 0;
          if (optvopt === "" && absent === "") {
            argvdoc = "";
          } else {
            exit$1 = 2;
          }
          if (exit$1 === 2) {
            if (absent === "") {
              s = optvopt;
              exit = 1;
            } else if (optvopt === "") {
              s = absent;
              exit = 1;
            } else {
              argvdoc = curry._2(printf_1.sprintf(/* Format */[
                        /* String_literal */block.__(11, [
                            " (",
                            /* String */block.__(2, [
                                /* No_padding */0,
                                /* String_literal */block.__(11, [
                                    ") (",
                                    /* String */block.__(2, [
                                        /* No_padding */0,
                                        /* Char_literal */block.__(12, [
                                            /* ")" */41,
                                            /* End_of_format */0
                                          ])
                                      ])
                                  ])
                              ])
                          ]),
                        " (%s) (%s)"
                      ]), optvopt, absent);
            }
          }
          if (exit === 1) {
            argvdoc = curry._1(printf_1.sprintf(/* Format */[
                      /* String_literal */block.__(11, [
                          " (",
                          /* String */block.__(2, [
                              /* No_padding */0,
                              /* Char_literal */block.__(12, [
                                  /* ")" */41,
                                  /* End_of_format */0
                                ])
                            ])
                        ]),
                      " (%s)"
                    ]), s);
          }
          var subst$2 = function (param) {
            return arg_info_subst(subst$1, a, param);
          };
          var doc = cmdliner_info_bs.arg_doc(a);
          var doc$1 = cmdliner_manpage_bs.subst_vars(errs$1, subst$2, buf$1, doc);
          return /* tuple */[
                  cmdliner_info_bs.arg_docs(a),
                  /* `I */[
                    73,
                    /* tuple */[
                      arg_man_item_label(a) + argvdoc,
                      doc$1
                    ]
                  ]
                ];
        }), args$2);
  return sorted_items_to_blocks(undefined, args$3);
}

function exit_boilerplate(sec) {
  var match = sec === cmdliner_manpage_bs.s_exit_status;
  if (match) {
    return cmdliner_manpage_bs.s_exit_status_intro;
  }
  
}

function exit_docs$1(errs, subst, buf, has_sexit, ei) {
  var by_sec = function (param, param$1) {
    return caml_obj.caml_compare(param[0], param$1[0]);
  };
  var add_exit_item = function (acc, e) {
    var subst$1 = function (param) {
      var subst$2 = subst;
      var e$1 = e;
      var id = param;
      switch (id) {
        case "status" :
            return curry._1(printf_1.sprintf(/* Format */[
                            /* Int */block.__(4, [
                                /* Int_d */0,
                                /* No_padding */0,
                                /* No_precision */0,
                                /* End_of_format */0
                              ]),
                            "%d"
                          ]), cmdliner_info_bs.exit_statuses(e$1)[0]);
        case "status_max" :
            return curry._1(printf_1.sprintf(/* Format */[
                            /* Int */block.__(4, [
                                /* Int_d */0,
                                /* No_padding */0,
                                /* No_precision */0,
                                /* End_of_format */0
                              ]),
                            "%d"
                          ]), cmdliner_info_bs.exit_statuses(e$1)[1]);
        default:
          return curry._1(subst$2, id);
      }
    };
    var match = cmdliner_info_bs.exit_statuses(e);
    var max = match[1];
    var min = match[0];
    var doc = cmdliner_info_bs.exit_doc(e);
    var label = min === max ? curry._1(printf_1.sprintf(/* Format */[
                /* Int */block.__(4, [
                    /* Int_d */0,
                    /* No_padding */0,
                    /* No_precision */0,
                    /* End_of_format */0
                  ]),
                "%d"
              ]), min) : curry._2(printf_1.sprintf(/* Format */[
                /* Int */block.__(4, [
                    /* Int_d */0,
                    /* No_padding */0,
                    /* No_precision */0,
                    /* Char_literal */block.__(12, [
                        /* "-" */45,
                        /* Int */block.__(4, [
                            /* Int_d */0,
                            /* No_padding */0,
                            /* No_precision */0,
                            /* End_of_format */0
                          ])
                      ])
                  ]),
                "%d-%d"
              ]), min, max);
    var item_001 = /* tuple */[
      label,
      cmdliner_manpage_bs.subst_vars(errs, subst$1, buf, doc)
    ];
    var item = /* `I */[
      73,
      item_001
    ];
    return /* :: */[
            /* tuple */[
              cmdliner_info_bs.exit_docs(e),
              item
            ],
            acc
          ];
  };
  var exits = cmdliner_info_bs.term_exits(cmdliner_info_bs.eval_term(ei));
  var exits$1 = list.sort(cmdliner_info_bs.exit_order, exits);
  var exits$2 = list.fold_left(add_exit_item, /* [] */0, exits$1);
  var exits$3 = list.stable_sort(by_sec, exits$2);
  var boilerplate = has_sexit ? undefined : exit_boilerplate;
  return sorted_items_to_blocks(boilerplate, exits$3);
}

function env_boilerplate(sec) {
  var match = sec === cmdliner_manpage_bs.s_environment;
  if (match) {
    return cmdliner_manpage_bs.s_environment_intro;
  }
  
}

function env_docs$1(errs, subst, buf, has_senv, ei) {
  var add_env_item = function (subst, acc, e) {
    var seen = acc[0];
    if (curry._2(cmdliner_info_bs.Envs.mem, e, seen)) {
      return acc;
    } else {
      var seen$1 = curry._2(cmdliner_info_bs.Envs.add, e, seen);
      var $$var = curry._1(printf_1.sprintf(/* Format */[
                /* String_literal */block.__(11, [
                    "$(b,",
                    /* String */block.__(2, [
                        /* No_padding */0,
                        /* Char_literal */block.__(12, [
                            /* ")" */41,
                            /* End_of_format */0
                          ])
                      ])
                  ]),
                "$(b,%s)"
              ]), cmdliner_manpage_bs.$$escape(cmdliner_info_bs.env_var(e)));
      var doc = cmdliner_info_bs.env_doc(e);
      var doc$1 = cmdliner_manpage_bs.subst_vars(errs, subst, buf, doc);
      var envs_000 = /* tuple */[
        cmdliner_info_bs.env_docs(e),
        /* `I */[
          73,
          /* tuple */[
            $$var,
            doc$1
          ]
        ]
      ];
      var envs_001 = acc[1];
      var envs = /* :: */[
        envs_000,
        envs_001
      ];
      return /* tuple */[
              seen$1,
              envs
            ];
    }
  };
  var add_arg_env = function (a, acc) {
    var match = cmdliner_info_bs.arg_env(a);
    if (match !== undefined) {
      return add_env_item((function (param) {
                    return arg_info_subst(subst, a, param);
                  }), acc, caml_option.valFromOption(match));
    } else {
      return acc;
    }
  };
  var add_env = function (acc, e) {
    return add_env_item((function (param) {
                  return env_info_subst(subst, e, param);
                }), acc, e);
  };
  var by_sec_by_rev_name = function (param, param$1) {
    var c = caml_obj.caml_compare(param[0], param$1[0]);
    if (c !== 0) {
      return c;
    } else {
      return caml_obj.caml_compare(param$1[1][1][0], param[1][1][0]);
    }
  };
  var args = cmdliner_info_bs.term_args(cmdliner_info_bs.eval_term(ei));
  var tenvs = cmdliner_info_bs.term_envs(cmdliner_info_bs.eval_term(ei));
  var init_000 = cmdliner_info_bs.Envs.empty;
  var init = /* tuple */[
    init_000,
    /* [] */0
  ];
  var acc = curry._3(cmdliner_info_bs.Args.fold, add_arg_env, args, init);
  var match = list.fold_left(add_env, acc, tenvs);
  var envs = list.sort(by_sec_by_rev_name, match[1]);
  var boilerplate = has_senv ? undefined : env_boilerplate;
  return sorted_items_to_blocks(boilerplate, envs);
}

function xref_docs(errs, ei) {
  var main = cmdliner_info_bs.term_name(cmdliner_info_bs.eval_main(ei));
  var to_xref = function (param) {
    if (typeof param === "number") {
      return /* tuple */[
              main,
              1
            ];
    } else {
      var variant = param[0];
      if (variant !== 892012143) {
        if (variant >= 937068408) {
          return /* tuple */[
                  param[1],
                  1
                ];
        } else {
          var c = param[1];
          if (cmdliner_info_bs.eval_has_choice(ei, c)) {
            return /* tuple */[
                    curry._2(printf_1.sprintf(/* Format */[
                              /* String */block.__(2, [
                                  /* No_padding */0,
                                  /* Char_literal */block.__(12, [
                                      /* "-" */45,
                                      /* String */block.__(2, [
                                          /* No_padding */0,
                                          /* End_of_format */0
                                        ])
                                    ])
                                ]),
                              "%s-%s"
                            ]), main, c),
                    1
                  ];
          } else {
            curry._1(format.fprintf(errs, /* Format */[
                      /* String_literal */block.__(11, [
                          "xref ",
                          /* String */block.__(2, [
                              /* No_padding */0,
                              /* String_literal */block.__(11, [
                                  ": no such term name",
                                  /* Formatting_lit */block.__(17, [
                                      /* Flush_newline */4,
                                      /* End_of_format */0
                                    ])
                                ])
                            ])
                        ]),
                      "xref %s: no such term name@."
                    ]), c);
            return /* tuple */[
                    "doc-err",
                    0
                  ];
          }
        }
      } else {
        var match = param[1];
        return /* tuple */[
                match[0],
                match[1]
              ];
      }
    }
  };
  var xref_str = function (param) {
    return curry._2(printf_1.sprintf(/* Format */[
                    /* String */block.__(2, [
                        /* No_padding */0,
                        /* Char_literal */block.__(12, [
                            /* "(" */40,
                            /* Int */block.__(4, [
                                /* Int_d */0,
                                /* No_padding */0,
                                /* No_precision */0,
                                /* Char_literal */block.__(12, [
                                    /* ")" */41,
                                    /* End_of_format */0
                                  ])
                              ])
                          ])
                      ]),
                    "%s(%d)"
                  ]), cmdliner_manpage_bs.$$escape(param[0]), param[1]);
  };
  var xrefs = cmdliner_info_bs.term_man_xrefs(cmdliner_info_bs.eval_term(ei));
  var xrefs$1 = list.fold_left((function (acc, x) {
          return /* :: */[
                  to_xref(x),
                  acc
                ];
        }), /* [] */0, xrefs);
  var xrefs$2 = list.rev_map(xref_str, list.sort(rev_compare, xrefs$1));
  if (xrefs$2 === /* [] */0) {
    return /* [] */0;
  } else {
    return /* :: */[
            /* tuple */[
              cmdliner_manpage_bs.s_see_also,
              /* `P */[
                80,
                string.concat(", ", xrefs$2)
              ]
            ],
            /* [] */0
          ];
  }
}

function ensure_s_name(ei, sm) {
  if (cmdliner_manpage_bs.smap_has_section(sm, cmdliner_manpage_bs.s_name)) {
    return sm;
  } else {
    var tname = cmdliner_manpage_bs.$$escape(invocation(/* "-" */45, ei));
    var tdoc = cmdliner_info_bs.term_doc(cmdliner_info_bs.eval_term(ei));
    var tagline = tdoc === "" ? "" : curry._1(printf_1.sprintf(/* Format */[
                /* String_literal */block.__(11, [
                    " - ",
                    /* String */block.__(2, [
                        /* No_padding */0,
                        /* End_of_format */0
                      ])
                  ]),
                " - %s"
              ]), tdoc);
    var tagline_001 = curry._2(printf_1.sprintf(/* Format */[
              /* String */block.__(2, [
                  /* No_padding */0,
                  /* String */block.__(2, [
                      /* No_padding */0,
                      /* End_of_format */0
                    ])
                ]),
              "%s%s"
            ]), tname, tagline);
    var tagline$1 = /* `P */[
      80,
      tagline_001
    ];
    return cmdliner_manpage_bs.smap_append_block(sm, cmdliner_manpage_bs.s_name, tagline$1);
  }
}

function ensure_s_synopsis(ei, sm) {
  if (cmdliner_manpage_bs.smap_has_section(sm, cmdliner_manpage_bs.s_synopsis)) {
    return sm;
  } else {
    var synopsis_001 = synopsis(ei);
    var synopsis$1 = /* `P */[
      80,
      synopsis_001
    ];
    return cmdliner_manpage_bs.smap_append_block(sm, cmdliner_manpage_bs.s_synopsis, synopsis$1);
  }
}

function insert_term_man_docs(errs, ei, sm) {
  var buf = buffer.create(200);
  var subst = function (param) {
    return term_info_subst(ei, param);
  };
  var ins = function (sm, param) {
    return cmdliner_manpage_bs.smap_append_block(sm, param[0], param[1]);
  };
  var has_senv = cmdliner_manpage_bs.smap_has_section(sm, cmdliner_manpage_bs.s_environment);
  var has_sexit = cmdliner_manpage_bs.smap_has_section(sm, cmdliner_manpage_bs.s_exit_status);
  var sm$1 = list.fold_left(ins, sm, cmd_docs(ei));
  var sm$2 = list.fold_left(ins, sm$1, arg_docs$1(errs, subst, buf, ei));
  var sm$3 = list.fold_left(ins, sm$2, exit_docs$1(errs, subst, buf, has_sexit, ei));
  var sm$4 = list.fold_left(ins, sm$3, env_docs$1(errs, subst, buf, has_senv, ei));
  return list.fold_left(ins, sm$4, xref_docs(errs, ei));
}

function text(errs, ei) {
  var man = cmdliner_info_bs.term_man(cmdliner_info_bs.eval_term(ei));
  var sm = cmdliner_manpage_bs.smap_of_blocks(man);
  var sm$1 = ensure_s_name(ei, sm);
  var sm$2 = ensure_s_synopsis(ei, sm$1);
  return cmdliner_manpage_bs.smap_to_blocks(insert_term_man_docs(errs, ei, sm$2));
}

function title(ei) {
  var main = cmdliner_info_bs.eval_main(ei);
  var exec = string.capitalize_ascii(cmdliner_info_bs.term_name(main));
  var name = string.uppercase_ascii(cmdliner_manpage_bs.$$escape(invocation(/* "-" */45, ei)));
  var center_header = cmdliner_manpage_bs.$$escape(curry._1(printf_1.sprintf(/* Format */[
                /* String */block.__(2, [
                    /* No_padding */0,
                    /* String_literal */block.__(11, [
                        " Manual",
                        /* End_of_format */0
                      ])
                  ]),
                "%s Manual"
              ]), exec));
  var match = cmdliner_info_bs.term_version(main);
  var version = match !== undefined ? " " + match : "";
  var left_footer = cmdliner_manpage_bs.$$escape(curry._2(printf_1.sprintf(/* Format */[
                /* String */block.__(2, [
                    /* No_padding */0,
                    /* String */block.__(2, [
                        /* No_padding */0,
                        /* End_of_format */0
                      ])
                  ]),
                "%s%s"
              ]), exec, version));
  return /* tuple */[
          name,
          1,
          "",
          left_footer,
          center_header
        ];
}

function man(errs, ei) {
  return /* tuple */[
          title(ei),
          text(errs, ei)
        ];
}

function pp_man(errs, fmt, ppf, ei) {
  return cmdliner_manpage_bs.print(caml_option.some(errs), (function (param) {
                return term_info_subst(ei, param);
              }), fmt, ppf, man(errs, ei));
}

function pp_plain_synopsis(errs, ppf, ei) {
  var buf = buffer.create(100);
  var subst = function (param) {
    return term_info_subst(ei, param);
  };
  return curry._1(format.fprintf(ppf, /* Format */[
                  /* Formatting_gen */block.__(18, [
                      /* Open_box */block.__(1, [/* Format */[
                            /* End_of_format */0,
                            ""
                          ]]),
                      /* String */block.__(2, [
                          /* No_padding */0,
                          /* Formatting_lit */block.__(17, [
                              /* Close_box */0,
                              /* End_of_format */0
                            ])
                        ])
                    ]),
                  "@[%s@]"
                ]), cmdliner_manpage_bs.doc_to_plain(errs, subst, buf, synopsis(ei)));
}

var plain_invocation_1 = plain_invocation;
var pp_man_1 = pp_man;
var pp_plain_synopsis_1 = pp_plain_synopsis;
/* Format Not a pure module */

var cmdliner_docgen_bs = {
	plain_invocation: plain_invocation_1,
	pp_man: pp_man_1,
	pp_plain_synopsis: pp_plain_synopsis_1
};

function err_env_parse(env, err) {
  var $$var = cmdliner_info_bs.env_var(env);
  return curry._2(printf_1.sprintf(/* Format */[
                  /* String_literal */block.__(11, [
                      "environment variable ",
                      /* String */block.__(2, [
                          /* No_padding */0,
                          /* String_literal */block.__(11, [
                              ": ",
                              /* String */block.__(2, [
                                  /* No_padding */0,
                                  /* End_of_format */0
                                ])
                            ])
                        ])
                    ]),
                  "environment variable %s: %s"
                ]), cmdliner_base_bs.quote($$var), err);
}

function err_pos_excess(excess) {
  return curry._1(printf_1.sprintf(/* Format */[
                  /* String_literal */block.__(11, [
                      "too many arguments, don't know what to do with ",
                      /* String */block.__(2, [
                          /* No_padding */0,
                          /* End_of_format */0
                        ])
                    ]),
                  "too many arguments, don't know what to do with %s"
                ]), string.concat(", ", list.map(cmdliner_base_bs.quote, excess)));
}

function err_pos_miss(a) {
  var v = cmdliner_info_bs.arg_docv(a);
  if (v === "") {
    return "a required argument is missing";
  } else {
    return curry._1(printf_1.sprintf(/* Format */[
                    /* String_literal */block.__(11, [
                        "required argument ",
                        /* String */block.__(2, [
                            /* No_padding */0,
                            /* String_literal */block.__(11, [
                                " is missing",
                                /* End_of_format */0
                              ])
                          ])
                      ]),
                    "required argument %s is missing"
                  ]), v);
  }
}

function err_pos_misses(args) {
  if (args) {
    if (args[1]) {
      var add_arg = function (acc, a) {
        var argv = cmdliner_info_bs.arg_docv(a);
        if (argv === "") {
          return /* :: */[
                  "ARG",
                  acc
                ];
        } else {
          return /* :: */[
                  argv,
                  acc
                ];
        }
      };
      var rev_args = list.sort(cmdliner_info_bs.rev_arg_pos_cli_order, args);
      var args$1 = list.fold_left(add_arg, /* [] */0, rev_args);
      var args$2 = string.concat(", ", args$1);
      return curry._1(printf_1.sprintf(/* Format */[
                      /* String_literal */block.__(11, [
                          "required arguments ",
                          /* String */block.__(2, [
                              /* No_padding */0,
                              /* String_literal */block.__(11, [
                                  " are missing",
                                  /* End_of_format */0
                                ])
                            ])
                        ]),
                      "required arguments %s are missing"
                    ]), args$2);
    } else {
      return err_pos_miss(args[0]);
    }
  } else {
    throw [
          caml_builtin_exceptions.assert_failure,
          /* tuple */[
            "cmdliner_msg.ml",
            31,
            8
          ]
        ];
  }
}

function err_pos_parse(a, err) {
  var argv = cmdliner_info_bs.arg_docv(a);
  if (argv === "") {
    return err;
  } else {
    var match = cmdliner_info_bs.pos_len(cmdliner_info_bs.arg_pos(a));
    if (match === 1) {
      return curry._2(printf_1.sprintf(/* Format */[
                      /* String */block.__(2, [
                          /* No_padding */0,
                          /* String_literal */block.__(11, [
                              " argument: ",
                              /* String */block.__(2, [
                                  /* No_padding */0,
                                  /* End_of_format */0
                                ])
                            ])
                        ]),
                      "%s argument: %s"
                    ]), argv, err);
    }
    return curry._2(printf_1.sprintf(/* Format */[
                    /* String */block.__(2, [
                        /* No_padding */0,
                        /* String_literal */block.__(11, [
                            "... arguments: ",
                            /* String */block.__(2, [
                                /* No_padding */0,
                                /* End_of_format */0
                              ])
                          ])
                      ]),
                    "%s... arguments: %s"
                  ]), argv, err);
  }
}

function err_flag_value(flag, v) {
  return curry._2(printf_1.sprintf(/* Format */[
                  /* String_literal */block.__(11, [
                      "option ",
                      /* String */block.__(2, [
                          /* No_padding */0,
                          /* String_literal */block.__(11, [
                              " is a flag, it cannot take the argument ",
                              /* String */block.__(2, [
                                  /* No_padding */0,
                                  /* End_of_format */0
                                ])
                            ])
                        ])
                    ]),
                  "option %s is a flag, it cannot take the argument %s"
                ]), cmdliner_base_bs.quote(flag), cmdliner_base_bs.quote(v));
}

function err_opt_value_missing(f) {
  return curry._1(printf_1.sprintf(/* Format */[
                  /* String_literal */block.__(11, [
                      "option ",
                      /* String */block.__(2, [
                          /* No_padding */0,
                          /* String_literal */block.__(11, [
                              " needs an argument",
                              /* End_of_format */0
                            ])
                        ])
                    ]),
                  "option %s needs an argument"
                ]), cmdliner_base_bs.quote(f));
}

function err_opt_parse(f, err) {
  return curry._2(printf_1.sprintf(/* Format */[
                  /* String_literal */block.__(11, [
                      "option ",
                      /* String */block.__(2, [
                          /* No_padding */0,
                          /* String_literal */block.__(11, [
                              ": ",
                              /* String */block.__(2, [
                                  /* No_padding */0,
                                  /* End_of_format */0
                                ])
                            ])
                        ])
                    ]),
                  "option %s: %s"
                ]), cmdliner_base_bs.quote(f), err);
}

function err_opt_repeated(f, f$prime) {
  if (f === f$prime) {
    return curry._1(printf_1.sprintf(/* Format */[
                    /* String_literal */block.__(11, [
                        "option ",
                        /* String */block.__(2, [
                            /* No_padding */0,
                            /* String_literal */block.__(11, [
                                " cannot be repeated",
                                /* End_of_format */0
                              ])
                          ])
                      ]),
                    "option %s cannot be repeated"
                  ]), cmdliner_base_bs.quote(f));
  } else {
    return curry._2(printf_1.sprintf(/* Format */[
                    /* String_literal */block.__(11, [
                        "options ",
                        /* String */block.__(2, [
                            /* No_padding */0,
                            /* String_literal */block.__(11, [
                                " and ",
                                /* String */block.__(2, [
                                    /* No_padding */0,
                                    /* String_literal */block.__(11, [
                                        " cannot be present at the same time",
                                        /* End_of_format */0
                                      ])
                                  ])
                              ])
                          ])
                      ]),
                    "options %s and %s cannot be present at the same time"
                  ]), cmdliner_base_bs.quote(f), cmdliner_base_bs.quote(f$prime));
  }
}

function err_arg_missing(a) {
  if (cmdliner_info_bs.arg_is_pos(a)) {
    return err_pos_miss(a);
  } else {
    return curry._1(printf_1.sprintf(/* Format */[
                    /* String_literal */block.__(11, [
                        "required option ",
                        /* String */block.__(2, [
                            /* No_padding */0,
                            /* String_literal */block.__(11, [
                                " is missing",
                                /* End_of_format */0
                              ])
                          ])
                      ]),
                    "required option %s is missing"
                  ]), cmdliner_info_bs.arg_opt_name_sample(a));
  }
}

function pp_version(ppf, ei) {
  var match = cmdliner_info_bs.term_version(cmdliner_info_bs.eval_main(ei));
  if (match !== undefined) {
    return curry._2(format.fprintf(ppf, /* Format */[
                    /* Formatting_gen */block.__(18, [
                        /* Open_box */block.__(1, [/* Format */[
                              /* End_of_format */0,
                              ""
                            ]]),
                        /* Alpha */block.__(15, [/* Formatting_lit */block.__(17, [
                                /* Close_box */0,
                                /* Formatting_lit */block.__(17, [
                                    /* Flush_newline */4,
                                    /* End_of_format */0
                                  ])
                              ])])
                      ]),
                    "@[%a@]@."
                  ]), cmdliner_base_bs.pp_text, match);
  } else {
    throw [
          caml_builtin_exceptions.assert_failure,
          /* tuple */[
            "cmdliner_msg.ml",
            74,
            10
          ]
        ];
  }
}

function pp_try_help(ppf, ei) {
  var match = cmdliner_info_bs.eval_kind(ei);
  if (match >= 491021489) {
    var exec_cmd = cmdliner_docgen_bs.plain_invocation(ei);
    return curry._2(format.fprintf(ppf, /* Format */[
                    /* Formatting_gen */block.__(18, [
                        /* Open_box */block.__(1, [/* Format */[
                              /* String_literal */block.__(11, [
                                  "<2>",
                                  /* End_of_format */0
                                ]),
                              "<2>"
                            ]]),
                        /* String_literal */block.__(11, [
                            "Try `",
                            /* String */block.__(2, [
                                /* No_padding */0,
                                /* String_literal */block.__(11, [
                                    " --help' or `",
                                    /* String */block.__(2, [
                                        /* No_padding */0,
                                        /* String_literal */block.__(11, [
                                            " --help' for more information.",
                                            /* Formatting_lit */block.__(17, [
                                                /* Close_box */0,
                                                /* End_of_format */0
                                              ])
                                          ])
                                      ])
                                  ])
                              ])
                          ])
                      ]),
                    "@[<2>Try `%s --help' or `%s --help' for more information.@]"
                  ]), exec_cmd, cmdliner_info_bs.term_name(cmdliner_info_bs.eval_main(ei)));
  } else {
    return curry._1(format.fprintf(ppf, /* Format */[
                    /* Formatting_gen */block.__(18, [
                        /* Open_box */block.__(1, [/* Format */[
                              /* String_literal */block.__(11, [
                                  "<2>",
                                  /* End_of_format */0
                                ]),
                              "<2>"
                            ]]),
                        /* String_literal */block.__(11, [
                            "Try `",
                            /* String */block.__(2, [
                                /* No_padding */0,
                                /* String_literal */block.__(11, [
                                    " --help' for more information.",
                                    /* Formatting_lit */block.__(17, [
                                        /* Close_box */0,
                                        /* End_of_format */0
                                      ])
                                  ])
                              ])
                          ])
                      ]),
                    "@[<2>Try `%s --help' for more information.@]"
                  ]), cmdliner_info_bs.term_name(cmdliner_info_bs.eval_main(ei)));
  }
}

function pp_err(ppf, ei, err) {
  return curry._3(format.fprintf(ppf, /* Format */[
                  /* String */block.__(2, [
                      /* No_padding */0,
                      /* String_literal */block.__(11, [
                          ": ",
                          /* Formatting_gen */block.__(18, [
                              /* Open_box */block.__(1, [/* Format */[
                                    /* End_of_format */0,
                                    ""
                                  ]]),
                              /* Alpha */block.__(15, [/* Formatting_lit */block.__(17, [
                                      /* Close_box */0,
                                      /* Formatting_lit */block.__(17, [
                                          /* Flush_newline */4,
                                          /* End_of_format */0
                                        ])
                                    ])])
                            ])
                        ])
                    ]),
                  "%s: @[%a@]@."
                ]), cmdliner_info_bs.term_name(cmdliner_info_bs.eval_main(ei)), cmdliner_base_bs.pp_lines, err);
}

function pp_err_usage(ppf, ei, err_lines, err) {
  var pp_err = err_lines ? cmdliner_base_bs.pp_lines : cmdliner_base_bs.pp_text;
  return curry._7(format.fprintf(ppf, /* Format */[
                  /* Formatting_gen */block.__(18, [
                      /* Open_box */block.__(1, [/* Format */[
                            /* String_literal */block.__(11, [
                                "<v>",
                                /* End_of_format */0
                              ]),
                            "<v>"
                          ]]),
                      /* String */block.__(2, [
                          /* No_padding */0,
                          /* String_literal */block.__(11, [
                              ": ",
                              /* Formatting_gen */block.__(18, [
                                  /* Open_box */block.__(1, [/* Format */[
                                        /* End_of_format */0,
                                        ""
                                      ]]),
                                  /* Alpha */block.__(15, [/* Formatting_lit */block.__(17, [
                                          /* Close_box */0,
                                          /* Formatting_lit */block.__(17, [
                                              /* Break */block.__(0, [
                                                  "@,",
                                                  0,
                                                  0
                                                ]),
                                              /* Formatting_gen */block.__(18, [
                                                  /* Open_box */block.__(1, [/* Format */[
                                                        /* End_of_format */0,
                                                        ""
                                                      ]]),
                                                  /* String_literal */block.__(11, [
                                                      "Usage: ",
                                                      /* Formatting_gen */block.__(18, [
                                                          /* Open_box */block.__(1, [/* Format */[
                                                                /* End_of_format */0,
                                                                ""
                                                              ]]),
                                                          /* Alpha */block.__(15, [/* Formatting_lit */block.__(17, [
                                                                  /* Close_box */0,
                                                                  /* Formatting_lit */block.__(17, [
                                                                      /* Close_box */0,
                                                                      /* Formatting_lit */block.__(17, [
                                                                          /* Break */block.__(0, [
                                                                              "@,",
                                                                              0,
                                                                              0
                                                                            ]),
                                                                          /* Alpha */block.__(15, [/* Formatting_lit */block.__(17, [
                                                                                  /* Close_box */0,
                                                                                  /* Formatting_lit */block.__(17, [
                                                                                      /* Flush_newline */4,
                                                                                      /* End_of_format */0
                                                                                    ])
                                                                                ])])
                                                                        ])
                                                                    ])
                                                                ])])
                                                        ])
                                                    ])
                                                ])
                                            ])
                                        ])])
                                ])
                            ])
                        ])
                    ]),
                  "@[<v>%s: @[%a@]@,@[Usage: @[%a@]@]@,%a@]@."
                ]), cmdliner_info_bs.term_name(cmdliner_info_bs.eval_main(ei)), pp_err, err, (function (param, param$1) {
                return cmdliner_docgen_bs.pp_plain_synopsis(ppf, param, param$1);
              }), ei, pp_try_help, ei);
}

function pp_backtrace(ppf, ei, e, bt) {
  var bt$1 = printexc.raw_backtrace_to_string(bt);
  var len = bt$1.length;
  var bt$2 = len > 0 ? string.sub(bt$1, 0, len - 1 | 0) : bt$1;
  return curry._3(format.fprintf(ppf, /* Format */[
                  /* String */block.__(2, [
                      /* No_padding */0,
                      /* String_literal */block.__(11, [
                          ": ",
                          /* Formatting_gen */block.__(18, [
                              /* Open_box */block.__(1, [/* Format */[
                                    /* End_of_format */0,
                                    ""
                                  ]]),
                              /* String_literal */block.__(11, [
                                  "internal error, uncaught exception:",
                                  /* Formatting_lit */block.__(17, [
                                      /* Force_newline */3,
                                      /* Alpha */block.__(15, [/* Formatting_lit */block.__(17, [
                                              /* Close_box */0,
                                              /* Formatting_lit */block.__(17, [
                                                  /* Flush_newline */4,
                                                  /* End_of_format */0
                                                ])
                                            ])])
                                    ])
                                ])
                            ])
                        ])
                    ]),
                  "%s: @[internal error, uncaught exception:@\n%a@]@."
                ]), cmdliner_info_bs.term_name(cmdliner_info_bs.eval_main(ei)), cmdliner_base_bs.pp_lines, curry._2(printf_1.sprintf(/* Format */[
                      /* String */block.__(2, [
                          /* No_padding */0,
                          /* Char_literal */block.__(12, [
                              /* "\n" */10,
                              /* String */block.__(2, [
                                  /* No_padding */0,
                                  /* End_of_format */0
                                ])
                            ])
                        ]),
                      "%s\n%s"
                    ]), printexc.to_string(e), bt$2));
}

var err_env_parse_1 = err_env_parse;
var err_pos_excess_1 = err_pos_excess;
var err_pos_misses_1 = err_pos_misses;
var err_pos_parse_1 = err_pos_parse;
var err_flag_value_1 = err_flag_value;
var err_opt_value_missing_1 = err_opt_value_missing;
var err_opt_parse_1 = err_opt_parse;
var err_opt_repeated_1 = err_opt_repeated;
var err_arg_missing_1 = err_arg_missing;
var pp_version_1 = pp_version;
var pp_try_help_1 = pp_try_help;
var pp_err_1 = pp_err;
var pp_err_usage_1 = pp_err_usage;
var pp_backtrace_1 = pp_backtrace;
/* Format Not a pure module */

var cmdliner_msg_bs = {
	err_env_parse: err_env_parse_1,
	err_pos_excess: err_pos_excess_1,
	err_pos_misses: err_pos_misses_1,
	err_pos_parse: err_pos_parse_1,
	err_flag_value: err_flag_value_1,
	err_opt_value_missing: err_opt_value_missing_1,
	err_opt_parse: err_opt_parse_1,
	err_opt_repeated: err_opt_repeated_1,
	err_arg_missing: err_arg_missing_1,
	pp_version: pp_version_1,
	pp_try_help: pp_try_help_1,
	pp_err: pp_err_1,
	pp_err_usage: pp_err_usage_1,
	pp_backtrace: pp_backtrace_1
};

function levenshtein_distance(s, t) {
  var minimum = function (a, b, c) {
    return caml_obj.caml_min(a, caml_obj.caml_min(b, c));
  };
  var m = s.length;
  var n = t.length;
  var d = array.make_matrix(m + 1 | 0, n + 1 | 0, 0);
  for(var i = 0; i <= m; ++i){
    caml_array.caml_array_set(caml_array.caml_array_get(d, i), 0, i);
  }
  for(var j = 0; j <= n; ++j){
    caml_array.caml_array_set(caml_array.caml_array_get(d, 0), j, j);
  }
  for(var j$1 = 1; j$1 <= n; ++j$1){
    for(var i$1 = 1; i$1 <= m; ++i$1){
      if (caml_string.get(s, i$1 - 1 | 0) === caml_string.get(t, j$1 - 1 | 0)) {
        caml_array.caml_array_set(caml_array.caml_array_get(d, i$1), j$1, caml_array.caml_array_get(caml_array.caml_array_get(d, i$1 - 1 | 0), j$1 - 1 | 0));
      } else {
        caml_array.caml_array_set(caml_array.caml_array_get(d, i$1), j$1, minimum(caml_array.caml_array_get(caml_array.caml_array_get(d, i$1 - 1 | 0), j$1) + 1 | 0, caml_array.caml_array_get(caml_array.caml_array_get(d, i$1), j$1 - 1 | 0) + 1 | 0, caml_array.caml_array_get(caml_array.caml_array_get(d, i$1 - 1 | 0), j$1 - 1 | 0) + 1 | 0));
      }
    }
  }
  return caml_array.caml_array_get(caml_array.caml_array_get(d, m), n);
}

function value(s, candidates) {
  var add = function (param, name) {
    var acc = param[1];
    var min = param[0];
    var d = levenshtein_distance(s, name);
    if (d === min) {
      return /* tuple */[
              min,
              /* :: */[
                name,
                acc
              ]
            ];
    } else if (d < min) {
      return /* tuple */[
              d,
              /* :: */[
                name,
                /* [] */0
              ]
            ];
    } else {
      return /* tuple */[
              min,
              acc
            ];
    }
  };
  var match = list.fold_left(add, /* tuple */[
        pervasives.max_int,
        /* [] */0
      ], candidates);
  if (match[0] < 3) {
    return match[1];
  } else {
    return /* [] */0;
  }
}

var value_1 = value;
/* No side effect */

var cmdliner_suggest_bs = {
	value: value_1
};

function err_multi_opt_name_def(name, a, a$prime) {
  return cmdliner_base_bs.err_multi_def("option name", name, cmdliner_info_bs.arg_doc, a, a$prime);
}

var Amap = map$8.Make(cmdliner_info_bs.Arg);

function get_arg(cl, a) {
  try {
    return curry._2(Amap.find, a, cl);
  }
  catch (exn){
    if (exn === caml_builtin_exceptions.not_found) {
      throw [
            caml_builtin_exceptions.assert_failure,
            /* tuple */[
              "cmdliner_cline.ml",
              27,
              56
            ]
          ];
    }
    throw exn;
  }
}

function opt_arg(cl, a) {
  var match = get_arg(cl, a);
  if (match.tag) {
    throw [
          caml_builtin_exceptions.assert_failure,
          /* tuple */[
            "cmdliner_cline.ml",
            28,
            59
          ]
        ];
  } else {
    return match[0];
  }
}

function pos_arg(cl, a) {
  var match = get_arg(cl, a);
  if (match.tag) {
    return match[0];
  } else {
    throw [
          caml_builtin_exceptions.assert_failure,
          /* tuple */[
            "cmdliner_cline.ml",
            29,
            59
          ]
        ];
  }
}

function actual_args(cl, a) {
  var match = get_arg(cl, a);
  if (match.tag) {
    return match[0];
  } else {
    var extract_args = function (param) {
      var value = param[2];
      return /* :: */[
              param[1],
              value !== undefined ? /* :: */[
                  caml_option.valFromOption(value),
                  /* [] */0
                ] : /* [] */0
            ];
    };
    return list.concat(list.map(extract_args, match[0]));
  }
}

function arg_info_indexes(args) {
  var _optidx = cmdliner_trie_bs.empty;
  var _posidx = /* [] */0;
  var _cl = Amap.empty;
  var _param = curry._1(cmdliner_info_bs.Args.elements, args);
  while(true) {
    var param = _param;
    var cl = _cl;
    var posidx = _posidx;
    var optidx = _optidx;
    if (param) {
      var l = param[1];
      var a = param[0];
      var match = cmdliner_info_bs.arg_is_pos(a);
      if (match) {
        _param = l;
        _cl = curry._3(Amap.add, a, /* P */block.__(1, [/* [] */0]), cl);
        _posidx = /* :: */[
          a,
          posidx
        ];
        continue ;
      } else {
        var add = (function(a){
        return function add(t, name) {
          var match = cmdliner_trie_bs.add(t, name, a);
          if (match[0] >= 3901504) {
            return match[1];
          } else {
            return pervasives.invalid_arg(err_multi_opt_name_def(name, a, match[1][0]));
          }
        }
        }(a));
        var names = cmdliner_info_bs.arg_opt_names(a);
        var optidx$1 = list.fold_left(add, optidx, names);
        _param = l;
        _cl = curry._3(Amap.add, a, /* O */block.__(0, [/* [] */0]), cl);
        _optidx = optidx$1;
        continue ;
      }
    } else {
      return /* tuple */[
              optidx,
              posidx,
              cl
            ];
    }
  }}

function is_opt(s) {
  if (s.length > 1) {
    return caml_string.get(s, 0) === /* "-" */45;
  } else {
    return false;
  }
}

function is_short_opt(s) {
  if (s.length === 2) {
    return caml_string.get(s, 0) === /* "-" */45;
  } else {
    return false;
  }
}

function parse_opt_arg(s) {
  var l = s.length;
  if (caml_string.get(s, 1) !== /* "-" */45) {
    if (l === 2) {
      return /* tuple */[
              s,
              undefined
            ];
    } else {
      return /* tuple */[
              string.sub(s, 0, 2),
              string.sub(s, 2, l - 2 | 0)
            ];
    }
  } else {
    try {
      var i = string.index(s, /* "=" */61);
      return /* tuple */[
              string.sub(s, 0, i),
              string.sub(s, i + 1 | 0, (l - i | 0) - 1 | 0)
            ];
    }
    catch (exn){
      if (exn === caml_builtin_exceptions.not_found) {
        return /* tuple */[
                s,
                undefined
              ];
      } else {
        throw exn;
      }
    }
  }
}

function hint_matching_opt(optidx, s) {
  if (s.length <= 2) {
    return /* [] */0;
  } else {
    var match = caml_string.get(s, 1) !== /* "-" */45 ? /* tuple */[
        s,
        curry._1(printf_1.sprintf(/* Format */[
                  /* Char_literal */block.__(12, [
                      /* "-" */45,
                      /* String */block.__(2, [
                          /* No_padding */0,
                          /* End_of_format */0
                        ])
                    ]),
                  "-%s"
                ]), s)
      ] : /* tuple */[
        string.sub(s, 1, s.length - 1 | 0),
        s
      ];
    var match$1 = parse_opt_arg(match[0]);
    var short_opt = match$1[0];
    var match$2 = parse_opt_arg(match[1]);
    var all = cmdliner_trie_bs.ambiguities(optidx, "-");
    var match$3 = list.mem(short_opt, all);
    var match$4 = cmdliner_suggest_bs.value(match$2[0], all);
    if (match$3) {
      if (match$4) {
        if (list.mem(short_opt, match$4)) {
          return match$4;
        } else {
          return /* :: */[
                  short_opt,
                  match$4
                ];
        }
      } else {
        return /* :: */[
                short_opt,
                /* [] */0
              ];
      }
    } else if (match$4) {
      return match$4;
    } else {
      return /* [] */0;
    }
  }
}

function parse_opt_args(peek_opts, optidx, cl, args) {
  var loop = function (_errs, _k, _cl, _pargs, _param) {
    while(true) {
      var param = _param;
      var pargs = _pargs;
      var cl = _cl;
      var k = _k;
      var errs = _errs;
      if (param) {
        var s = param[0];
        if (s === "--") {
          return /* tuple */[
                  list.rev(errs),
                  cl,
                  list.rev_append(pargs, param[1])
                ];
        } else {
          var args = param[1];
          if (is_opt(s)) {
            var match = parse_opt_arg(s);
            var value = match[1];
            var name = match[0];
            var match$1 = cmdliner_trie_bs.find(optidx, name);
            if (typeof match$1 === "number") {
              if (match$1 >= -328798100) {
                var ambs = cmdliner_trie_bs.ambiguities(optidx, name);
                var ambs$1 = list.sort(caml_primitive.caml_string_compare, ambs);
                var err = cmdliner_base_bs.err_ambiguous("option", name, ambs$1);
                _param = args;
                _k = k + 1 | 0;
                _errs = /* :: */[
                  err,
                  errs
                ];
                continue ;
              } else if (peek_opts) {
                _param = args;
                _k = k + 1 | 0;
                continue ;
              } else {
                var hints = hint_matching_opt(optidx, s);
                var err$1 = cmdliner_base_bs.err_unknown(hints, "option", name);
                _param = args;
                _k = k + 1 | 0;
                _errs = /* :: */[
                  err$1,
                  errs
                ];
                continue ;
              }
            } else {
              var a = match$1[1];
              var match$2 = cmdliner_info_bs.arg_opt_kind(a);
              var match$3;
              if (value !== undefined) {
                match$3 = typeof match$2 === "number" && !(match$2 !== 0 || !is_short_opt(name)) ? /* tuple */[
                    undefined,
                    /* :: */[
                      "-" + value,
                      args
                    ]
                  ] : /* tuple */[
                    value,
                    args
                  ];
              } else {
                var exit = 0;
                if (typeof match$2 === "number" && match$2 === 0) {
                  match$3 = /* tuple */[
                    value,
                    args
                  ];
                } else {
                  exit = 1;
                }
                if (exit === 1) {
                  if (args) {
                    var v = args[0];
                    match$3 = is_opt(v) ? /* tuple */[
                        undefined,
                        args
                      ] : /* tuple */[
                        v,
                        args[1]
                      ];
                  } else {
                    match$3 = /* tuple */[
                      undefined,
                      args
                    ];
                  }
                }
                
              }
              var arg = /* O */block.__(0, [/* :: */[
                    /* tuple */[
                      k,
                      name,
                      match$3[0]
                    ],
                    opt_arg(cl, a)
                  ]]);
              _param = match$3[1];
              _cl = curry._3(Amap.add, a, arg, cl);
              _k = k + 1 | 0;
              continue ;
            }
          } else {
            _param = args;
            _pargs = /* :: */[
              s,
              pargs
            ];
            _k = k + 1 | 0;
            continue ;
          }
        }
      } else {
        return /* tuple */[
                list.rev(errs),
                cl,
                list.rev(pargs)
              ];
      }
    }  };
  var match = loop(/* [] */0, 0, cl, /* [] */0, args);
  var pargs = match[2];
  var cl$1 = match[1];
  var errs = match[0];
  if (errs === /* [] */0) {
    return /* Ok */block.__(0, [/* tuple */[
                cl$1,
                pargs
              ]]);
  } else {
    var err = string.concat("\n", errs);
    return /* Error */block.__(1, [/* tuple */[
                err,
                cl$1,
                pargs
              ]]);
  }
}

function take_range(start, stop, l) {
  var _i = 0;
  var _acc = /* [] */0;
  var _param = l;
  while(true) {
    var param = _param;
    var acc = _acc;
    var i = _i;
    if (param) {
      var vs = param[1];
      if (i < start) {
        _param = vs;
        _i = i + 1 | 0;
        continue ;
      } else if (i <= stop) {
        _param = vs;
        _acc = /* :: */[
          param[0],
          acc
        ];
        _i = i + 1 | 0;
        continue ;
      } else {
        return list.rev(acc);
      }
    } else {
      return list.rev(acc);
    }
  }}

function create$2($staropt$star, al, args) {
  var peek_opts = $staropt$star !== undefined ? $staropt$star : false;
  var match = arg_info_indexes(al);
  var match$1 = parse_opt_args(peek_opts, match[0], match[2], args);
  if (match$1.tag) {
    var match$2 = match$1[0];
    return /* Error */block.__(1, [/* tuple */[
                match$2[0],
                match$2[1]
              ]]);
  } else {
    var match$3 = match$1[0];
    var cl = match$3[0];
    if (peek_opts) {
      return /* Ok */block.__(0, [cl]);
    } else {
      var posidx = match[1];
      var cl$1 = cl;
      var pargs = match$3[1];
      if (pargs === /* [] */0) {
        var misses = list.filter(cmdliner_info_bs.arg_is_req)(posidx);
        if (misses === /* [] */0) {
          return /* Ok */block.__(0, [cl$1]);
        } else {
          return /* Error */block.__(1, [/* tuple */[
                      cmdliner_msg_bs.err_pos_misses(misses),
                      cl$1
                    ]]);
        }
      } else {
        var last = list.length(pargs) - 1 | 0;
        var pos = function (rev, k) {
          if (rev) {
            return last - k | 0;
          } else {
            return k;
          }
        };
        var loop = function (_misses, _cl, _max_spec, _param) {
          while(true) {
            var param = _param;
            var max_spec = _max_spec;
            var cl = _cl;
            var misses = _misses;
            if (param) {
              var a = param[0];
              var apos = cmdliner_info_bs.arg_pos(a);
              var rev = cmdliner_info_bs.pos_rev(apos);
              var start = pos(rev, cmdliner_info_bs.pos_start(apos));
              var match = cmdliner_info_bs.pos_len(apos);
              var stop = match !== undefined ? pos(rev, (cmdliner_info_bs.pos_start(apos) + match | 0) - 1 | 0) : pos(rev, last);
              var match$1 = rev ? /* tuple */[
                  stop,
                  start
                ] : /* tuple */[
                  start,
                  stop
                ];
              var stop$1 = match$1[1];
              var args = take_range(match$1[0], stop$1, pargs);
              var max_spec$1 = stop$1 > max_spec ? stop$1 : max_spec;
              var cl$1 = curry._3(Amap.add, a, /* P */block.__(1, [args]), cl);
              var match$2 = cmdliner_info_bs.arg_is_req(a) && args === /* [] */0;
              var misses$1 = match$2 ? /* :: */[
                  a,
                  misses
                ] : misses;
              _param = param[1];
              _max_spec = max_spec$1;
              _cl = cl$1;
              _misses = misses$1;
              continue ;
            } else {
              return /* tuple */[
                      misses,
                      cl,
                      max_spec
                    ];
            }
          }        };
        var match$4 = loop(/* [] */0, cl$1, -1, posidx);
        var max_spec = match$4[2];
        var cl$2 = match$4[1];
        var misses$1 = match$4[0];
        if (misses$1 !== /* [] */0) {
          return /* Error */block.__(1, [/* tuple */[
                      cmdliner_msg_bs.err_pos_misses(misses$1),
                      cl$2
                    ]]);
        } else if (last <= max_spec) {
          return /* Ok */block.__(0, [cl$2]);
        } else {
          var excess = take_range(max_spec + 1 | 0, last, pargs);
          return /* Error */block.__(1, [/* tuple */[
                      cmdliner_msg_bs.err_pos_excess(excess),
                      cl$2
                    ]]);
        }
      }
    }
  }
}

var create_1$2 = create$2;
var opt_arg_1 = opt_arg;
var pos_arg_1 = pos_arg;
var actual_args_1 = actual_args;
/* Amap Not a pure module */

var cmdliner_cline_bs = {
	create: create_1$2,
	opt_arg: opt_arg_1,
	pos_arg: pos_arg_1,
	actual_args: actual_args_1
};

function rev_compare$1(n0, n1) {
  return caml_obj.caml_compare(n1, n0);
}

var err_not_opt = "Option argument without name";

var err_not_pos = "Positional argument with a name";

function doc_alts_enum(quoted, $$enum) {
  return cmdliner_base_bs.alts_str(quoted, list.map((function (prim) {
                    return prim[0];
                  }), $$enum));
}

function str_of_pp(pp, v) {
  curry._2(pp, format.str_formatter, v);
  return format.flush_str_formatter(/* () */0);
}

function conv(docv, param) {
  var parse = param[0];
  var parse$1 = function (s) {
    var match = curry._1(parse, s);
    if (match.tag) {
      return /* `Error */[
              106380200,
              match[0][1]
            ];
    } else {
      return /* `Ok */[
              17724,
              match[0]
            ];
    }
  };
  return /* tuple */[
          parse$1,
          param[1]
        ];
}

function pconv(docv, conv) {
  return conv;
}

function conv_parser(param, s) {
  var match = curry._1(param[0], s);
  if (match[0] >= 106380200) {
    return /* Error */block.__(1, [/* `Msg */[
                3854881,
                match[1]
              ]]);
  } else {
    return /* Ok */block.__(0, [match[1]]);
  }
}

function conv_printer(param) {
  return param[1];
}

function conv_docv(param) {
  return "VALUE";
}

function err_invalid$1(s, kind) {
  return /* `Msg */[
          3854881,
          curry._2(printf_1.sprintf(/* Format */[
                    /* String_literal */block.__(11, [
                        "invalid value '",
                        /* String */block.__(2, [
                            /* No_padding */0,
                            /* String_literal */block.__(11, [
                                "', expected ",
                                /* String */block.__(2, [
                                    /* No_padding */0,
                                    /* End_of_format */0
                                  ])
                              ])
                          ])
                      ]),
                    "invalid value '%s', expected %s"
                  ]), s, kind)
        ];
}

function parser_of_kind_of_string(kind, k_of_string, s) {
  var match = curry._1(k_of_string, s);
  if (match !== undefined) {
    return /* Ok */block.__(0, [caml_option.valFromOption(match)]);
  } else {
    return /* Error */block.__(1, [err_invalid$1(s, kind)]);
  }
}

function $amp(f, x) {
  return curry._1(f, x);
}

function parse_to_list(parser, s) {
  var e = curry._1(parser, s);
  if (e[0] >= 106380200) {
    return e;
  } else {
    return /* `Ok */[
            17724,
            /* :: */[
              e[1],
              /* [] */0
            ]
          ];
  }
}

function try_env(ei, a, parse, absent) {
  var match = cmdliner_info_bs.arg_env(a);
  if (match !== undefined) {
    var env = caml_option.valFromOption(match);
    var $$var = cmdliner_info_bs.env_var(env);
    var match$1 = cmdliner_info_bs.eval_env_var(ei, $$var);
    if (match$1 !== undefined) {
      var match$2 = curry._1(parse, match$1);
      if (match$2[0] >= 106380200) {
        var e = cmdliner_msg_bs.err_env_parse(env, match$2[1]);
        return /* Error */block.__(1, [/* `Parse */[
                    -796721133,
                    e
                  ]]);
      } else {
        return /* Ok */block.__(0, [match$2[1]]);
      }
    } else {
      return /* Ok */block.__(0, [absent]);
    }
  } else {
    return /* Ok */block.__(0, [absent]);
  }
}

var arg_to_args = cmdliner_info_bs.Args.singleton;

function list_to_args(f, l) {
  var add = function (acc, v) {
    return curry._2(cmdliner_info_bs.Args.add, curry._1(f, v), acc);
  };
  return list.fold_left(add, cmdliner_info_bs.Args.empty, l);
}

function flag(a) {
  if (cmdliner_info_bs.arg_is_pos(a)) {
    return pervasives.invalid_arg(err_not_opt);
  } else {
    var convert = function (ei, cl) {
      var match = cmdliner_cline_bs.opt_arg(cl, a);
      if (match) {
        var match$1 = match[0];
        var match$2 = match$1[2];
        var f = match$1[1];
        if (match$2 !== undefined) {
          if (!match[1]) {
            var e = cmdliner_msg_bs.err_flag_value(f, match$2);
            return /* Error */block.__(1, [/* `Parse */[
                        -796721133,
                        e
                      ]]);
          }
          
        } else if (!match[1]) {
          return /* Ok */block.__(0, [true]);
        }
        var e$1 = cmdliner_msg_bs.err_opt_repeated(f, match[1][0][1]);
        return /* Error */block.__(1, [/* `Parse */[
                    -796721133,
                    e$1
                  ]]);
      } else {
        return try_env(ei, a, cmdliner_base_bs.env_bool_parse, false);
      }
    };
    return /* tuple */[
            curry._1(arg_to_args, a),
            convert
          ];
  }
}

function flag_all(a) {
  if (cmdliner_info_bs.arg_is_pos(a)) {
    return pervasives.invalid_arg(err_not_opt);
  } else {
    var a$1 = cmdliner_info_bs.arg_make_all_opts(a);
    var convert = function (ei, cl) {
      var l = cmdliner_cline_bs.opt_arg(cl, a$1);
      if (l) {
        try {
          var truth = function (param) {
            var v = param[2];
            if (v !== undefined) {
              return pervasives.failwith(cmdliner_msg_bs.err_flag_value(param[1], v));
            } else {
              return true;
            }
          };
          return /* Ok */block.__(0, [list.rev_map(truth, l)]);
        }
        catch (raw_exn){
          var exn = caml_js_exceptions.internalToOCamlException(raw_exn);
          if (exn[0] === caml_builtin_exceptions.failure) {
            return /* Error */block.__(1, [/* `Parse */[
                        -796721133,
                        exn[1]
                      ]]);
          } else {
            throw exn;
          }
        }
      } else {
        return try_env(ei, a$1, (function (param) {
                      return parse_to_list(cmdliner_base_bs.env_bool_parse, param);
                    }), /* [] */0);
      }
    };
    return /* tuple */[
            curry._1(arg_to_args, a$1),
            convert
          ];
  }
}

function vflag(v, l) {
  var convert = function (param, cl) {
    var aux = function (_fv, _param) {
      while(true) {
        var param = _param;
        var fv = _fv;
        if (param) {
          var rest = param[1];
          var match = param[0];
          var match$1 = cmdliner_cline_bs.opt_arg(cl, match[1]);
          if (match$1) {
            var match$2 = match$1[0];
            var match$3 = match$2[2];
            var f = match$2[1];
            if (match$3 !== undefined) {
              if (!match$1[1]) {
                return pervasives.failwith(cmdliner_msg_bs.err_flag_value(f, match$3));
              }
              
            } else if (!match$1[1]) {
              if (fv !== undefined) {
                return pervasives.failwith(cmdliner_msg_bs.err_opt_repeated(fv[0], f));
              } else {
                _param = rest;
                _fv = /* tuple */[
                  f,
                  match[0]
                ];
                continue ;
              }
            }
            return pervasives.failwith(cmdliner_msg_bs.err_opt_repeated(match$1[1][0][1], f));
          } else {
            _param = rest;
            continue ;
          }
        } else if (fv !== undefined) {
          return fv[1];
        } else {
          return v;
        }
      }    };
    try {
      return /* Ok */block.__(0, [aux(undefined, l)]);
    }
    catch (raw_exn){
      var exn = caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn[0] === caml_builtin_exceptions.failure) {
        return /* Error */block.__(1, [/* `Parse */[
                    -796721133,
                    exn[1]
                  ]]);
      } else {
        throw exn;
      }
    }
  };
  var flag = function (param) {
    var a = param[1];
    if (cmdliner_info_bs.arg_is_pos(a)) {
      return pervasives.invalid_arg(err_not_opt);
    } else {
      return a;
    }
  };
  return /* tuple */[
          list_to_args(flag, l),
          convert
        ];
}

function vflag_all(v, l) {
  var convert = function (param, cl) {
    var aux = function (_acc, _param) {
      while(true) {
        var param = _param;
        var acc = _acc;
        if (param) {
          var rest = param[1];
          var match = param[0];
          var fv = match[0];
          var l = cmdliner_cline_bs.opt_arg(cl, match[1]);
          if (l) {
            var fval = (function(fv){
            return function fval(param) {
              var v = param[2];
              if (v !== undefined) {
                return pervasives.failwith(cmdliner_msg_bs.err_flag_value(param[1], v));
              } else {
                return /* tuple */[
                        param[0],
                        fv
                      ];
              }
            }
            }(fv));
            _param = rest;
            _acc = list.rev_append(list.rev_map(fval, l), acc);
            continue ;
          } else {
            _param = rest;
            continue ;
          }
        } else if (acc === /* [] */0) {
          return v;
        } else {
          return list.rev_map((function (prim) {
                        return prim[1];
                      }), list.sort(rev_compare$1, acc));
        }
      }    };
    try {
      return /* Ok */block.__(0, [aux(/* [] */0, l)]);
    }
    catch (raw_exn){
      var exn = caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn[0] === caml_builtin_exceptions.failure) {
        return /* Error */block.__(1, [/* `Parse */[
                    -796721133,
                    exn[1]
                  ]]);
      } else {
        throw exn;
      }
    }
  };
  var flag = function (param) {
    var a = param[1];
    if (cmdliner_info_bs.arg_is_pos(a)) {
      return pervasives.invalid_arg(err_not_opt);
    } else {
      return cmdliner_info_bs.arg_make_all_opts(a);
    }
  };
  return /* tuple */[
          list_to_args(flag, l),
          convert
        ];
}

function parse_opt_value(parse, f, v) {
  var match = curry._1(parse, v);
  if (match[0] >= 106380200) {
    return pervasives.failwith(cmdliner_msg_bs.err_opt_parse(f, match[1]));
  } else {
    return match[1];
  }
}

function opt(vopt, param, v, a) {
  var print = param[1];
  var parse = param[0];
  if (cmdliner_info_bs.arg_is_pos(a)) {
    return pervasives.invalid_arg(err_not_opt);
  } else {
    var absent = /* Val */[caml_obj.caml_lazy_make((function (param) {
              return str_of_pp(print, v);
            }))];
    var kind = vopt !== undefined ? /* Opt_vopt */[str_of_pp(print, caml_option.valFromOption(vopt))] : /* Opt */1;
    var a$1 = cmdliner_info_bs.arg_make_opt(absent, kind, a);
    var convert = function (ei, cl) {
      var match = cmdliner_cline_bs.opt_arg(cl, a$1);
      if (match) {
        var match$1 = match[0];
        var match$2 = match$1[2];
        var f = match$1[1];
        if (match$2 !== undefined) {
          if (!match[1]) {
            try {
              return /* Ok */block.__(0, [parse_opt_value(parse, f, match$2)]);
            }
            catch (raw_exn){
              var exn = caml_js_exceptions.internalToOCamlException(raw_exn);
              if (exn[0] === caml_builtin_exceptions.failure) {
                return /* Error */block.__(1, [/* `Parse */[
                            -796721133,
                            exn[1]
                          ]]);
              } else {
                throw exn;
              }
            }
          }
          
        } else if (!match[1]) {
          if (vopt !== undefined) {
            return /* Ok */block.__(0, [caml_option.valFromOption(vopt)]);
          } else {
            var e = cmdliner_msg_bs.err_opt_value_missing(f);
            return /* Error */block.__(1, [/* `Parse */[
                        -796721133,
                        e
                      ]]);
          }
        }
        var e$1 = cmdliner_msg_bs.err_opt_repeated(match[1][0][1], f);
        return /* Error */block.__(1, [/* `Parse */[
                    -796721133,
                    e$1
                  ]]);
      } else {
        return try_env(ei, a$1, parse, v);
      }
    };
    return /* tuple */[
            curry._1(arg_to_args, a$1),
            convert
          ];
  }
}

function opt_all(vopt, param, v, a) {
  var parse = param[0];
  if (cmdliner_info_bs.arg_is_pos(a)) {
    return pervasives.invalid_arg(err_not_opt);
  } else {
    var kind = vopt !== undefined ? /* Opt_vopt */[str_of_pp(param[1], caml_option.valFromOption(vopt))] : /* Opt */1;
    var a$1 = cmdliner_info_bs.arg_make_opt_all(/* Val */[""], kind, a);
    var convert = function (ei, cl) {
      var l = cmdliner_cline_bs.opt_arg(cl, a$1);
      if (l) {
        var parse$1 = function (param) {
          var v = param[2];
          var f = param[1];
          var k = param[0];
          if (v !== undefined) {
            return /* tuple */[
                    k,
                    parse_opt_value(parse, f, v)
                  ];
          } else if (vopt !== undefined) {
            return /* tuple */[
                    k,
                    caml_option.valFromOption(vopt)
                  ];
          } else {
            return pervasives.failwith(cmdliner_msg_bs.err_opt_value_missing(f));
          }
        };
        try {
          return /* Ok */block.__(0, [list.rev_map((function (prim) {
                            return prim[1];
                          }), list.sort(rev_compare$1, list.rev_map(parse$1, l)))]);
        }
        catch (raw_exn){
          var exn = caml_js_exceptions.internalToOCamlException(raw_exn);
          if (exn[0] === caml_builtin_exceptions.failure) {
            return /* Error */block.__(1, [/* `Parse */[
                        -796721133,
                        exn[1]
                      ]]);
          } else {
            throw exn;
          }
        }
      } else {
        return try_env(ei, a$1, (function (param) {
                      return parse_to_list(parse, param);
                    }), v);
      }
    };
    return /* tuple */[
            curry._1(arg_to_args, a$1),
            convert
          ];
  }
}

function parse_pos_value(parse, a, v) {
  var match = curry._1(parse, v);
  if (match[0] >= 106380200) {
    return pervasives.failwith(cmdliner_msg_bs.err_pos_parse(a, match[1]));
  } else {
    return match[1];
  }
}

function pos$1($staropt$star, k, param, v, a) {
  var print = param[1];
  var parse = param[0];
  var rev = $staropt$star !== undefined ? $staropt$star : false;
  if (cmdliner_info_bs.arg_is_opt(a)) {
    return pervasives.invalid_arg(err_not_pos);
  } else {
    var absent = /* Val */[caml_obj.caml_lazy_make((function (param) {
              return str_of_pp(print, v);
            }))];
    var pos$1 = cmdliner_info_bs.pos(rev, k, 1);
    var a$1 = cmdliner_info_bs.arg_make_pos_abs(absent, pos$1, a);
    var convert = function (ei, cl) {
      var match = cmdliner_cline_bs.pos_arg(cl, a$1);
      if (match) {
        if (match[1]) {
          throw [
                caml_builtin_exceptions.assert_failure,
                /* tuple */[
                  "cmdliner_arg.ml",
                  225,
                  9
                ]
              ];
        }
        try {
          return /* Ok */block.__(0, [parse_pos_value(parse, a$1, match[0])]);
        }
        catch (raw_exn){
          var exn = caml_js_exceptions.internalToOCamlException(raw_exn);
          if (exn[0] === caml_builtin_exceptions.failure) {
            return /* Error */block.__(1, [/* `Parse */[
                        -796721133,
                        exn[1]
                      ]]);
          } else {
            throw exn;
          }
        }
      } else {
        return try_env(ei, a$1, parse, v);
      }
    };
    return /* tuple */[
            curry._1(arg_to_args, a$1),
            convert
          ];
  }
}

function pos_list(pos, param, v, a) {
  var parse = param[0];
  if (cmdliner_info_bs.arg_is_opt(a)) {
    return pervasives.invalid_arg(err_not_pos);
  } else {
    var a$1 = cmdliner_info_bs.arg_make_pos(pos, a);
    var convert = function (ei, cl) {
      var l = cmdliner_cline_bs.pos_arg(cl, a$1);
      if (l) {
        try {
          return /* Ok */block.__(0, [list.rev(list.rev_map((function (param) {
                                return parse_pos_value(parse, a$1, param);
                              }), l))]);
        }
        catch (raw_exn){
          var exn = caml_js_exceptions.internalToOCamlException(raw_exn);
          if (exn[0] === caml_builtin_exceptions.failure) {
            return /* Error */block.__(1, [/* `Parse */[
                        -796721133,
                        exn[1]
                      ]]);
          } else {
            throw exn;
          }
        }
      } else {
        return try_env(ei, a$1, (function (param) {
                      return parse_to_list(parse, param);
                    }), v);
      }
    };
    return /* tuple */[
            curry._1(arg_to_args, a$1),
            convert
          ];
  }
}

var all = cmdliner_info_bs.pos(false, 0, undefined);

function pos_all(c, v, a) {
  return pos_list(all, c, v, a);
}

function pos_left($staropt$star, k) {
  var rev = $staropt$star !== undefined ? $staropt$star : false;
  var start = rev ? k + 1 | 0 : 0;
  var len = rev ? undefined : k;
  var partial_arg = cmdliner_info_bs.pos(rev, start, len);
  return (function (param, param$1, param$2) {
      return pos_list(partial_arg, param, param$1, param$2);
    });
}

function pos_right($staropt$star, k) {
  var rev = $staropt$star !== undefined ? $staropt$star : false;
  var start = rev ? 0 : k + 1 | 0;
  var len = rev ? k : undefined;
  var partial_arg = cmdliner_info_bs.pos(rev, start, len);
  return (function (param, param$1, param$2) {
      return pos_list(partial_arg, param, param$1, param$2);
    });
}

function absent_error(args) {
  var make_req = function (a, acc) {
    var req_a = cmdliner_info_bs.arg_make_req(a);
    return curry._2(cmdliner_info_bs.Args.add, req_a, acc);
  };
  return curry._3(cmdliner_info_bs.Args.fold, make_req, args, cmdliner_info_bs.Args.empty);
}

function value$1(a) {
  return a;
}

function err_arg_missing$1(args) {
  var e = cmdliner_msg_bs.err_arg_missing(curry._1(cmdliner_info_bs.Args.choose, args));
  return /* Error */block.__(1, [/* `Parse */[
              -796721133,
              e
            ]]);
}

function required(param) {
  var convert = param[1];
  var args = absent_error(param[0]);
  var convert$1 = function (ei, cl) {
    var e = curry._2(convert, ei, cl);
    if (e.tag) {
      return e;
    } else {
      var match = e[0];
      if (match !== undefined) {
        return /* Ok */block.__(0, [caml_option.valFromOption(match)]);
      } else {
        return err_arg_missing$1(args);
      }
    }
  };
  return /* tuple */[
          args,
          convert$1
        ];
}

function non_empty(param) {
  var convert = param[1];
  var args = absent_error(param[0]);
  var convert$1 = function (ei, cl) {
    var e = curry._2(convert, ei, cl);
    if (e.tag) {
      return e;
    } else {
      var l = e[0];
      if (l) {
        return /* Ok */block.__(0, [l]);
      } else {
        return err_arg_missing$1(args);
      }
    }
  };
  return /* tuple */[
          args,
          convert$1
        ];
}

function last(param) {
  var convert = param[1];
  var args = param[0];
  var convert$1 = function (ei, cl) {
    var e = curry._2(convert, ei, cl);
    if (e.tag) {
      return e;
    } else {
      var l = e[0];
      if (l) {
        return /* Ok */block.__(0, [list.hd(list.rev(l))]);
      } else {
        return err_arg_missing$1(args);
      }
    }
  };
  return /* tuple */[
          args,
          convert$1
        ];
}

var man_fmts = /* :: */[
  /* tuple */[
    "auto",
    /* Auto */726666127
  ],
  /* :: */[
    /* tuple */[
      "pager",
      /* Pager */-797271261
    ],
    /* :: */[
      /* tuple */[
        "groff",
        /* Groff */757208580
      ],
      /* :: */[
        /* tuple */[
          "plain",
          /* Plain */-675583510
        ],
        /* [] */0
      ]
    ]
  ]
];

var man_fmt_docv = "FMT";

var man_fmts_enum = cmdliner_base_bs.$$enum(man_fmts);

var man_fmts_alts = doc_alts_enum(undefined, man_fmts);

function man_fmts_doc(kind) {
  return curry._2(printf_1.sprintf(/* Format */[
                  /* String_literal */block.__(11, [
                      "Show ",
                      /* String */block.__(2, [
                          /* No_padding */0,
                          /* String_literal */block.__(11, [
                              " in format $(docv). The value $(docv) must be ",
                              /* String */block.__(2, [
                                  /* No_padding */0,
                                  /* String_literal */block.__(11, [
                                      ". With `auto',\n        the format is `pager` or `plain' whenever the $(b,TERM) env var is\n        `dumb' or undefined.",
                                      /* End_of_format */0
                                    ])
                                ])
                            ])
                        ])
                    ]),
                  "Show %s in format $(docv). The value $(docv) must be %s. With `auto',\n        the format is `pager` or `plain' whenever the $(b,TERM) env var is\n        `dumb' or undefined."
                ]), kind, man_fmts_alts);
}

var doc = man_fmts_doc("output");

var man_format = opt(undefined, man_fmts_enum, /* Pager */-797271261, cmdliner_info_bs.arg(undefined, man_fmt_docv, doc, undefined, /* :: */[
          "man-format",
          /* [] */0
        ]));

function stdopt_version(docs) {
  return flag(cmdliner_info_bs.arg(docs, undefined, "Show version information.", undefined, /* :: */[
                  "version",
                  /* [] */0
                ]));
}

function stdopt_help(docs) {
  var doc = man_fmts_doc("this help");
  var partial_arg = cmdliner_base_bs.some(undefined, man_fmts_enum);
  var partial_arg$1 = /* Auto */726666127;
  return (function (param) {
              return opt(partial_arg$1, partial_arg, undefined, param);
            })(cmdliner_info_bs.arg(docs, man_fmt_docv, doc, undefined, /* :: */[
                  "help",
                  /* [] */0
                ]));
}

var some$2 = cmdliner_base_bs.some;

var env_var$1 = cmdliner_info_bs.env;

var info = cmdliner_info_bs.arg;

var bool$4 = cmdliner_base_bs.bool;

var $$char$2 = cmdliner_base_bs.$$char;

var $$int$4 = cmdliner_base_bs.$$int;

var nativeint$3 = cmdliner_base_bs.nativeint;

var int32$3 = cmdliner_base_bs.int32;

var int64$3 = cmdliner_base_bs.int64;

var $$float$4 = cmdliner_base_bs.$$float;

var string$4 = cmdliner_base_bs.string;

var $$enum$1 = cmdliner_base_bs.$$enum;

var file$2 = cmdliner_base_bs.file;

var dir$1 = cmdliner_base_bs.dir;

var non_dir_file$1 = cmdliner_base_bs.non_dir_file;

var list$3 = cmdliner_base_bs.list;

var array$3 = cmdliner_base_bs.array;

var pair$2 = cmdliner_base_bs.pair;

var t2$1 = cmdliner_base_bs.t2;

var t3$1 = cmdliner_base_bs.t3;

var t4$1 = cmdliner_base_bs.t4;

var doc_quote = cmdliner_base_bs.quote;

var doc_alts = cmdliner_base_bs.alts_str;

var conv_1 = conv;
var pconv_1 = pconv;
var conv_parser_1 = conv_parser;
var conv_printer_1 = conv_printer;
var conv_docv_1 = conv_docv;
var parser_of_kind_of_string_1 = parser_of_kind_of_string;
var some_1$2 = some$2;
var env_var_1$1 = env_var$1;
var info_1 = info;
var $amp_1 = $amp;
var flag_1 = flag;
var flag_all_1 = flag_all;
var vflag_1 = vflag;
var vflag_all_1 = vflag_all;
var opt_1 = opt;
var opt_all_1 = opt_all;
var pos_1$1 = pos$1;
var pos_all_1 = pos_all;
var pos_left_1 = pos_left;
var pos_right_1 = pos_right;
var value_1$1 = value$1;
var required_1 = required;
var non_empty_1 = non_empty;
var last_1 = last;
var man_format_1 = man_format;
var stdopt_version_1 = stdopt_version;
var stdopt_help_1 = stdopt_help;
var bool_1$3 = bool$4;
var $$char_1$2 = $$char$2;
var $$int_1$3 = $$int$4;
var nativeint_1$2 = nativeint$3;
var int32_1$2 = int32$3;
var int64_1$2 = int64$3;
var $$float_1$3 = $$float$4;
var string_1$3 = string$4;
var $$enum_1$1 = $$enum$1;
var file_1$2 = file$2;
var dir_1$1 = dir$1;
var non_dir_file_1$1 = non_dir_file$1;
var list_1$2 = list$3;
var array_1$2 = array$3;
var pair_1$2 = pair$2;
var t2_1$1 = t2$1;
var t3_1$1 = t3$1;
var t4_1$1 = t4$1;
var doc_quote_1 = doc_quote;
var doc_alts_1 = doc_alts;
var doc_alts_enum_1 = doc_alts_enum;
/* all Not a pure module */

var cmdliner_arg_bs = {
	conv: conv_1,
	pconv: pconv_1,
	conv_parser: conv_parser_1,
	conv_printer: conv_printer_1,
	conv_docv: conv_docv_1,
	parser_of_kind_of_string: parser_of_kind_of_string_1,
	some: some_1$2,
	env_var: env_var_1$1,
	info: info_1,
	$amp: $amp_1,
	flag: flag_1,
	flag_all: flag_all_1,
	vflag: vflag_1,
	vflag_all: vflag_all_1,
	opt: opt_1,
	opt_all: opt_all_1,
	pos: pos_1$1,
	pos_all: pos_all_1,
	pos_left: pos_left_1,
	pos_right: pos_right_1,
	value: value_1$1,
	required: required_1,
	non_empty: non_empty_1,
	last: last_1,
	man_format: man_format_1,
	stdopt_version: stdopt_version_1,
	stdopt_help: stdopt_help_1,
	bool: bool_1$3,
	$$char: $$char_1$2,
	$$int: $$int_1$3,
	nativeint: nativeint_1$2,
	int32: int32_1$2,
	int64: int64_1$2,
	$$float: $$float_1$3,
	string: string_1$3,
	$$enum: $$enum_1$1,
	file: file_1$2,
	dir: dir_1$1,
	non_dir_file: non_dir_file_1$1,
	list: list_1$2,
	array: array_1$2,
	pair: pair_1$2,
	t2: t2_1$1,
	t3: t3_1$1,
	t4: t4_1$1,
	doc_quote: doc_quote_1,
	doc_alts: doc_alts_1,
	doc_alts_enum: doc_alts_enum_1
};

function $$const(v) {
  return /* tuple */[
          cmdliner_info_bs.Args.empty,
          (function (param, param$1) {
              return /* Ok */block.__(0, [v]);
            })
        ];
}

function app$1(param, param$1) {
  var v = param$1[1];
  var f = param[1];
  return /* tuple */[
          curry._2(cmdliner_info_bs.Args.union, param[0], param$1[0]),
          (function (ei, cl) {
              var e = curry._2(f, ei, cl);
              if (e.tag) {
                return e;
              } else {
                var e$1 = curry._2(v, ei, cl);
                if (e$1.tag) {
                  return e$1;
                } else {
                  return /* Ok */block.__(0, [curry._1(e[0], e$1[0])]);
                }
              }
            })
        ];
}

var $$const_1 = $$const;
var app_1$1 = app$1;
/* Cmdliner_info Not a pure module */

var cmdliner_term_bs = {
	$$const: $$const_1,
	app: app_1$1
};

function ret(param) {
  var v = param[1];
  return /* tuple */[
          param[0],
          (function (ei, cl) {
              var e = curry._2(v, ei, cl);
              if (e.tag) {
                return e;
              } else {
                var err = e[0];
                if (err[0] >= 106380200) {
                  return /* Error */block.__(1, [err]);
                } else {
                  return /* Ok */block.__(0, [err[1]]);
                }
              }
            })
        ];
}

function term_result($staropt$star, param) {
  var v = param[1];
  var usage = $staropt$star !== undefined ? $staropt$star : false;
  return /* tuple */[
          param[0],
          (function (ei, cl) {
              var e = curry._2(v, ei, cl);
              if (e.tag) {
                return e;
              } else {
                var ok = e[0];
                if (ok.tag) {
                  return /* Error */block.__(1, [/* `Error */[
                              106380200,
                              /* tuple */[
                                usage,
                                ok[0][1]
                              ]
                            ]]);
                } else {
                  return ok;
                }
              }
            })
        ];
}

function cli_parse_result(param) {
  var v = param[1];
  return /* tuple */[
          param[0],
          (function (ei, cl) {
              var e = curry._2(v, ei, cl);
              if (e.tag) {
                return e;
              } else {
                var ok = e[0];
                if (ok.tag) {
                  return /* Error */block.__(1, [/* `Parse */[
                              -796721133,
                              ok[0][1]
                            ]]);
                } else {
                  return ok;
                }
              }
            })
        ];
}

var main_name_000 = cmdliner_info_bs.Args.empty;

function main_name_001(ei, param) {
  return /* Ok */block.__(0, [cmdliner_info_bs.term_name(cmdliner_info_bs.eval_main(ei))]);
}

var main_name = /* tuple */[
  main_name_000,
  main_name_001
];

var choice_name = cmdliner_info_bs.term_name;

var choice_names_000 = cmdliner_info_bs.Args.empty;

function choice_names_001(ei, param) {
  return /* Ok */block.__(0, [list.rev_map(choice_name, cmdliner_info_bs.eval_choices(ei))]);
}

var choice_names = /* tuple */[
  choice_names_000,
  choice_names_001
];

function with_used_args(param) {
  var v = param[1];
  var al = param[0];
  return /* tuple */[
          al,
          (function (ei, cl) {
              var e = curry._2(v, ei, cl);
              if (e.tag) {
                return e;
              } else {
                var actual_args = function (arg_info, acc) {
                  var args = cmdliner_cline_bs.actual_args(cl, arg_info);
                  return list.rev_append(args, acc);
                };
                var used = list.rev(curry._3(cmdliner_info_bs.Args.fold, actual_args, al, /* [] */0));
                return /* Ok */block.__(0, [/* tuple */[
                            e[0],
                            used
                          ]]);
              }
            })
        ];
}

var default_error_exits_000 = cmdliner_info_bs.exit(undefined, "on command line parsing errors.", undefined, 124);

var default_error_exits_001 = /* :: */[
  cmdliner_info_bs.exit(undefined, "on unexpected internal errors (bugs).", undefined, 125),
  /* [] */0
];

var default_error_exits = /* :: */[
  default_error_exits_000,
  default_error_exits_001
];

var default_exits_000 = cmdliner_info_bs.exit(undefined, "on success.", undefined, 0);

var default_exits = /* :: */[
  default_exits_000,
  default_error_exits
];

var partial_arg = caml_option.some(cmdliner_info_bs.Args.empty);

function info$1(param, param$1, param$2, param$3, param$4, param$5, param$6, param$7, param$8) {
  return cmdliner_info_bs.term(partial_arg, param, param$1, param$2, param$3, param$4, param$5, param$6, param$7, param$8);
}

var name = cmdliner_info_bs.term_name;

function err_multi_cmd_def(name, param, param$1) {
  return cmdliner_base_bs.err_multi_def("command", name, cmdliner_info_bs.term_doc, param[0], param$1[0]);
}

function add_stdopts(ei) {
  var docs = cmdliner_info_bs.term_stdopts_docs(cmdliner_info_bs.eval_term(ei));
  var match = cmdliner_info_bs.term_version(cmdliner_info_bs.eval_main(ei));
  var match$1;
  if (match !== undefined) {
    var vers = cmdliner_arg_bs.stdopt_version(docs);
    match$1 = /* tuple */[
      vers[0],
      vers
    ];
  } else {
    match$1 = /* tuple */[
      cmdliner_info_bs.Args.empty,
      undefined
    ];
  }
  var help = cmdliner_arg_bs.stdopt_help(docs);
  var args = curry._2(cmdliner_info_bs.Args.union, match$1[0], help[0]);
  var term = cmdliner_info_bs.term_add_args(cmdliner_info_bs.eval_term(ei), args);
  return /* tuple */[
          help,
          match$1[1],
          cmdliner_info_bs.eval_with_term(ei, term)
        ];
}

function run$2($$catch, ei, cl, f) {
  try {
    return curry._2(f, ei, cl);
  }
  catch (raw_exn){
    var exn = caml_js_exceptions.internalToOCamlException(raw_exn);
    if ($$catch) {
      var bt = printexc.get_raw_backtrace(/* () */0);
      return /* Error */block.__(1, [/* `Exn */[
                  3458171,
                  /* tuple */[
                    exn,
                    bt
                  ]
                ]]);
    } else {
      throw exn;
    }
  }
}

function try_eval_stdopts($$catch, ei, cl, help, version) {
  var err = run$2($$catch, ei, cl, help[1]);
  if (err.tag) {
    return err;
  } else {
    var match = err[0];
    if (match !== undefined) {
      return /* Error */block.__(1, [/* `Std_help */[
                  -689884355,
                  match
                ]]);
    } else if (version !== undefined) {
      var err$1 = run$2($$catch, ei, cl, version[1]);
      if (err$1.tag) {
        return err$1;
      } else if (err$1[0]) {
        return /* Error */block.__(1, [/* Std_version */114449436]);
      } else {
        return ;
      }
    } else {
      return ;
    }
  }
}

function term_eval($$catch, ei, f, args) {
  var match = add_stdopts(ei);
  var ei$1 = match[2];
  var version = match[1];
  var help = match[0];
  var term_args = cmdliner_info_bs.term_args(cmdliner_info_bs.eval_term(ei$1));
  var match$1 = cmdliner_cline_bs.create(undefined, term_args, args);
  var res;
  if (match$1.tag) {
    var match$2 = match$1[0];
    var match$3 = try_eval_stdopts($$catch, ei$1, match$2[1], help, version);
    res = match$3 !== undefined ? match$3 : /* Error */block.__(1, [/* `Error */[
            106380200,
            /* tuple */[
              true,
              match$2[0]
            ]
          ]]);
  } else {
    var cl = match$1[0];
    var match$4 = try_eval_stdopts($$catch, ei$1, cl, help, version);
    res = match$4 !== undefined ? match$4 : run$2($$catch, ei$1, cl, f);
  }
  return /* tuple */[
          ei$1,
          res
        ];
}

function do_help(help_ppf, err_ppf, ei, fmt, cmd) {
  var ei$1;
  if (cmd !== undefined) {
    var cmd$1 = cmd;
    try {
      var is_cmd = function (t) {
        return cmdliner_info_bs.term_name(t) === cmd$1;
      };
      var cmd$2 = list.find(is_cmd, cmdliner_info_bs.eval_choices(ei));
      ei$1 = cmdliner_info_bs.eval_with_term(ei, cmd$2);
    }
    catch (exn){
      if (exn === caml_builtin_exceptions.not_found) {
        ei$1 = pervasives.invalid_arg("Term error, help requested for unknown command " + cmd$1);
      } else {
        throw exn;
      }
    }
  } else {
    ei$1 = cmdliner_info_bs.eval_with_term(ei, cmdliner_info_bs.eval_main(ei));
  }
  var match = add_stdopts(ei$1);
  return cmdliner_docgen_bs.pp_man(err_ppf, fmt, help_ppf, match[2]);
}

function do_result(help_ppf, err_ppf, ei, param) {
  if (param.tag) {
    var res = param[0];
    if (typeof res === "number") {
      cmdliner_msg_bs.pp_version(help_ppf, ei);
      return /* Version */-901574920;
    } else {
      var variant = res[0];
      if (variant !== -689884355) {
        if (variant >= 106380200) {
          if (variant >= 803495649) {
            var match = res[1];
            do_help(help_ppf, err_ppf, ei, match[0], match[1]);
            return /* Help */803495649;
          } else {
            var match$1 = res[1];
            var err = match$1[1];
            if (match$1[0]) {
              cmdliner_msg_bs.pp_err_usage(err_ppf, ei, true, err);
            } else {
              cmdliner_msg_bs.pp_err(err_ppf, ei, err);
            }
            return /* `Error */[
                    106380200,
                    /* Term */936571788
                  ];
          }
        } else if (variant >= 3458171) {
          var match$2 = res[1];
          cmdliner_msg_bs.pp_backtrace(err_ppf, ei, match$2[0], match$2[1]);
          return /* `Error */[
                  106380200,
                  /* Exn */3458171
                ];
        } else {
          cmdliner_msg_bs.pp_err_usage(err_ppf, ei, false, res[1]);
          return /* `Error */[
                  106380200,
                  /* Parse */-796721133
                ];
        }
      } else {
        cmdliner_docgen_bs.pp_man(err_ppf, res[1], help_ppf, ei);
        return /* Help */803495649;
      }
    }
  } else {
    return /* `Ok */[
            17724,
            param[0]
          ];
  }
}

function env_default(v) {
  try {
    return caml_sys.caml_sys_getenv(v);
  }
  catch (exn){
    if (exn === caml_builtin_exceptions.not_found) {
      return ;
    } else {
      throw exn;
    }
  }
}

function remove_exec(argv) {
  try {
    return list.tl(array.to_list(argv));
  }
  catch (raw_exn){
    var exn = caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] === caml_builtin_exceptions.failure) {
      return pervasives.invalid_arg("argv array must have at least one element");
    } else {
      throw exn;
    }
  }
}

function $$eval$1($staropt$star, $staropt$star$1, $staropt$star$2, $staropt$star$3, $staropt$star$4, param) {
  var match = param[0];
  var help_ppf = $staropt$star !== undefined ? caml_option.valFromOption($staropt$star) : format.std_formatter;
  var err_ppf = $staropt$star$1 !== undefined ? caml_option.valFromOption($staropt$star$1) : format.err_formatter;
  var $$catch = $staropt$star$2 !== undefined ? $staropt$star$2 : true;
  var env = $staropt$star$3 !== undefined ? $staropt$star$3 : env_default;
  var argv = $staropt$star$4 !== undefined ? $staropt$star$4 : sys.argv;
  var term = cmdliner_info_bs.term_add_args(param[1], match[0]);
  var ei = cmdliner_info_bs.$$eval(term, term, /* [] */0, env);
  var args = remove_exec(argv);
  var match$1 = term_eval($$catch, ei, match[1], args);
  return do_result(help_ppf, err_ppf, match$1[0], match$1[1]);
}

function choose_term(main, choices, args) {
  if (args) {
    var maybe = args[0];
    if (maybe.length > 1 && caml_string.get(maybe, 0) === /* "-" */45) {
      return /* Ok */block.__(0, [/* tuple */[
                  main,
                  args
                ]]);
    } else {
      var add = function (acc, c) {
        var name = cmdliner_info_bs.term_name(c[0]);
        var match = cmdliner_trie_bs.add(acc, name, c);
        if (match[0] >= 3901504) {
          return match[1];
        } else {
          return pervasives.invalid_arg(err_multi_cmd_def(name, c, match[1][0]));
        }
      };
      var index = list.fold_left(add, cmdliner_trie_bs.empty, choices);
      var match = cmdliner_trie_bs.find(index, maybe);
      if (typeof match === "number") {
        if (match >= -328798100) {
          var ambs = cmdliner_trie_bs.ambiguities(index, maybe);
          var ambs$1 = list.sort(caml_primitive.caml_string_compare, ambs);
          return /* Error */block.__(1, [cmdliner_base_bs.err_ambiguous("command", maybe, ambs$1)]);
        } else {
          var all = cmdliner_trie_bs.ambiguities(index, "");
          var hints = cmdliner_suggest_bs.value(maybe, all);
          return /* Error */block.__(1, [cmdliner_base_bs.err_unknown(hints, "command", maybe)]);
        }
      } else {
        return /* Ok */block.__(0, [/* tuple */[
                    match[1],
                    args[1]
                  ]]);
      }
    }
  } else {
    return /* Ok */block.__(0, [/* tuple */[
                main,
                /* [] */0
              ]]);
  }
}

function eval_choice($staropt$star, $staropt$star$1, $staropt$star$2, $staropt$star$3, $staropt$star$4, main, choices) {
  var help_ppf = $staropt$star !== undefined ? caml_option.valFromOption($staropt$star) : format.std_formatter;
  var err_ppf = $staropt$star$1 !== undefined ? caml_option.valFromOption($staropt$star$1) : format.err_formatter;
  var $$catch = $staropt$star$2 !== undefined ? $staropt$star$2 : true;
  var env = $staropt$star$3 !== undefined ? $staropt$star$3 : env_default;
  var argv = $staropt$star$4 !== undefined ? $staropt$star$4 : sys.argv;
  var to_term_f = function (param) {
    var match = param[0];
    return /* tuple */[
            cmdliner_info_bs.term_add_args(param[1], match[0]),
            match[1]
          ];
  };
  var choices_f = list.rev_map(to_term_f, choices);
  var main_f = to_term_f(main);
  var choices$1 = list.rev_map((function (prim) {
          return prim[0];
        }), choices_f);
  var main$1 = main_f[0];
  var match = choose_term(main_f, choices_f, remove_exec(argv));
  if (match.tag) {
    var ei = cmdliner_info_bs.$$eval(main$1, main$1, choices$1, env);
    cmdliner_msg_bs.pp_err_usage(err_ppf, ei, false, match[0]);
    return /* `Error */[
            106380200,
            /* Parse */-796721133
          ];
  } else {
    var match$1 = match[0];
    var match$2 = match$1[0];
    var ei$1 = cmdliner_info_bs.$$eval(match$2[0], main$1, choices$1, env);
    var match$3 = term_eval($$catch, ei$1, match$2[1], match$1[1]);
    return do_result(help_ppf, err_ppf, match$3[0], match$3[1]);
  }
}

function eval_peek_opts($staropt$star, $staropt$star$1, $staropt$star$2, param) {
  var version_opt = $staropt$star !== undefined ? $staropt$star : false;
  var env = $staropt$star$1 !== undefined ? $staropt$star$1 : env_default;
  var argv = $staropt$star$2 !== undefined ? $staropt$star$2 : sys.argv;
  var version = version_opt ? "dummy" : undefined;
  var term = cmdliner_info_bs.term(caml_option.some(param[0]), undefined, undefined, undefined, undefined, undefined, undefined, undefined, version, "dummy");
  var ei = cmdliner_info_bs.$$eval(term, term, /* [] */0, env);
  var ei$1 = ei;
  var f = param[1];
  var args = remove_exec(argv);
  var match = add_stdopts(ei$1);
  var ei$2 = match[2];
  var version$1 = match[1];
  var help = match[0];
  var term_args = cmdliner_info_bs.term_args(cmdliner_info_bs.eval_term(ei$2));
  var match$1 = cmdliner_cline_bs.create(true, term_args, args);
  var match$2;
  if (match$1.tag) {
    var match$3 = match$1[0];
    var match$4 = try_eval_stdopts(true, ei$2, match$3[1], help, version$1);
    match$2 = match$4 !== undefined ? /* tuple */[
        undefined,
        match$4
      ] : /* tuple */[
        undefined,
        /* Error */block.__(1, [/* `Error */[
              106380200,
              /* tuple */[
                true,
                match$3[0]
              ]
            ]])
      ];
  } else {
    var cl = match$1[0];
    var ret = run$2(true, ei$2, cl, f);
    var v;
    v = ret.tag ? undefined : caml_option.some(ret[0]);
    var match$5 = try_eval_stdopts(true, ei$2, cl, help, version$1);
    match$2 = match$5 !== undefined ? /* tuple */[
        v,
        match$5
      ] : /* tuple */[
        v,
        ret
      ];
  }
  var ret$1 = match$2[1];
  var ret$2;
  if (ret$1.tag) {
    var match$6 = ret$1[0];
    if (typeof match$6 === "number") {
      ret$2 = /* Version */-901574920;
    } else {
      var variant = match$6[0];
      ret$2 = variant !== 3458171 ? (
          variant !== 106380200 ? (
              variant >= -796721132 ? /* Help */803495649 : /* `Error */[
                  106380200,
                  /* Parse */-796721133
                ]
            ) : /* `Error */[
              106380200,
              /* Term */936571788
            ]
        ) : /* `Error */[
          106380200,
          /* Exn */3458171
        ];
    }
  } else {
    ret$2 = /* `Ok */[
      17724,
      ret$1[0]
    ];
  }
  return /* tuple */[
          match$2[0],
          ret$2
        ];
}

function exit_status_of_result($staropt$star, param) {
  var term_err = $staropt$star !== undefined ? $staropt$star : 1;
  if (typeof param === "number" || param[0] < 106380200) {
    return 0;
  } else {
    var match = param[1];
    if (match !== 3458171) {
      if (match >= 936571788) {
        return term_err;
      } else {
        return 124;
      }
    } else {
      return 125;
    }
  }
}

function exit_status_of_status_result(term_err, r) {
  if (typeof r === "number" || r[0] !== 17724) {
    return exit_status_of_result(term_err, r);
  } else {
    return r[1];
  }
}

function exit$2(term_err, r) {
  return pervasives.exit(exit_status_of_result(term_err, r));
}

function exit_status(term_err, r) {
  return pervasives.exit(exit_status_of_status_result(term_err, r));
}

var Manpage = {
  $$escape: cmdliner_manpage_bs.$$escape,
  s_name: cmdliner_manpage_bs.s_name,
  s_synopsis: cmdliner_manpage_bs.s_synopsis,
  s_description: cmdliner_manpage_bs.s_description,
  s_commands: cmdliner_manpage_bs.s_commands,
  s_arguments: cmdliner_manpage_bs.s_arguments,
  s_options: cmdliner_manpage_bs.s_options,
  s_common_options: cmdliner_manpage_bs.s_common_options,
  s_exit_status: cmdliner_manpage_bs.s_exit_status,
  s_environment: cmdliner_manpage_bs.s_environment,
  s_environment_intro: cmdliner_manpage_bs.s_environment_intro,
  s_files: cmdliner_manpage_bs.s_files,
  s_bugs: cmdliner_manpage_bs.s_bugs,
  s_examples: cmdliner_manpage_bs.s_examples,
  s_authors: cmdliner_manpage_bs.s_authors,
  s_see_also: cmdliner_manpage_bs.s_see_also,
  print: cmdliner_manpage_bs.print
};

var Term = {
  $$const: cmdliner_term_bs.$$const,
  pure: cmdliner_term_bs.$$const,
  man_format: cmdliner_arg_bs.man_format,
  $: cmdliner_term_bs.app,
  app: cmdliner_term_bs.app,
  ret: ret,
  term_result: term_result,
  cli_parse_result: cli_parse_result,
  main_name: main_name,
  choice_names: choice_names,
  with_used_args: with_used_args,
  exit_info: cmdliner_info_bs.exit,
  default_exits: default_exits,
  default_error_exits: default_error_exits,
  env_info: cmdliner_info_bs.env,
  info: info$1,
  name: name,
  $$eval: $$eval$1,
  eval_choice: eval_choice,
  eval_peek_opts: eval_peek_opts,
  exit_status_success: 0,
  exit_status_cli_error: 124,
  exit_status_internal_error: 125,
  exit_status_of_result: exit_status_of_result,
  exit_status_of_status_result: exit_status_of_status_result,
  exit: exit$2,
  exit_status: exit_status
};

var Arg$1 = {
  conv: cmdliner_arg_bs.conv,
  pconv: cmdliner_arg_bs.pconv,
  conv_parser: cmdliner_arg_bs.conv_parser,
  conv_printer: cmdliner_arg_bs.conv_printer,
  conv_docv: cmdliner_arg_bs.conv_docv,
  parser_of_kind_of_string: cmdliner_arg_bs.parser_of_kind_of_string,
  some: cmdliner_arg_bs.some,
  env_var: cmdliner_arg_bs.env_var,
  info: cmdliner_arg_bs.info,
  $amp: cmdliner_arg_bs.$amp,
  flag: cmdliner_arg_bs.flag,
  flag_all: cmdliner_arg_bs.flag_all,
  vflag: cmdliner_arg_bs.vflag,
  vflag_all: cmdliner_arg_bs.vflag_all,
  opt: cmdliner_arg_bs.opt,
  opt_all: cmdliner_arg_bs.opt_all,
  pos: cmdliner_arg_bs.pos,
  pos_all: cmdliner_arg_bs.pos_all,
  pos_left: cmdliner_arg_bs.pos_left,
  pos_right: cmdliner_arg_bs.pos_right,
  value: cmdliner_arg_bs.value,
  required: cmdliner_arg_bs.required,
  non_empty: cmdliner_arg_bs.non_empty,
  last: cmdliner_arg_bs.last,
  man_format: cmdliner_arg_bs.man_format,
  bool: cmdliner_arg_bs.bool,
  $$char: cmdliner_arg_bs.$$char,
  $$int: cmdliner_arg_bs.$$int,
  nativeint: cmdliner_arg_bs.nativeint,
  int32: cmdliner_arg_bs.int32,
  int64: cmdliner_arg_bs.int64,
  $$float: cmdliner_arg_bs.$$float,
  string: cmdliner_arg_bs.string,
  $$enum: cmdliner_arg_bs.$$enum,
  file: cmdliner_arg_bs.file,
  dir: cmdliner_arg_bs.dir,
  non_dir_file: cmdliner_arg_bs.non_dir_file,
  list: cmdliner_arg_bs.list,
  array: cmdliner_arg_bs.array,
  pair: cmdliner_arg_bs.pair,
  t2: cmdliner_arg_bs.t2,
  t3: cmdliner_arg_bs.t3,
  t4: cmdliner_arg_bs.t4,
  doc_quote: cmdliner_arg_bs.doc_quote,
  doc_alts: cmdliner_arg_bs.doc_alts,
  doc_alts_enum: cmdliner_arg_bs.doc_alts_enum
};

var Manpage_1 = Manpage;
var Term_1 = Term;
var Arg_1$1 = Arg$1;
/* default_error_exits Not a pure module */

var cmdliner_bs = {
	Manpage: Manpage_1,
	Term: Term_1,
	Arg: Arg_1$1
};

sourceMapSupport.install();

((process.argv.shift()));

function packageNameKebab(projectPath) {
  return Utils_bs.kebab(path$1.basename(projectPath));
}

function packageNameKebabSansScope(projectPath) {
  return Utils_bs.removeScope(Utils_bs.kebab(path$1.basename(projectPath)));
}

function packageNameUpperCamelCase(projectPath) {
  return Utils_bs.upperCamelCasify(Utils_bs.removeScope(Utils_bs.kebab(path$1.basename(projectPath))));
}

var templateVersion = "0.0.0";

function packageLibName(projectPath) {
  return Utils_bs.removeScope(Utils_bs.kebab(path$1.basename(projectPath))) + "/library";
}

function packageTestName(projectPath) {
  return Utils_bs.removeScope(Utils_bs.kebab(path$1.basename(projectPath))) + "/test";
}

function substituteTemplateValues(projectPath, s) {
  return s.replace((/<PACKAGE_NAME_FULL>/g), Utils_bs.kebab(path$1.basename(projectPath))).replace((/<VERSION>/g), templateVersion).replace((/<PUBLIC_LIB_NAME>/g), Utils_bs.removeScope(Utils_bs.kebab(path$1.basename(projectPath))) + "/library").replace((/<TEST_LIB_NAME>/g), Utils_bs.removeScope(Utils_bs.kebab(path$1.basename(projectPath))) + "/test").replace((/<PACKAGE_NAME>/g), Utils_bs.kebab(path$1.basename(projectPath))).replace((/<PACKAGE_NAME_UPPER_CAMEL>/g), Utils_bs.upperCamelCasify(Utils_bs.removeScope(Utils_bs.kebab(path$1.basename(projectPath)))));
}

function stripTemplateExtension(s) {
  return s.replace("-template", "");
}

function substituteFileNames(projectPath, s) {
  return s.replace((/__PACKAGE_NAME_FULL__/g), Utils_bs.kebab(path$1.basename(projectPath))).replace((/__PACKAGE_NAME__/g), Utils_bs.kebab(path$1.basename(projectPath))).replace((/__PACKAGE_NAME_UPPER_CAMEL__/g), Utils_bs.upperCamelCasify(Utils_bs.removeScope(Utils_bs.kebab(path$1.basename(projectPath)))));
}

function isDirectoryEmpty(path) {
  if (fs.existsSync(path)) {
    return fs.readdirSync(path).length === 0;
  } else {
    return true;
  }
}

function askYesNoQuestion(question, onYes, onNo, param) {
  var rl = readline.createInterface({
        input: (process.stdin),
        output: (process.stdout)
      });
  return rl.question(question + " [y/n] ", (function (input) {
                var response = input.trim().toLowerCase();
                switch (response) {
                  case "n" :
                  case "no" :
                      curry._1(onNo, /* () */0);
                      return rl.close();
                  case "y" :
                  case "yes" :
                      curry._1(onYes, /* () */0);
                      return rl.close();
                  default:
                    return askYesNoQuestion(question, onYes, onNo);
                }
              }));
}

function forEachDirEnt(dir, f) {
  return Bindings_bs.Fs.readdir(dir).then((function (files) {
                  return Promise.all(files.map(curry.__1(f)));
                })).then((function (param) {
                return Promise.resolve(/* Ok */caml_chrome_debugger.variant("Ok", 0, [/* () */0]));
              }));
}

function scanDir(dir, f) {
  return forEachDirEnt(dir, (function (entry) {
                var entryPath = path$1.join(dir, entry);
                return curry._1(f, entryPath).then((function (param) {
                              return Bindings_bs.Fs.isDirectory(entryPath).then((function (isDir) {
                                            if (isDir) {
                                              return scanDir(entryPath, f);
                                            } else {
                                              return Promise.resolve(/* Ok */caml_chrome_debugger.variant("Ok", 0, [/* () */0]));
                                            }
                                          }));
                            }));
              }));
}

function copyBundledTemplate(projectPath) {
  var templatesDir = path$1.resolve(__dirname, "templates", "pesy-reason-template-0.1.0-alpha.3");
  return scanDir(templatesDir, (function (src) {
                var dest = src.replace(templatesDir, projectPath);
                return Bindings_bs.Fs.isDirectory(src).then((function (isDir) {
                                if (isDir) {
                                  return Bindings_bs.Fs.mkdir(false, true, dest);
                                } else {
                                  return Bindings_bs.Fs.copy(false, src, dest, /* () */0);
                                }
                              })).then((function (param) {
                              return Promise.resolve(/* Ok */caml_chrome_debugger.variant("Ok", 0, [/* () */0]));
                            }));
              }));
}

function bootstrap(projectPath, param) {
  if (param !== undefined) {
    return Bindings_bs.downloadGit(param, projectPath).then((function (param) {
                    return Bindings_bs.Rimraf.run(curry._2(Utils_bs.Path.$slash, projectPath, ".ci-self"));
                  })).then((function (param) {
                  if (param.tag) {
                    return Promise.resolve(/* Error */caml_chrome_debugger.variant("Error", 1, [param[0]]));
                  } else {
                    return Promise.resolve(/* Ok */caml_chrome_debugger.variant("Ok", 0, [/* () */0]));
                  }
                }));
  } else {
    return copyBundledTemplate(projectPath);
  }
}

function subst(projectPath, file) {
  return Bindings_bs.Fs.readFile(file).then((function (b) {
                    return Promise.resolve(Buffer.from(substituteTemplateValues(projectPath, b.toString())));
                  })).then((function (s) {
                  return Bindings_bs.Fs.writeFile(file, s);
                })).then((function (param) {
                return Promise.resolve((fs.renameSync(file, substituteFileNames(projectPath, file).replace("-template", "")), /* () */0));
              }));
}

function substitute(projectPath) {
  return Promise.all(walkSync(projectPath).map((function (file_or_dir) {
                        return curry._2(Utils_bs.Path.$slash, projectPath, file_or_dir);
                      })).filter((function (file_or_dir) {
                      return fs.statSync(file_or_dir).isFile();
                    })).map((function (param) {
                    return subst(projectPath, param);
                  })));
}

function runCommand(cmd, args, projectPath, message) {
  console.log("");
  console.log(message);
  return Cmd_bs.spawn(args, projectPath, cmd);
}

function setup$1(esy, template, projectPath) {
  return Utils_bs.ResultPromise.$great$great$pipe(Utils_bs.ResultPromise.$great$great$eq(Utils_bs.ResultPromise.$great$great$eq(Utils_bs.ResultPromise.$great$great$eq(Utils_bs.ResultPromise.$great$great$eq(Utils_bs.ResultPromise.$great$great$eq(Bindings_bs.Fs.mkdir(undefined, true, projectPath).then((function (param) {
                                        process.chdir(projectPath);
                                        return bootstrap(projectPath, template);
                                      })), (function (param) {
                                    console.log("");
                                    console.log("Setting up");
                                    return substitute(projectPath).then((function (_arrayOfCompletions) {
                                                  console.log("");
                                                  /* array */[
                                                      "azure-pipelines.yml",
                                                      curry._2(Utils_bs.Path.$slash, "library", "Util.re"),
                                                      curry._2(Utils_bs.Path.$slash, "test", "TestFile.re"),
                                                      curry._2(Utils_bs.Path.$slash, "test", "TestFramework.re"),
                                                      "README.md",
                                                      curry._2(Utils_bs.Path.$slash, "bin", Utils_bs.upperCamelCasify(Utils_bs.removeScope(Utils_bs.kebab(path$1.basename(projectPath)))) + "App.re"),
                                                      "dune-project",
                                                      Utils_bs.kebab(path$1.basename(projectPath)) + ".opam",
                                                      "package.json"
                                                    ].forEach((function (file) {
                                                          console.log(chalk.green("    created ") + chalk.whiteBright(file));
                                                          return /* () */0;
                                                        }));
                                                  return Promise.resolve(/* Ok */caml_chrome_debugger.variant("Ok", 0, [/* () */0]));
                                                }));
                                  })), (function (param) {
                                return runCommand(esy, /* array */["i"], projectPath, chalk.dim("Running") + chalk.whiteBright(" esy install"));
                              })), (function (param) {
                            return Warmup_bs.run(projectPath);
                          })), (function (param) {
                        return runCommand(esy, /* array */["pesy"], projectPath, chalk.dim("Running") + (chalk.whiteBright(" esy pesy") + (chalk.dim(" and ") + chalk.whiteBright("building project dependencies"))));
                      })), (function (param) {
                    return runCommand(esy, /* array */["b"], projectPath, chalk.dim("Running") + chalk.whiteBright(" esy build"));
                  })), (function (param) {
                console.log(chalk.green("Ready for development!"));
                return /* () */0;
              }));
}

function promptEmptyDirectory(param) {
  return new Promise((function (resolve, param) {
                return askYesNoQuestion("Current directory is not empty. Are you sure to continue?", (function (param) {
                              return Utils_bs.ResultPromise.ok(/* () */0);
                            }), (function (param) {
                              return Utils_bs.ResultPromise.fail(/* () */0);
                            }));
              }));
}

function handleEmptyDirectory(path, force) {
  if (isDirectoryEmpty(path) || force) {
    return Utils_bs.ResultPromise.ok(/* () */0);
  } else {
    return promptEmptyDirectory();
  }
}

function main$prime(projectPath, template, useDefaultOptions) {
  return Utils_bs.ResultPromise.$great$great$eq(Cmd_bs.make(process.env, "esy"), (function (esy) {
                    var match = path$1.isAbsolute(projectPath);
                    var projectPath$1 = match ? projectPath : path$1.join(process.cwd(), projectPath);
                    return Utils_bs.ResultPromise.$great$great$eq(handleEmptyDirectory(projectPath$1, useDefaultOptions), (function (param) {
                                  return setup$1(esy, template, projectPath);
                                }));
                  })).then((function (param) {
                  if (param.tag) {
                    return Promise.resolve((console.log(param[0]), /* () */0));
                  } else {
                    return Promise.resolve(/* () */0);
                  }
                })).catch(Bindings_bs.handlePromiseRejectInJS);
}

function warmup(param) {
  var projectPath = process.cwd();
  return Warmup_bs.run(projectPath).then((function (param) {
                if (param.tag) {
                  return Promise.resolve((console.log("Error", param[0]), /* () */0));
                } else {
                  return Promise.resolve(/* () */0);
                }
              }));
}

function main(projectPath, template, useDefaultOptions) {
  try {
    return main$prime(projectPath, template, useDefaultOptions);
  }
  catch (raw_exn){
    var exn = caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] === js_exn.$$Error) {
      var e = exn[1];
      var match = e.message;
      var message = match !== undefined ? match : "";
      var match$1 = e.stack;
      var stack = match$1 !== undefined ? match$1 : "";
      console.log(message);
      console.log(stack);
      return Promise.resolve(/* () */0);
    } else {
      throw exn;
    }
  }
}

var version$1 = "0.5.0-dev";

var partial_arg$1 = cmdliner_bs.Arg.some(undefined, cmdliner_bs.Arg.string);

var template = cmdliner_bs.Arg.$amp(cmdliner_bs.Arg.value, cmdliner_bs.Arg.$amp((function (param) {
            return cmdliner_bs.Arg.opt(undefined, partial_arg$1, undefined, param);
          }), cmdliner_bs.Arg.info(undefined, "TEMPLATE_URL", "Specify URL of the remote template. This can be of the form https://repo-url.git#<commit|branch|tag>. Eg: https://github.com/reason-native-web/morph-hello-world-pesy-template#6e5cbbb9f28", undefined, /* :: */caml_chrome_debugger.simpleVariant("::", [
                "t",
                /* :: */caml_chrome_debugger.simpleVariant("::", [
                    "template",
                    /* [] */0
                  ])
              ]))));

var partial_arg$1$1 = process.cwd();

var directory = cmdliner_bs.Arg.$amp(cmdliner_bs.Arg.value, cmdliner_bs.Arg.$amp((function (param) {
            return cmdliner_bs.Arg.opt(undefined, cmdliner_bs.Arg.string, partial_arg$1$1, param);
          }), cmdliner_bs.Arg.info(undefined, "INIT", "Initialises a new project at given directory", undefined, /* :: */caml_chrome_debugger.simpleVariant("::", [
                "init",
                /* [] */0
              ]))));

var useDefaultOptions = cmdliner_bs.Arg.$amp(cmdliner_bs.Arg.value, cmdliner_bs.Arg.$amp(cmdliner_bs.Arg.flag, cmdliner_bs.Arg.info(undefined, undefined, "Use default options", undefined, /* :: */caml_chrome_debugger.simpleVariant("::", [
                "y",
                /* :: */caml_chrome_debugger.simpleVariant("::", [
                    "yes",
                    /* [] */0
                  ])
              ]))));

var cmdT = cmdliner_bs.Term.$(cmdliner_bs.Term.$(cmdliner_bs.Term.$(cmdliner_bs.Term.$$const(main), directory), template), useDefaultOptions);

var cmd_001 = curry.app(cmdliner_bs.Term.info, [
      undefined,
      undefined,
      /* [] */0,
      /* [] */0,
      undefined,
      undefined,
      "Your Esy Assistant.",
      version$1,
      "pesy"
    ]);

var cmd = /* tuple */[
  cmdT,
  cmd_001
];

var cmdT$1 = cmdliner_bs.Term.$(cmdliner_bs.Term.$$const(warmup), cmdliner_bs.Term.$$const(/* () */0));

var warmupCmd_001 = curry.app(cmdliner_bs.Term.info, [
      undefined,
      undefined,
      /* [] */0,
      /* [] */0,
      undefined,
      undefined,
      "warmup - warms esy cache with prebuilts from CI",
      version$1,
      "warmup"
    ]);

var warmupCmd = /* tuple */[
  cmdT$1,
  warmupCmd_001
];

cmdliner_bs.Term.eval_choice(undefined, undefined, undefined, undefined, undefined, cmd, /* :: */caml_chrome_debugger.simpleVariant("::", [
        warmupCmd,
        /* [] */0
      ]));

var packageNameKebab_1 = packageNameKebab;
var packageNameKebabSansScope_1 = packageNameKebabSansScope;
var packageNameUpperCamelCase_1 = packageNameUpperCamelCase;
var templateVersion_1 = templateVersion;
var packageLibName_1 = packageLibName;
var packageTestName_1 = packageTestName;
var substituteTemplateValues_1 = substituteTemplateValues;
var stripTemplateExtension_1 = stripTemplateExtension;
var substituteFileNames_1 = substituteFileNames;
var isDirectoryEmpty_1 = isDirectoryEmpty;
var askYesNoQuestion_1 = askYesNoQuestion;
var forEachDirEnt_1 = forEachDirEnt;
var scanDir_1 = scanDir;
var copyBundledTemplate_1 = copyBundledTemplate;
var bootstrap_1 = bootstrap;
var subst_1 = subst;
var substitute_1 = substitute;
var runCommand_1 = runCommand;
var setup_1 = setup$1;
var promptEmptyDirectory_1 = promptEmptyDirectory;
var handleEmptyDirectory_1 = handleEmptyDirectory;
var main$prime_1 = main$prime;
var warmup_1 = warmup;
var main_1 = main;
var version_1 = version$1;
var template_1 = template;
var directory_1 = directory;
var useDefaultOptions_1 = useDefaultOptions;
var cmd_1 = cmd;
var warmupCmd_1 = warmupCmd;
/*  Not a pure module */

var Pesy_bs = {
	packageNameKebab: packageNameKebab_1,
	packageNameKebabSansScope: packageNameKebabSansScope_1,
	packageNameUpperCamelCase: packageNameUpperCamelCase_1,
	templateVersion: templateVersion_1,
	packageLibName: packageLibName_1,
	packageTestName: packageTestName_1,
	substituteTemplateValues: substituteTemplateValues_1,
	stripTemplateExtension: stripTemplateExtension_1,
	substituteFileNames: substituteFileNames_1,
	isDirectoryEmpty: isDirectoryEmpty_1,
	askYesNoQuestion: askYesNoQuestion_1,
	forEachDirEnt: forEachDirEnt_1,
	scanDir: scanDir_1,
	copyBundledTemplate: copyBundledTemplate_1,
	bootstrap: bootstrap_1,
	subst: subst_1,
	substitute: substitute_1,
	runCommand: runCommand_1,
	setup: setup_1,
	promptEmptyDirectory: promptEmptyDirectory_1,
	handleEmptyDirectory: handleEmptyDirectory_1,
	main$prime: main$prime_1,
	warmup: warmup_1,
	main: main_1,
	version: version_1,
	template: template_1,
	directory: directory_1,
	useDefaultOptions: useDefaultOptions_1,
	cmd: cmd_1,
	warmupCmd: warmupCmd_1
};

exports.askYesNoQuestion = askYesNoQuestion_1;
exports.bootstrap = bootstrap_1;
exports.cmd = cmd_1;
exports.copyBundledTemplate = copyBundledTemplate_1;
exports.default = Pesy_bs;
exports.directory = directory_1;
exports.forEachDirEnt = forEachDirEnt_1;
exports.handleEmptyDirectory = handleEmptyDirectory_1;
exports.isDirectoryEmpty = isDirectoryEmpty_1;
exports.main = main_1;
exports.main$prime = main$prime_1;
exports.packageLibName = packageLibName_1;
exports.packageNameKebab = packageNameKebab_1;
exports.packageNameKebabSansScope = packageNameKebabSansScope_1;
exports.packageNameUpperCamelCase = packageNameUpperCamelCase_1;
exports.packageTestName = packageTestName_1;
exports.promptEmptyDirectory = promptEmptyDirectory_1;
exports.runCommand = runCommand_1;
exports.scanDir = scanDir_1;
exports.setup = setup_1;
exports.stripTemplateExtension = stripTemplateExtension_1;
exports.subst = subst_1;
exports.substitute = substitute_1;
exports.substituteFileNames = substituteFileNames_1;
exports.substituteTemplateValues = substituteTemplateValues_1;
exports.template = template_1;
exports.templateVersion = templateVersion_1;
exports.useDefaultOptions = useDefaultOptions_1;
exports.version = version_1;
exports.warmup = warmup_1;
exports.warmupCmd = warmupCmd_1;
//# sourceMappingURL=pesy.bundle.js.map
